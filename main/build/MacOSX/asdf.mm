#include <xamarin/xamarin.h>
#include "asdf.h"
extern "C" {
static BOOL native_to_managed_trampoline_1 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static id native_to_managed_trampoline_2 (id self, SEL _cmd, MonoMethod **managed_method_ptr, bool* call_super, uint32_t token_ref)
{
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static id native_to_managed_trampoline_3 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCoder * p0, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static void native_to_managed_trampoline_4 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioPlayer * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_5 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioPlayer * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_6 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioRecorder * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_7 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioRecorder * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_8 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNotification * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_9 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_10 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMenuItem * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_11 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAlert * p0, NSInteger p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	void * a2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_12 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_13 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTimer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_14 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, NSObject * p1, NSDictionary * p2, void * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	void * a3 = p3;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &a3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_15 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSEvent * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_16 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_17 (id self, SEL _cmd, MonoMethod **managed_method_ptr, BOOL p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGSize native_to_managed_trampoline_18 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGRect native_to_managed_trampoline_19 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_20 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_21 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_22 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, NSView * p1, uint32_t token_ref)
{
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_23 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_24 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_25 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSInteger native_to_managed_trampoline_26 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_27 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_28 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, NSView * p1, NSText * p2, NSObject * p3, NSEvent * p4, uint32_t token_ref)
{
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_29 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, NSView * p1, NSText * p2, NSObject * p3, NSInteger p4, NSInteger p5, uint32_t token_ref)
{
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [6];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = &p4;
	arg_ptrs [5] = &p5;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_30 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSEvent * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_31 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, CGRect p1, NSView * p2, uint32_t token_ref)
{
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSInteger native_to_managed_trampoline_32 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_33 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGSize native_to_managed_trampoline_34 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGSize p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_35 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGSize p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSNumber * native_to_managed_trampoline_36 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSNumber * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_37 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_38 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_39 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? mono_string_new (mono_domain_get (), [p0 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSRange native_to_managed_trampoline_40 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSRange res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSRange *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGRect native_to_managed_trampoline_41 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRange p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_42 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSRange native_to_managed_trampoline_43 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSRange res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSRange *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_44 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRange p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSRange native_to_managed_trampoline_45 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSRange res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSRange *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_46 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMenu * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_47 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMenuItem * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_48 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMenu * p0, NSMenuItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_49 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMenuItem * p0, CGPoint p1, NSView * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_50 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_51 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSUInteger p1, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_52 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void ** p0, NSUInteger* p1, uint32_t token_ref)
{
	void ** a0 = 0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	*p0 = a0;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_53 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_54 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_55 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, void * p1, void * p2, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	void * a1 = p1;
	void * a2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &a1;
	arg_ptrs [2] = &a2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_56 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRunLoop * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_57 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_58 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSViewController * native_to_managed_trampoline_59 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSViewController * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_60 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_61 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_62 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_63 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, NSString * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_64 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_65 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CAAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_66 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CAAnimation * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_67 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_68 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSInputStream * p1, NSOutputStream * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_69 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_70 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSData * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_71 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_72 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSNetService * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_73 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_74 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_75 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, NULL, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_76 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, unsigned int p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_77 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_78 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSInteger p1, CLRegion * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum1 = p1;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_79 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLRegion * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_80 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_81 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_82 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLRegion * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_83 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_84 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLLocation * p1, CLLocation * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_85 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVCaptureFileOutput * p0, NSURL * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_86 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVCaptureFileOutput * p0, NSURL * p1, NSArray * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_87 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAlert * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_88 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_89 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, float p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_90 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static float native_to_managed_trampoline_91 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, float p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_92 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSStream * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSMenu * native_to_managed_trampoline_93 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSMenu * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_94 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_95 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_96 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_97 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSUserActivity * p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		arg_ptrs [2] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 2, p2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_98 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSCoder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_99 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSString * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_100 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_101 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_102 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_103 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_104 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_105 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDictionary * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_106 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, NSDictionary * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_107 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_108 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_109 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSArray * p0, NSArray * p1, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (p0) {
		NSArray *arr = (NSArray *) p0;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 0);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [0] = marr;
	} else {
		arg_ptrs [0] = NULL;
	}
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_110 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSData * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_111 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSUserActivity * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_112 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, CKShareMetadata * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSError * native_to_managed_trampoline_113 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSError * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_114 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_115 (id self, SEL _cmd, MonoMethod **managed_method_ptr, DOMEvent * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_116 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSClickGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_117 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_118 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_119 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSTextView * p1, SEL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? xamarin_get_selector (p2, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_120 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_121 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSTextView * p1, NSArray * p2, NSRange p3, NSInteger* p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	arg_ptrs [3] = &p3;
	arg_ptrs [4] = p4;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_122 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSArray * p2, NSRange p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_123 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_124 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_125 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSText * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_126 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDatePickerCell * p0, NSDate ** p1, double p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *mobj1 = NULL;
	NSObject *nsobj1 = NULL;
	MonoType *paramtype1 = NULL;
	void * handle1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = *(NSObject **) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr (nsobj1, false, paramtype1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = (int *) &mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (mobj1 != NULL)
	handle1 = xamarin_get_nsobject_handle (mobj1);
	if (p1 != NULL)
		*p1 = (id) handle1;

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_127 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebFrame * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_128 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebScriptObject * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_129 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, JSContext * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_130 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSError * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_131 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSImage * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_132 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_133 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURL * p1, double p2, NSDate * p3, WebFrame * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_134 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebScriptObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSWindow * native_to_managed_trampoline_135 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebDownload * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSWindow * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_136 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLAuthenticationChallenge * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_137 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSError * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_138 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_139 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURLRequest * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_140 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSError * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_141 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSInteger p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_142 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLResponse * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSURLRequest * native_to_managed_trampoline_143 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLRequest * p2, NSURLResponse * p3, WebDataSource * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSURLRequest * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_144 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_145 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static WebView * native_to_managed_trampoline_146 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURLRequest * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	WebView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_147 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, CGPoint p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_148 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_149 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_150 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_151 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, id<NSDraggingInfo> p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSResponder * native_to_managed_trampoline_152 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSResponder * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static float native_to_managed_trampoline_153 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_154 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_155 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSResponder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_156 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_157 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebFrameView * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_158 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_159 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_160 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_161 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_162 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSString * p2, WebFrame * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_163 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "WebKit.WebOpenPanelResultListenerWrapper, Xamarin.Mac", "WebKit.IWebOpenPanelResultListener, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_164 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_165 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, SEL p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_166 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_167 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, unsigned long long p1, id<NSDraggingInfo> p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_168 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, unsigned long long p1, CGPoint p2, NSPasteboard * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_169 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSURLRequest * p2, WebFrame * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_170 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, WebFrame * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_171 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, NSString * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = p3 ? mono_string_new (mono_domain_get (), [p3 UTF8String]) : NULL;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_172 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDocument * p0, BOOL p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	void * a2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_173 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUserNotificationCenter * p0, NSUserNotification * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_174 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUserNotificationCenter * p0, NSUserNotification * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_175 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSEvent * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_176 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSGestureRecognizer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_177 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_178 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSTouch * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_179 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_180 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDrawer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_181 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDrawer * p0, CGSize p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_182 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKGameCenterViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_183 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKAchievementViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_184 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_185 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_186 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, NSDictionary * p2, NSNumber * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_187 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_188 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_189 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_190 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_191 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBCentral * p1, CBCharacteristic * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_192 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBL2CAPChannel * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_193 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, unsigned short p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_194 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBATTRequest * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_195 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_196 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBService * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_197 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_198 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_199 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKFriendRequestComposeViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_200 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBL2CAPChannel * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_201 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBService * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_202 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBCharacteristic * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_203 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_204 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_205 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_206 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSNumber * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_207 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBDescriptor * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_208 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_209 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_210 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSImage * native_to_managed_trampoline_211 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static Class native_to_managed_trampoline_212 (id self, SEL _cmd, MonoMethod **managed_method_ptr, Class p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? xamarin_get_class (p0, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_get_class_handle (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_213 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFSelection * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static Class native_to_managed_trampoline_214 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? mono_string_new (mono_domain_get (), [p0 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_get_class_handle (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_215 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMagnificationGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_216 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKLeaderboardViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_217 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_218 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_219 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, GKPlayer * p2, GKPlayer * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_220 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, GKPlayer * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_221 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_222 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, GKPlayer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_223 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_224 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_225 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, GKPlayer * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_226 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_227 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_228 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, GKMatch * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_229 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_230 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, GKPlayer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_231 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_232 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_233 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, PDFActionRemoteGoTo * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_234 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSString * native_to_managed_trampoline_235 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_236 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, CGFloat p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_237 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_238 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_239 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_240 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_241 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSViewController * native_to_managed_trampoline_242 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSViewController * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_243 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSViewController * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_244 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SEL p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? xamarin_get_selector (p0, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_245 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPanGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_246 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_247 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_248 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_249 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static Class native_to_managed_trampoline_250 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSString * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_get_class_handle (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_251 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_252 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_253 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSObject * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_254 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPathCell * p0, NSOpenPanel * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_255 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPathCell * p0, NSMenu * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_256 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_257 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPressGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_258 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCache * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_259 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRotationGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_260 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSInteger p1, NSObject * p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	unsigned long long nativeEnum3 = p3;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &nativeEnum3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_261 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_262 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_263 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSObject * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_264 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSearchField * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSInteger native_to_managed_trampoline_265 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, NSString * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_266 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_267 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_268 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_269 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_270 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_271 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_272 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, NSError ** p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *mobj2 = NULL;
	void * handle2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = (int *) &mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (mobj2 != NULL)
	handle2 = xamarin_get_nsobject_handle (mobj2);
	if (p2 != NULL)
		*p2 = (id) handle2;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_273 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTableRowView * native_to_managed_trampoline_274 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTableRowView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_275 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableRowView * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_276 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSCell * native_to_managed_trampoline_277 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSCell * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_278 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, NSString * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = p3 ? mono_string_new (mono_domain_get (), [p3 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_279 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_280 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSIndexSet * native_to_managed_trampoline_281 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSIndexSet * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSIndexSet * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_282 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSCell * p1, CGRect* p2, NSTableColumn * p3, NSInteger p4, CGPoint p5, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [6];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = &p4;
	arg_ptrs [5] = &p5;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSView * native_to_managed_trampoline_283 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_284 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_285 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_286 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_287 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_288 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_289 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_290 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSCell * p1, NSTableColumn * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_291 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSEvent * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_292 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSObject * p1, NSTableColumn * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSView * native_to_managed_trampoline_293 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, CGRect* p1, NSUInteger* p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1;
	arg_ptrs [2] = p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_294 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_295 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_296 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "AppKit.NSPasteboardWritingWrapper, Xamarin.Mac", "AppKit.INSPasteboardWriting, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSWindow * native_to_managed_trampoline_297 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSWindow * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSImage * native_to_managed_trampoline_298 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, id p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "AppKit.NSPasteboardWritingWrapper, Xamarin.Mac", "AppKit.INSPasteboardWriting, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_299 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSound * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static id native_to_managed_trampoline_300 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSSharingService * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_301 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSSharingService * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_302 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_303 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextStorage * p0, NSUInteger p1, NSRange p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_304 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_305 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSCoder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_306 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_307 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSEvent * p1, CGPoint p2, NSPasteboard * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_308 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSMenu * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_309 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_310 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, double p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_311 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSWindow * p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_312 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGSize p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_313 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGSize p1, CGSize p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_314 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUndoManager * native_to_managed_trampoline_315 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUndoManager * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_316 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGRect native_to_managed_trampoline_317 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_318 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_319 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_320 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_321 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKDeviceBrowserView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_322 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, NSTabViewItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_323 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_324 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, NSTabViewItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_325 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSEvent * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_326 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_327 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSInteger p1, NSEvent * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_328 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_329 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKSaveOptions * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_330 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSText * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_331 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_332 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSURL * p1, NSData * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_333 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSError * p1, uint32_t token_ref)
{
	void * a0 = p0;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSTouchBarItem * native_to_managed_trampoline_334 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTouchBar * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTouchBarItem * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_335 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, CGRect p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_336 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, unsigned long long p2, NSDictionary * p3, NSArray * p4, NSOrthography * p5, NSInteger p6, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj5 = NULL;
	MonoObject *mobj5 = NULL;
	int32_t created5 = false;
	MonoType *paramtype5 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [7];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		NSArray *arr = (NSArray *) p4;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 4);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj4 = NULL;
			if (nobj) {
				mobj4 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj4);
		}
		arg_ptrs [4] = marr;
	} else {
		arg_ptrs [4] = NULL;
	}
	nsobj5 = (NSObject *) p5;
	if (nsobj5) {
		paramtype5 = xamarin_get_parameter_type (managed_method, 5);
		mobj5 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj5, false, paramtype5, &created5, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [5] = mobj5;
	arg_ptrs [6] = &p6;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_337 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, SEL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_338 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, CGRect p2, NSEvent * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_339 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_340 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSRange p2, NSInteger* p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_341 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUndoManager * native_to_managed_trampoline_342 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUndoManager * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_343 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_344 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSObject * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSMenu * native_to_managed_trampoline_345 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSMenu * p1, NSEvent * p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSMenu * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_346 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_347 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_348 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSDictionary * p1, NSDictionary * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_349 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_350 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSInteger p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_351 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSRange native_to_managed_trampoline_352 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSRange res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSRange *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_353 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_354 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSDictionary * p2, unsigned long long p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_355 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSString * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_356 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, NSUInteger p2, NSPasteboard * p3, NSString * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = p4 ? mono_string_new (mono_domain_get (), [p4 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_357 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMetadataQuery * p0, NSMetadataItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_358 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMetadataQuery * p0, NSString * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_359 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSToolbar * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSToolbarItem * native_to_managed_trampoline_360 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSToolbar * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSToolbarItem * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_361 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SCNPhysicsWorld * p0, SCNPhysicsContact * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_362 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKAnnotationView * p1, NSUInteger p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	unsigned long long nativeEnum3 = p3;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;
	arg_ptrs [3] = &nativeEnum3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static MKClusterAnnotation * native_to_managed_trampoline_363 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKClusterAnnotation * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				MonoType *type1;
				type1 = xamarin_get_parameter_type (managed_method, 1);
				mobj1 = xamarin_get_inative_object_dynamic (nobj, false, mono_type_get_object (mono_domain_get (), mono_class_get_type (e_class)), &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_364 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_365 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKAnnotationView * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_366 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_367 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_368 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_369 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKUserLocation * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static MKAnnotationView * native_to_managed_trampoline_370 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKAnnotationView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "MapKit.MKAnnotationWrapper, Xamarin.Mac", "MapKit.IMKAnnotation, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static MKOverlayRenderer * native_to_managed_trampoline_371 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKOverlayRenderer * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "MapKit.MKOverlayWrapper, Xamarin.Mac", "MapKit.IMKOverlay, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_372 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKPhysicsContact * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_373 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKRequest * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_374 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKRequest * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_375 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKProductsRequest * p0, SKProductsResponse * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_376 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSURLResponse * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_377 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSData * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_378 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_379 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSCachedURLResponse * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_380 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSHTTPURLResponse * p2, NSURLRequest * p3, id p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		arg_ptrs [4] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 4, p4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [4] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_381 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSURLAuthenticationChallenge * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_382 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAppleEventDescriptor * p0, NSAppleEventDescriptor * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_383 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_384 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, id<NSDraggingInfo> p1, NSObject * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_385 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSURL * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_386 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSInteger p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_387 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_388 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSTableColumn * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_389 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSObject * p1, NSTableColumn * p2, NSObject * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_390 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_391 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_392 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSArray * p1, NSPasteboard * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_393 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_394 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, id<NSDraggingInfo> p1, NSObject * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_395 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_396 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, id<NSDraggingInfo> p1, NSInteger p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum3 = p3;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &nativeEnum3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_397 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSURL * p1, NSIndexSet * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_398 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_399 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, id<NSDraggingInfo> p1, NSInteger p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum3 = p3;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &nativeEnum3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_400 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSIndexSet * p1, NSPasteboard * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_401 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSComboBox * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_402 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSComboBox * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_403 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_404 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static double native_to_managed_trampoline_405 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	double res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(double *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_406 (id self, SEL _cmd, MonoMethod **managed_method_ptr, double p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static double native_to_managed_trampoline_407 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	double res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(double *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSColor * native_to_managed_trampoline_408 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSColor * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_409 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSColor * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	nsobj0 = [nsobj0 copy];
	[nsobj0 autorelease];
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_410 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSFontPanel * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_411 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_412 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSAppearance * native_to_managed_trampoline_413 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSAppearance * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_414 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSOutlineView * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_415 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	nsobj0 = [nsobj0 copy];
	[nsobj0 autorelease];
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_416 (id self, SEL _cmd, MonoMethod **managed_method_ptr, BOOL p0, CGRect p1, NSView * p2, uint32_t token_ref)
{
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_417 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSEvent * p0, CGRect p1, NSView * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_418 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSEvent * p0, CGRect p1, NSView * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_419 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	MonoType *type0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	type0 = xamarin_get_parameter_type (managed_method, 0);
	arg_ptrs [0] = xamarin_get_inative_object_dynamic (p0, false, mono_type_get_object (mono_domain_get (), type0), &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSTextView * native_to_managed_trampoline_420 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTextView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_421 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableColumn * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_422 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSIndexSet * p0, NSIndexSet * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_423 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}




@implementation CoreImage_CIAccordionFoldTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xDD59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0xDD89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICompositingFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x21E79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAdditionCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xE119C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0xE149C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0xE4A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineClamp {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xE449C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0xE479C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xEE99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0xEEC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTransform {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x113D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x11409C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x115E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x11619C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaHistogram {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x11A49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x11A79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximum {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x11E49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x11E79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximumAlpha {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x11F89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x11FB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimum {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x12199C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x121C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimumAlpha {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x12529C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x12559C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMaxRed {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x14719C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x14749C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIImageGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x4FD49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAttributedTextImageGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x14CC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x14CF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1D579C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAztecCodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x15669C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x15699C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarcodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x164F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x16529C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICmykHalftone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1D199C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1D1C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICMYKHalftone {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x16E39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICmykHalftone class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation CoreImage_CITransitionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6D1C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarsSwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x16E59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x16E89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBicubicScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x17079C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x170A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x17BE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x19E99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x19EC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithAlphaMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x19349C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x19379C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithBlueMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x19859C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x19889C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithRedMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1A059C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1A089C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1A0C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1A0F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x54B29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBokehBlur {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1A289C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1A2B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBoxBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1A889C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1A8B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDistortionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2AA49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1AA79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1AAA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortionLinear {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1AE19C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1AE49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICheckerboardGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1B3B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1B3E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircleSplashDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1BDE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1BE19C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x677A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1C1C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1C1F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularWrap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1C279C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1C2A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1CB59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1CB89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICode128BarcodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1D299C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1D2C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1E0F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1E129C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1E159C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1E189C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1E1B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1E1E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorControls {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1E449C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1E479C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCrossPolynomial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1E549C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1E579C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCube {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1E7F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1E829C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubesMixedWithMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1ECE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x1ED19C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubeWithColorSpace {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x20239C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x20269C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCurves {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x20669C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x20699C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x20799C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x207C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorInvert {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x207D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x20809C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x20AD9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x20B09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMatrix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x20B39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x20B69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMonochrome {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x20C19C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x20C49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPolynomial {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x21699C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x216C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPosterize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x21939C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x21969C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColumnAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x21AD9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x21B09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIComicEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x21C69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x21C99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConstantColorGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x22549C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x22579C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionCore {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x25B99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution3X3 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x24419C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x24449C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution5X5 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x24BB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x24BE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution7X7 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x25009C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x25039C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Horizontal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x252D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x25309C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Vertical {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x255E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x25619C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICopyMachineTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x25C69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x25C99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x25E29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x25E59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrystallize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x26289C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x262B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDarkenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x26929C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x26959C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthBlurEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x27329C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x27359C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthDisparityConverter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x27AE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthOfField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x28809C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x28839C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthToDisparity {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x29059C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x29089C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDifferenceBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x298C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x298F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDiscBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x29BB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x29BE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisintegrateWithMaskTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x29E09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x29E39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisparityToDepth {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2A4B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2A4E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisplacementDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2A659C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2A689C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDissolveTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2A809C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2A839C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDivideBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2B299C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2B2C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDotScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2B539C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2B569C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDroste {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2B959C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2B989C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgePreserveUpsampleFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2BD99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2BDC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdges {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2C129C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2C159C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgeWork {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2C919C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2C949C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITileFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6C859C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEightfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2CDA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2CDD9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExclusionBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2D369C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2D399C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExposureAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2D5A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2D5D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFaceBalance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x2D8A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFalseColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x312F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x31329C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFlashTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x36329C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x36359C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x36609C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x36639C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldRotatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x367E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x36819C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldTranslatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x36989C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x369B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGammaAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x37019C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x37049C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x37409C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x37439C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x37559C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x37589C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x377A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x377D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassLozenge {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x37BB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x37BE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlideReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x37FC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x37FF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x38279C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x382A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHardLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x387D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x38809C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHatchedScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x47909C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x47939C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHeightFieldFromMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x47969C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x47999C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHexagonalPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x47E89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x47EB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHighlightShadowAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x48519C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x48549C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHistogramDisplayFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x48C09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x48C39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHoleDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x48E49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x48E79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x49039C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x49069C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x491B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x491E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueSaturationValueGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x495E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x49619C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end


@implementation CoreImage_CIKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x52239C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x52269C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILabDeltaE {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x532B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x532E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILanczosScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x536D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x53709C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILenticularHaloGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x53839C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x53869C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x53AA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x53AD9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightTunnel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x54759C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x54789C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x54C99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x54CC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x54F79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x54FA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x55019C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x55049C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearToSRGBToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x56179C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x561A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineOverlay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x567C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x567F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x56C29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x56C59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILuminosityBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x57399C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x573C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskedVariableBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x575C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x575F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskToAlpha {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x578F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x57929C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x58E69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x58E99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x592E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x59319C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMedianFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x59379C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x593A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x59A99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x59AC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x59CF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x59D29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIModTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x59D99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x59DC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphology {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5A4A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyGradient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5A8C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5A8F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMaximum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5AA79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5AAA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMinimum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5ADF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5AE29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMotionBlur {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5B109C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5B139C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5B519C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5B549C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5B749C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5B779C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartStretched {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5BB29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5BB59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartTiled {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5BD39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5BD69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINoiseReduction {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5C329C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5C359C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOpTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5C579C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5C5A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOverlayBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5C639C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5C669C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5C819C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5C849C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlWithShadowTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5C8F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5C929C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIParallelogramTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5CC69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5CC99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPdf417BarcodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5CCC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5CCF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5E7F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5E829C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveCorrection {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5E2A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5E2D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTile {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5E499C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5E4C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransformWithExtent {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5EFB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5EFE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5F059C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectChrome {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5F1E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5F219C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectFade {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5F629C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5F659C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectInstant {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5F669C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5F699C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectMono {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5F8D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5F909C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectNoir {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5FA69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5FA99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectProcess {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5FB99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5FBC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTonal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5FBD9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x5FC09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTransfer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x60099C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x600C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinchDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x600D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x60109C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x60139C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x60169C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x604F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x60529C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPointillize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x605F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x60629C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIQRCodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x61549C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x61579C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRadialGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x61B59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x61B89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRandomGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x61E69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x61E99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRippleTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x66D39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x66D69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRowAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x66E29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x66E59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaturationBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x670C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x670F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x67749C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x67779C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISepiaTone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x678F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x67929C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIShadedMaterial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x67A39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x67A69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISharpenLuminance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x67B99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x67BC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x67D79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x67DA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldRotatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x67DB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x67DE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISmoothLinearGradient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x67E99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x67EC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISoftLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x67F59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x67F89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceAtopCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x680C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x680F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceInCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x68C19C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x68C49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOutCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x68D09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x68D39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOverCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x69079C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x690A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x69139C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x69169C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotLight {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x69589C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x695B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISRGBToneCurveToLinear {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x69849C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x69879C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStarShineGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x69B59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x69B89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStraightenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6A119C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6A149C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStretchCrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6A319C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6A349C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStripesGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6AC69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6AC99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISubtractBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6AF89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6AFB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISunbeamsGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6B309C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6B339C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6B7B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6B7E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITemperatureAndTint {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6BB69C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6BB99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITextImageGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6C3F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6C429C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIThermal {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6C6F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6C729C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6C939C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6C969C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITorusLensDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6CB59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6CB89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6D3C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6D3F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6D5D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6D609C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwelvefoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6D839C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6D869C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwirlDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6D8D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6D909C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIUnsharpMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6E219C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6E249C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVibrance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6EB99C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6EBC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignette {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6EDF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6EE29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignetteEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6EEF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6EF29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVortexDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6F369C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x6F399C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIWhitePointAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x7DCE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x7DD19C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIXRay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x7DD49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x7DD79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIZoomBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x7DDF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, &call_super, 0x7DE29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@interface AVFoundation_InternalAVAudioPlayerDelegate : NSObject<AVAudioPlayerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1;
	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioPlayerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, p1, 0x8A1E9C);
	}

	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, p0, p1, 0x8A1F9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x8A1D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_InternalAVAudioRecorderDelegate : NSObject<AVAudioRecorderDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1;
	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioRecorderDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, p1, 0x8A219C);
	}

	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_7 (self, _cmd, &managed_method, p0, p1, 0x8A229C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x8A209C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end



@interface Foundation_InternalNSNotificationHandler : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) post:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_InternalNSNotificationHandler {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) post:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xB1709C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation Foundation_NSUrlProtocolClient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface __monomac_internal_ActionDispatcher : NSObject<NSMenuValidation> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) __monomac_internal_ActionDispatcher_activated:(NSObject *)p0;
	-(void) __monomac_internal_ActionDispatcher_doubleActivated:(NSObject *)p0;
	-(BOOL) validateMenuItem:(NSMenuItem *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __monomac_internal_ActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) __monomac_internal_ActionDispatcher_activated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0xC4F09C);
	}

	-(void) __monomac_internal_ActionDispatcher_doubleActivated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0xC4F19C);
	}

	-(BOOL) validateMenuItem:(NSMenuItem *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, p0, 0xC4F69C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xC4EF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSAlertDidEndDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) alertDidEnd:(NSAlert *)p0 returnCode:(NSInteger)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoMac_NSAlertDidEndDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) alertDidEnd:(NSAlert *)p0 returnCode:(NSInteger)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_11 (self, _cmd, &managed_method, p0, p1, p2, 0xC81A9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end




@interface __MonoMac_NSActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinApplySelector;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoMac_NSActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x110DE9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface __MonoMac_ActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinApplySelector;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoMac_ActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x110E19C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface __Xamarin_NSTimerActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinFireSelector:(NSTimer *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __Xamarin_NSTimerActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinFireSelector:(NSTimer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x110E49C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface __MonoMac_NSAsyncActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinApplySelector;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoMac_NSAsyncActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x110E79C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation Xwt_Mac_WindowBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x17AA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x158A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSWindow class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation MonoDevelop_MacIntegration_ThemedMacWindowBackend {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x19E0C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xwt_Mac_WindowBackend class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_DialogBackend {
}

	-(void) cancelOperation:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x4F9A2);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x4F7A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xwt_Mac_WindowBackend class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation MonoDevelop_MacIntegration_ThemedMacDialogBackend {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1A00C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xwt_Mac_DialogBackend class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_AlertDialogBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3E8A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSAlert class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation MonoDevelop_MacIntegration_ThemedMacAlertDialogBackend {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1A20C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xwt_Mac_AlertDialogBackend class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MDLabel : NSTextField {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_MacIntegration_MDLabel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_MacIntegration_AlertButtonWrapper : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) buttonActivatedAction;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_MacIntegration_AlertButtonWrapper {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) buttonActivatedAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x21C0C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_NSFocusButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) keyDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x38A0C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x38C0C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface RunButton : MonoDevelop_MacIntegration_MainToolbar_NSFocusButton<NSAccessibilityButton, NSAccessibility> {
}
	-(BOOL) isEnabled;
	-(void) setEnabled:(BOOL)p0;
	-(BOOL) accessibilityPerformPress;
	-(CGSize) intrinsicContentSize;
	-(CGRect) accessibilityFrame;
	-(NSString *) accessibilityIdentifier;
	-(NSObject *) accessibilityParent;
	-(BOOL) isAccessibilityFocused;
	-(NSString *) accessibilityLabel;
	-(id) init;
@end

@implementation RunButton {
}

	-(BOOL) isEnabled
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x2910C);
	}

	-(void) setEnabled:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, 0x2920C);
	}

	-(BOOL) accessibilityPerformPress
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x2960C);
	}

	-(CGSize) intrinsicContentSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x2970C);
	}

	-(CGRect) accessibilityFrame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_19 (self, _cmd, &managed_method, 0x2980C);
	}

	-(NSString *) accessibilityIdentifier
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x2990C);
	}

	-(NSObject *) accessibilityParent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_21 (self, _cmd, &managed_method, 0x29A0C);
	}

	-(BOOL) isAccessibilityFocused
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x29B0C);
	}

	-(NSString *) accessibilityLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x29C0C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x28C0C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [MonoDevelop_MacIntegration_MainToolbar_NSFocusButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_ColoredButtonCell : NSButtonCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawBezelWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_ColoredButtonCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawBezelWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x29E0C);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x29F0C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2A00C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButtonCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_StatusIcon : NSView<NSAccessibilityButton> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGRect) frame;
	-(void) setFrame:(CGRect)p0;
	-(NSString *) accessibilityLabel;
	-(void) mouseEntered:(NSEvent *)p0;
	-(void) mouseExited:(NSEvent *)p0;
	-(void) mouseUp:(NSEvent *)p0;
	-(BOOL) accessibilityPerformPress;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_StatusIcon {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_19 (self, _cmd, &managed_method, 0x2E20C);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x2E30C);
	}

	-(NSString *) accessibilityLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x2EC0C);
	}

	-(void) mouseEntered:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x2EF0C);
	}

	-(void) mouseExited:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x2F00C);
	}

	-(void) mouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x2F10C);
	}

	-(BOOL) accessibilityPerformPress
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x2F30C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_CancelButton : NSButton<NSAccessibilityButton> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSString *) accessibilityLabel;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_CancelButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSString *) accessibilityLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x3120C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3110C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_VerticallyCenteredTextFieldCell : NSTextFieldCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGRect) drawingRectForBounds:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_VerticallyCenteredTextFieldCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGRect) drawingRectForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x3500C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_AwesomeBar {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewDidMoveToWindow
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x35D0C);
	}

	-(void) viewWillMoveToSuperview:(NSView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x35E0C);
	}

	-(void) viewDidMoveToSuperview
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x35F0C);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x3610C);
	}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_19 (self, _cmd, &managed_method, 0x3620C);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x3630C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x35B0C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_ButtonBarContainer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) keyDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x36C0C);
	}

	-(BOOL) becomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x36D0C);
	}

	-(BOOL) resignFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x36E0C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x36F0C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingSource : NSObject<NSTableViewDataSource> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0;
	-(NSObject *) tableView:(NSTableView *)p0 objectValueForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_26 (self, _cmd, &managed_method, p0, 0x4320C);
	}

	-(NSObject *) tableView:(NSTableView *)p0 objectValueForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, p1, p2, 0x4330C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingAllDelegate : NSObject<NSTableViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tableViewSelectionDidChange:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingAllDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tableViewSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x4350C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingSelectedDelegate : NSObject<NSTableViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tableViewSelectionDidChange:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingSelectedDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tableViewSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x4370C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_MacIntegration_SelectEncodingPanel : NSPanel {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) sheetSel;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_SelectEncodingPanel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) sheetSel
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x1CF0C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1C60C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSPanel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_SelectEncodingPopUpButton : NSPopUpButton {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) addRemoveActivated:(NSObject *)p0;
	-(void) itemActivated:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_MacIntegration_SelectEncodingPopUpButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) addRemoveActivated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1DA0C);
	}

	-(void) itemActivated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1DB0C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_SearchBar_DarkThemeSearchFieldCell : NSSearchFieldCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(CGRect) searchTextRectForBounds:(CGRect)p0;
	-(CGRect) searchButtonRectForBounds:(CGRect)p0;
	-(CGRect) cancelButtonRectForBounds:(CGRect)p0;
	-(void) editWithFrame:(CGRect)p0 inView:(NSView *)p1 editor:(NSText *)p2 delegate:(NSObject *)p3 event:(NSEvent *)p4;
	-(void) selectWithFrame:(CGRect)p0 inView:(NSView *)p1 editor:(NSText *)p2 delegate:(NSObject *)p3 start:(NSInteger)p4 length:(NSInteger)p5;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_SearchBar_DarkThemeSearchFieldCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x4710C);
	}

	-(CGRect) searchTextRectForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x4720C);
	}

	-(CGRect) searchButtonRectForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x4730C);
	}

	-(CGRect) cancelButtonRectForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x4740C);
	}

	-(void) editWithFrame:(CGRect)p0 inView:(NSView *)p1 editor:(NSText *)p2 delegate:(NSObject *)p3 event:(NSEvent *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_28 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x4750C);
	}

	-(void) selectWithFrame:(CGRect)p0 inView:(NSView *)p1 editor:(NSText *)p2 delegate:(NSObject *)p3 start:(NSInteger)p4 length:(NSInteger)p5
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, 0x4760C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x4770C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSearchFieldCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_SearchBar : NSSearchField {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) accessibilityPerformShowMenu;
	-(BOOL) accessibilityPerformConfirm;
	-(BOOL) performKeyEquivalent:(NSEvent *)p0;
	-(void) textDidEndEditing:(NSNotification *)p0;
	-(void) viewDidMoveToWindow;
	-(BOOL) becomeFirstResponder;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_SearchBar {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) accessibilityPerformShowMenu
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x2AD0C);
	}

	-(BOOL) accessibilityPerformConfirm
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x2AE0C);
	}

	-(BOOL) performKeyEquivalent:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, p0, 0x2B30C);
	}

	-(void) textDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x2B40C);
	}

	-(void) viewDidMoveToWindow
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x2B50C);
	}

	-(BOOL) becomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x2B60C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2AC0C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSearchField class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_ButtonBar_DarkThemeSegmentedCell : NSSegmentedCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(void) drawSegment:(NSInteger)p0 inFrame:(CGRect)p1 withView:(NSView *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_ButtonBar_DarkThemeSegmentedCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x47D0C);
	}

	-(void) drawSegment:(NSInteger)p0 inFrame:(CGRect)p1 withView:(NSView *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, p1, p2, 0x47E0C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_ButtonBar : NSSegmentedControl {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) removeFromSuperview;
	-(NSInteger) segmentCount;
	-(void) setSegmentCount:(NSInteger)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_ButtonBar {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) removeFromSuperview
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x2BD0C);
	}

	-(NSInteger) segmentCount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x2BF0C);
	}

	-(void) setSegmentCount:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x2C00C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_SelectorView : MonoDevelop_MacIntegration_MainToolbar_NSFocusButton {
}
	-(CGSize) sizeThatFits:(CGSize)p0;
	-(void) setFrameSize:(CGSize)p0;
	-(void) viewDidMoveToWindow;
	-(void) viewDidChangeBackingProperties;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_SelectorView {
}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x2DB0C);
	}

	-(void) setFrameSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x2DC0C);
	}

	-(void) viewDidMoveToWindow
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x2DD0C);
	}

	-(void) viewDidChangeBackingProperties
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x2DF0C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2DA0C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [MonoDevelop_MacIntegration_MainToolbar_NSFocusButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_BuildResultsView : NSView<NSAccessibilityStaticText> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawRect:(CGRect)p0;
	-(void) mouseDown:(NSEvent *)p0;
	-(NSString *) accessibilityValue;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_BuildResultsView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x3010C);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x3030C);
	}

	-(NSString *) accessibilityValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x3040C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3000C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_ProgressView : NSView<NSAccessibilityProgressIndicator> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSNumber *) accessibilityValue;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_ProgressView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSNumber *) accessibilityValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_36 (self, _cmd, &managed_method, 0x3060C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3050C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_StatusBar : MonoDevelop_MacIntegration_MainToolbar_NSFocusButton {
}
	-(void) viewDidChangeBackingProperties;
	-(void) drawRect:(CGRect)p0;
	-(void) viewDidMoveToWindow;
	-(void) mouseEntered:(NSEvent *)p0;
	-(void) mouseExited:(NSEvent *)p0;
	-(void) mouseDown:(NSEvent *)p0;
	-(CGRect) frame;
	-(void) setFrame:(CGRect)p0;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_StatusBar {
}

	-(void) viewDidChangeBackingProperties
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x3170C);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x31B0C);
	}

	-(void) viewDidMoveToWindow
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x31C0C);
	}

	-(void) mouseEntered:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x3440C);
	}

	-(void) mouseExited:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x3450C);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x3470C);
	}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_19 (self, _cmd, &managed_method, 0x3480C);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x3490C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3140C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [MonoDevelop_MacIntegration_MainToolbar_NSFocusButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_MacIntegration_MainToolbar_SelectorView_PathSelectorView_NSPathComponentCellFocusable : NSPathComponentCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_SelectorView_PathSelectorView_NSPathComponentCellFocusable {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x4CE0C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x4CF0C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSPathComponentCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation MonoDevelop_MacIntegration_MainToolbar_SelectorView_PathSelectorView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x4860C);
	}

	-(BOOL) accessibilityPerformShowMenu
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4950C);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x4960C);
	}

	-(void) keyDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x4970C);
	}

	-(BOOL) becomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4990C);
	}

	-(void) viewDidChangeBackingProperties
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x49B0C);
	}

	-(void) viewDidMoveToWindow
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x49E0C);
	}

	-(BOOL) isEnabled
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4B70C);
	}

	-(void) setEnabled:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, 0x4B80C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementProxy : NSAccessibilityElement<NSAccessibility> {
}
	@property (nonatomic, assign, readonly) NSArray * accessibilityActionNames;
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) accessibilityActionNames;
	-(NSObject *) accessibilityHitTest:(CGPoint)p0;
	-(void) accessibilityPerformAction:(NSString *)p0;
	-(BOOL) isAccessibilityFocused;
	-(void) setAccessibilityFocused:(BOOL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) accessibilityActionNames
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_37 (self, _cmd, &managed_method, 0x85E60);
	}

	-(NSObject *) accessibilityHitTest:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, 0x85D60);
	}

	-(void) accessibilityPerformAction:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_39 (self, _cmd, &managed_method, p0, 0x85F60);
	}

	-(BOOL) isAccessibilityFocused
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x86060);
	}

	-(void) setAccessibilityFocused:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, 0x86160);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x86D60);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSAccessibilityElement class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementButtonProxy : MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementProxy<NSAccessibilityButton, NSAccessibility> {
}
	-(BOOL) accessibilityPerformPress;
	-(id) init;
@end

@implementation MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementButtonProxy {
}

	-(BOOL) accessibilityPerformPress
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x86E60);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x86F60);
		if (call_super && rv) {
			struct objc_super super = {  rv, [MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementProxy class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementNavigableStaticTextProxy : MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementProxy<NSAccessibilityNavigableStaticText, NSAccessibility> {
}
	-(NSString *) accessibilityValue;
	-(NSInteger) accessibilityInsertionPointLineNumber;
	-(NSInteger) accessibilityNumberOfCharacters;
	-(NSRange) accessibilityVisibleCharacterRange;
	-(CGRect) accessibilityFrameForRange:(NSRange)p0;
	-(NSInteger) accessibilityLineForIndex:(NSInteger)p0;
	-(NSRange) accessibilityRangeForLine:(NSInteger)p0;
	-(NSString *) accessibilityStringForRange:(NSRange)p0;
	-(NSRange) accessibilityRangeForIndex:(NSInteger)p0;
	-(NSRange) accessibilityStyleRangeForIndex:(NSInteger)p0;
	-(NSRange) accessibilityRangeForPosition:(CGPoint)p0;
	-(id) init;
@end

@implementation MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementNavigableStaticTextProxy {
}

	-(NSString *) accessibilityValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x87060);
	}

	-(NSInteger) accessibilityInsertionPointLineNumber
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x87160);
	}

	-(NSInteger) accessibilityNumberOfCharacters
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x87260);
	}

	-(NSRange) accessibilityVisibleCharacterRange
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_40 (self, _cmd, &managed_method, 0x87360);
	}

	-(CGRect) accessibilityFrameForRange:(NSRange)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_41 (self, _cmd, &managed_method, p0, 0x88A60);
	}

	-(NSInteger) accessibilityLineForIndex:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x88B60);
	}

	-(NSRange) accessibilityRangeForLine:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_43 (self, _cmd, &managed_method, p0, 0x88C60);
	}

	-(NSString *) accessibilityStringForRange:(NSRange)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_44 (self, _cmd, &managed_method, p0, 0x88D60);
	}

	-(NSRange) accessibilityRangeForIndex:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_43 (self, _cmd, &managed_method, p0, 0x88E60);
	}

	-(NSRange) accessibilityStyleRangeForIndex:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_43 (self, _cmd, &managed_method, p0, 0x88F60);
	}

	-(NSRange) accessibilityRangeForPosition:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_45 (self, _cmd, &managed_method, p0, 0x89060);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x89160);
		if (call_super && rv) {
			struct objc_super super = {  rv, [MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementProxy class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_Components_Mac_MDLinkMenuItem : NSMenuItem {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) run:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_Components_Mac_MDLinkMenuItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) run:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x8A160);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_Components_Mac_MDMenuHeaderItem : NSMenuItem {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_Components_Mac_MDMenuHeaderItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_Components_Mac_MDServicesMenuItem : NSMenuItem {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoDevelop_Components_Mac_MDServicesMenuItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x8C460);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSMenuItem class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_Components_Mac_MDMenu : NSMenu {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) menuNeedsUpdate:(NSMenu *)p0;
	-(void) menuWillOpen:(NSMenu *)p0;
	-(void) menuDidClose:(NSMenu *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_Components_Mac_MDMenu {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) menuNeedsUpdate:(NSMenu *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, 0x8A960);
	}

	-(void) menuWillOpen:(NSMenu *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, 0x8AA60);
	}

	-(void) menuDidClose:(NSMenu *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, 0x8AB60);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_Components_Mac_MDMenuItem_MDExpandedArrayItem : NSMenuItem {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoDevelop_Components_Mac_MDMenuItem_MDExpandedArrayItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x450660);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSMenuItem class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoDevelop_Components_Mac_MDMenuItem : NSMenuItem {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) run:(NSMenuItem *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_Components_Mac_MDMenuItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) run:(NSMenuItem *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_47 (self, _cmd, &managed_method, p0, 0x8B560);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_Components_Mac_MDSubMenuItem : NSMenuItem {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_Components_Mac_MDSubMenuItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation MonoDevelop_Components_Mac_GtkEmbed {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isGtkView
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x8FC60);
	}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_19 (self, _cmd, &managed_method, 0x8FF60);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x90060);
	}

	-(void) viewDidMoveToSuperview
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x90160);
	}

	-(void) removeFromSuperview
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x90260);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_Components_ContextMenuExtensionsMac_NSLocationAwareMenu_ContextMenuDelegate : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) menuDidClose:(NSMenu *)p0;
	-(void) menu:(NSMenu *)p0 willHighlightItem:(NSMenuItem *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_Components_ContextMenuExtensionsMac_NSLocationAwareMenu_ContextMenuDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) menuDidClose:(NSMenu *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, 0x563760);
	}

	-(void) menu:(NSMenu *)p0 willHighlightItem:(NSMenuItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_48 (self, _cmd, &managed_method, p0, p1, 0x563860);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface MonoDevelop_Components_ContextMenuExtensionsMac_NSLocationAwareMenu : NSMenu {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) popUpMenuPositioningItem:(NSMenuItem *)p0 atLocation:(CGPoint)p1 inView:(NSView *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation MonoDevelop_Components_ContextMenuExtensionsMac_NSLocationAwareMenu {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) popUpMenuPositioningItem:(NSMenuItem *)p0 atLocation:(CGPoint)p1 inView:(NSView *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_49 (self, _cmd, &managed_method, p0, p1, p2, 0x44A160);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end










































































@interface Foundation_NSUrlSessionHandler_WrappedNSInputStream : NSInputStream {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSUInteger) streamStatus;
	-(void) open;
	-(void) close;
	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1;
	-(BOOL) hasBytesAvailable;
	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1;
	-(NSObject *) propertyForKey:(NSString *)p0;
	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1;
	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2;
	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSUrlSessionHandler_WrappedNSInputStream {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSUInteger) streamStatus
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_50 (self, _cmd, &managed_method, 0x489C);
	}

	-(void) open
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x499C);
	}

	-(void) close
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x4A9C);
	}

	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_51 (self, _cmd, &managed_method, p0, p1, 0x4B9C);
	}

	-(BOOL) hasBytesAvailable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4C9C);
	}

	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_52 (self, _cmd, &managed_method, p0, p1, 0x4D9C);
	}

	-(NSObject *) propertyForKey:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_53 (self, _cmd, &managed_method, p0, 0x4E9C);
	}

	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, p1, 0x4F9C);
	}

	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_55 (self, _cmd, &managed_method, p0, p1, p2, 0x509C);
	}

	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_56 (self, _cmd, &managed_method, p0, p1, 0x519C);
	}

	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_56 (self, _cmd, &managed_method, p0, p1, 0x529C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate : NSObject<NCWidgetListViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) widgetList:(NCWidgetListViewController *)p0 didRemoveRow:(NSUInteger)p1;
	-(void) widgetList:(NCWidgetListViewController *)p0 didReorderRow:(NSUInteger)p1 toRow:(NSUInteger)p2;
	-(NSViewController *) widgetList:(NCWidgetListViewController *)p0 viewControllerForRow:(NSUInteger)p1;
	-(void) widgetListPerformAddAction:(NCWidgetListViewController *)p0;
	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldRemoveRow:(NSUInteger)p1;
	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldReorderRow:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) widgetList:(NCWidgetListViewController *)p0 didRemoveRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1AC9C);
	}

	-(void) widgetList:(NCWidgetListViewController *)p0 didReorderRow:(NSUInteger)p1 toRow:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_58 (self, _cmd, &managed_method, p0, p1, p2, 0x1AD9C);
	}

	-(NSViewController *) widgetList:(NCWidgetListViewController *)p0 viewControllerForRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1AE9C);
	}

	-(void) widgetListPerformAddAction:(NCWidgetListViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_60 (self, _cmd, &managed_method, p0, 0x1AF9C);
	}

	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldRemoveRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_61 (self, _cmd, &managed_method, p0, p1, 0x1B09C);
	}

	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldReorderRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_61 (self, _cmd, &managed_method, p0, p1, 0x1B19C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1AB9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate : NSObject<NCWidgetSearchViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 resultSelected:(NSObject *)p1;
	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 searchForTerm:(NSString *)p1 maxResults:(NSUInteger)p2;
	-(void) widgetSearchTermCleared:(NCWidgetSearchViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 resultSelected:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_62 (self, _cmd, &managed_method, p0, p1, 0x3E99C);
	}

	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 searchForTerm:(NSString *)p1 maxResults:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_63 (self, _cmd, &managed_method, p0, p1, p2, 0x3EA9C);
	}

	-(void) widgetSearchTermCleared:(NCWidgetSearchViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_64 (self, _cmd, &managed_method, p0, 0x3EB9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3E89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreAnimation_CAAnimation__CAAnimationDelegate : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) animationDidStart:(CAAnimation *)p0;
	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreAnimation_CAAnimation__CAAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) animationDidStart:(CAAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_65 (self, _cmd, &managed_method, p0, 0xCE649C);
	}

	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_66 (self, _cmd, &managed_method, p0, p1, 0xCE659C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xCE639C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSNetService__NSNetServiceDelegate : NSObject<NSNetServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) netServiceDidResolveAddress:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2;
	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1;
	-(void) netServiceDidPublish:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1;
	-(void) netServiceDidStop:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1;
	-(void) netServiceWillPublish:(NSNetService *)p0;
	-(void) netServiceWillResolve:(NSNetService *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetService__NSNetServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) netServiceDidResolveAddress:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, 0x7F19C);
	}

	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_68 (self, _cmd, &managed_method, p0, p1, p2, 0x7F29C);
	}

	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_69 (self, _cmd, &managed_method, p0, p1, 0x7F39C);
	}

	-(void) netServiceDidPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, 0x7F49C);
	}

	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_69 (self, _cmd, &managed_method, p0, p1, 0x7F59C);
	}

	-(void) netServiceDidStop:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, 0x7F69C);
	}

	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_70 (self, _cmd, &managed_method, p0, p1, 0x7F79C);
	}

	-(void) netServiceWillPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, 0x7F89C);
	}

	-(void) netServiceWillResolve:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, 0x7F99C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x7F09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate : NSObject<NSNetServiceBrowserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1;
	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_71 (self, _cmd, &managed_method, p0, p1, p2, 0x8D99C);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_71 (self, _cmd, &managed_method, p0, p1, p2, 0x8DA9C);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, p1, p2, 0x8DB9C);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_73 (self, _cmd, &managed_method, p0, p1, 0x8DC9C);
	}

	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x8DD9C);
	}

	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x8DE9C);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, p1, p2, 0x8DF9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x8D89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSObject_Disposer : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	+(void) drain:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __NSObject_Disposer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	+(void) drain:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_75 (self, _cmd, &managed_method, p0, 0x1120E9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1120C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __XamarinObjectObserver : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __XamarinObjectObserver {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x112119C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface CoreLocation_CLLocationManager__CLLocationManagerDelegate : NSObject<CLLocationManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1;
	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1;
	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1;
	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreLocation_CLLocationManager__CLLocationManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_76 (self, _cmd, &managed_method, p0, p1, 0x81D09C);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_77 (self, _cmd, &managed_method, p0, p1, 0x81D19C);
	}

	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_78 (self, _cmd, &managed_method, p0, p1, p2, 0x81D29C);
	}

	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_79 (self, _cmd, &managed_method, p0, p1, 0x81D39C);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_77 (self, _cmd, &managed_method, p0, p1, 0x81D49C);
	}

	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, 0x81D59C);
	}

	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, 0x81D69C);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_81 (self, _cmd, &managed_method, p0, p1, 0x81D79C);
	}

	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_82 (self, _cmd, &managed_method, p0, p1, p2, 0x81D89C);
	}

	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_79 (self, _cmd, &managed_method, p0, p1, 0x81D99C);
	}

	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_79 (self, _cmd, &managed_method, p0, p1, 0x81DA9C);
	}

	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x81DB9C);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x81DC9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x81CF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_AVCaptureFileOutput_recordingProxy : NSObject<AVCaptureFileOutputRecordingDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation AVFoundation_AVCaptureFileOutput_recordingProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_85 (self, _cmd, &managed_method, p0, p1, p2, 0x84A69C);
	}

	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x84A79C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface AppKit_NSAlert__NSAlertDelegate : NSObject<NSAlertDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) alertShowHelp:(NSAlert *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSAlert__NSAlertDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) alertShowHelp:(NSAlert *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x24F59C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x24F49C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSAnimation__NSAnimationDelegate : NSObject<NSAnimationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) animationDidEnd:(NSAnimation *)p0;
	-(void) animation:(NSAnimation *)p0 didReachProgressMark:(float)p1;
	-(void) animationDidStop:(NSAnimation *)p0;
	-(BOOL) animationShouldStart:(NSAnimation *)p0;
	-(float) animation:(NSAnimation *)p0 valueForProgress:(float)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSAnimation__NSAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) animationDidEnd:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_88 (self, _cmd, &managed_method, p0, 0x28FB9C);
	}

	-(void) animation:(NSAnimation *)p0 didReachProgressMark:(float)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_89 (self, _cmd, &managed_method, p0, p1, 0x28FC9C);
	}

	-(void) animationDidStop:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_88 (self, _cmd, &managed_method, p0, 0x28FD9C);
	}

	-(BOOL) animationShouldStart:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, 0x28FE9C);
	}

	-(float) animation:(NSAnimation *)p0 valueForProgress:(float)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_91 (self, _cmd, &managed_method, p0, p1, 0x28FF9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x28FA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSStream__NSStreamDelegate : NSObject<NSStreamDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSStream__NSStreamDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, p1, 0x2A2F9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2A2E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSApplication__NSApplicationDelegate : NSObject<NSApplicationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSMenu *) applicationDockMenu:(NSApplication *)p0;
	-(BOOL) applicationOpenUntitledFile:(NSApplication *)p0;
	-(BOOL) applicationShouldHandleReopen:(NSApplication *)p0 hasVisibleWindows:(BOOL)p1;
	-(BOOL) applicationShouldOpenUntitledFile:(NSApplication *)p0;
	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0;
	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0;
	-(BOOL) application:(NSApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(id)p2;
	-(void) application:(NSApplication *)p0 didDecodeRestorableState:(NSCoder *)p1;
	-(void) applicationDidBecomeActive:(NSNotification *)p0;
	-(void) applicationDidFinishLaunching:(NSNotification *)p0;
	-(void) applicationDidHide:(NSNotification *)p0;
	-(void) applicationDidResignActive:(NSNotification *)p0;
	-(void) applicationDidUnhide:(NSNotification *)p0;
	-(void) applicationDidUpdate:(NSNotification *)p0;
	-(void) application:(NSApplication *)p0 didFailToContinueUserActivityWithType:(NSString *)p1 error:(NSError *)p2;
	-(void) application:(NSApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1;
	-(BOOL) application:(NSApplication *)p0 openFile:(NSString *)p1;
	-(BOOL) application:(NSObject *)p0 openFileWithoutUI:(NSString *)p1;
	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1;
	-(BOOL) application:(NSApplication *)p0 openTempFile:(NSString *)p1;
	-(void) application:(NSApplication *)p0 openURLs:(NSArray *)p1;
	-(void) orderFrontStandardAboutPanel:(NSObject *)p0;
	-(void) orderFrontStandardAboutPanelWithOptions:(NSDictionary *)p0;
	-(BOOL) application:(NSApplication *)p0 printFile:(NSString *)p1;
	-(NSUInteger) application:(NSApplication *)p0 printFiles:(NSArray *)p1 withSettings:(NSDictionary *)p2 showPrintPanels:(BOOL)p3;
	-(BOOL) readSelectionFromPasteboard:(NSPasteboard *)p0;
	-(void) application:(NSApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1;
	-(void) registerServicesMenuSendTypes:(NSArray *)p0 returnTypes:(NSArray *)p1;
	-(void) application:(NSApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1;
	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0;
	-(void) application:(NSApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1;
	-(void) application:(NSApplication *)p0 userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)p1;
	-(void) applicationWillBecomeActive:(NSNotification *)p0;
	-(BOOL) application:(NSApplication *)p0 willContinueUserActivityWithType:(NSString *)p1;
	-(void) application:(NSApplication *)p0 willEncodeRestorableState:(NSCoder *)p1;
	-(void) applicationWillFinishLaunching:(NSNotification *)p0;
	-(void) applicationWillHide:(NSNotification *)p0;
	-(NSError *) application:(NSApplication *)p0 willPresentError:(NSError *)p1;
	-(void) applicationWillResignActive:(NSNotification *)p0;
	-(void) applicationWillTerminate:(NSNotification *)p0;
	-(void) applicationWillUnhide:(NSNotification *)p0;
	-(void) applicationWillUpdate:(NSNotification *)p0;
	-(BOOL) writeSelectionToPasteboard:(NSPasteboard *)p0 types:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSApplication__NSApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSMenu *) applicationDockMenu:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_93 (self, _cmd, &managed_method, p0, 0x30329C);
	}

	-(BOOL) applicationOpenUntitledFile:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_94 (self, _cmd, &managed_method, p0, 0x30339C);
	}

	-(BOOL) applicationShouldHandleReopen:(NSApplication *)p0 hasVisibleWindows:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_95 (self, _cmd, &managed_method, p0, p1, 0x30349C);
	}

	-(BOOL) applicationShouldOpenUntitledFile:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_94 (self, _cmd, &managed_method, p0, 0x30359C);
	}

	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_96 (self, _cmd, &managed_method, p0, 0x30369C);
	}

	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_94 (self, _cmd, &managed_method, p0, 0x30379C);
	}

	-(BOOL) application:(NSApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(id)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_97 (self, _cmd, &managed_method, p0, p1, p2, 0x30389C);
	}

	-(void) application:(NSApplication *)p0 didDecodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, p1, 0x30399C);
	}

	-(void) applicationDidBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x303A9C);
	}

	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x303B9C);
	}

	-(void) applicationDidHide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x303C9C);
	}

	-(void) applicationDidResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x303D9C);
	}

	-(void) applicationDidUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x303E9C);
	}

	-(void) applicationDidUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x303F9C);
	}

	-(void) application:(NSApplication *)p0 didFailToContinueUserActivityWithType:(NSString *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_99 (self, _cmd, &managed_method, p0, p1, p2, 0x30409C);
	}

	-(void) application:(NSApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_100 (self, _cmd, &managed_method, p0, p1, 0x30419C);
	}

	-(BOOL) application:(NSApplication *)p0 openFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x30429C);
	}

	-(BOOL) application:(NSObject *)p0 openFileWithoutUI:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_102 (self, _cmd, &managed_method, p0, p1, 0x30439C);
	}

	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_103 (self, _cmd, &managed_method, p0, p1, 0x30449C);
	}

	-(BOOL) application:(NSApplication *)p0 openTempFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x30459C);
	}

	-(void) application:(NSApplication *)p0 openURLs:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_104 (self, _cmd, &managed_method, p0, p1, 0x30469C);
	}

	-(void) orderFrontStandardAboutPanel:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x30479C);
	}

	-(void) orderFrontStandardAboutPanelWithOptions:(NSDictionary *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_105 (self, _cmd, &managed_method, p0, 0x30489C);
	}

	-(BOOL) application:(NSApplication *)p0 printFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x30499C);
	}

	-(NSUInteger) application:(NSApplication *)p0 printFiles:(NSArray *)p1 withSettings:(NSDictionary *)p2 showPrintPanels:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_106 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x304A9C);
	}

	-(BOOL) readSelectionFromPasteboard:(NSPasteboard *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x304B9C);
	}

	-(void) application:(NSApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, p1, 0x304C9C);
	}

	-(void) registerServicesMenuSendTypes:(NSArray *)p0 returnTypes:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_109 (self, _cmd, &managed_method, p0, p1, 0x304D9C);
	}

	-(void) application:(NSApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_110 (self, _cmd, &managed_method, p0, p1, 0x304E9C);
	}

	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x304F9C);
	}

	-(void) application:(NSApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_111 (self, _cmd, &managed_method, p0, p1, 0x30509C);
	}

	-(void) application:(NSApplication *)p0 userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_112 (self, _cmd, &managed_method, p0, p1, 0x30519C);
	}

	-(void) applicationWillBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x30529C);
	}

	-(BOOL) application:(NSApplication *)p0 willContinueUserActivityWithType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x30539C);
	}

	-(void) application:(NSApplication *)p0 willEncodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, p1, 0x30549C);
	}

	-(void) applicationWillFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x30559C);
	}

	-(void) applicationWillHide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x30569C);
	}

	-(NSError *) application:(NSApplication *)p0 willPresentError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0x30579C);
	}

	-(void) applicationWillResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x30589C);
	}

	-(void) applicationWillTerminate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x30599C);
	}

	-(void) applicationWillUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x305A9C);
	}

	-(void) applicationWillUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x305B9C);
	}

	-(BOOL) writeSelectionToPasteboard:(NSPasteboard *)p0 types:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, p1, 0x305C9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x30319C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSThread_ActionThread : NSThread {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) main;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSThread_ActionThread {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) main
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0xB4219C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface WebKit_DomNode_DomNodeEventProxy : NSObject<DOMEventListener> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) handleEvent:(DOMEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation WebKit_DomNode_DomNodeEventProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) handleEvent:(DOMEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, 0xFCD39C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface WebKit_DomNode_DomNodeEventProxy2 : NSObject<DOMEventListener> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) handleEvent:(DOMEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation WebKit_DomNode_DomNodeEventProxy2 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) handleEvent:(DOMEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, 0xFCD59C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation __NSGestureRecognizerToken {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xCD169C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSClickGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSClickGestureRecognizer *)p0;
@end

@implementation __NSClickGestureRecognizer {
}

	-(void) target:(NSClickGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_116 (self, _cmd, &managed_method, p0, 0xCD1C9C);
	}
@end





@interface AppKit_NSTextField__NSTextFieldDelegate : NSObject<NSTextFieldDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) controlTextDidChange:(NSNotification *)p0;
	-(BOOL) control:(NSControl *)p0 didFailToFormatString:(NSString *)p1 errorDescription:(NSString *)p2;
	-(void) control:(NSControl *)p0 didFailToValidatePartialString:(NSString *)p1 errorDescription:(NSString *)p2;
	-(BOOL) control:(NSControl *)p0 textView:(NSTextView *)p1 doCommandBySelector:(SEL)p2;
	-(void) controlTextDidBeginEditing:(NSNotification *)p0;
	-(void) controlTextDidEndEditing:(NSNotification *)p0;
	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidatesForSelectedRange:(NSRange)p2;
	-(NSArray *) control:(NSControl *)p0 textView:(NSTextView *)p1 completions:(NSArray *)p2 forPartialWordRange:(NSRange)p3 indexOfSelectedItem:(NSInteger*)p4;
	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidates:(NSArray *)p2 forSelectedRange:(NSRange)p3;
	-(BOOL) control:(NSControl *)p0 isValidObject:(NSObject *)p1;
	-(BOOL) textField:(NSTextField *)p0 textView:(NSTextView *)p1 shouldSelectCandidateAtIndex:(NSUInteger)p2;
	-(BOOL) control:(NSControl *)p0 textShouldBeginEditing:(NSText *)p1;
	-(BOOL) control:(NSControl *)p0 textShouldEndEditing:(NSText *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTextField__NSTextFieldDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) controlTextDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xE6EB9C);
	}

	-(BOOL) control:(NSControl *)p0 didFailToFormatString:(NSString *)p1 errorDescription:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_117 (self, _cmd, &managed_method, p0, p1, p2, 0xE6EC9C);
	}

	-(void) control:(NSControl *)p0 didFailToValidatePartialString:(NSString *)p1 errorDescription:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_118 (self, _cmd, &managed_method, p0, p1, p2, 0xE6ED9C);
	}

	-(BOOL) control:(NSControl *)p0 textView:(NSTextView *)p1 doCommandBySelector:(SEL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, p1, p2, 0xE6EE9C);
	}

	-(void) controlTextDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xE6EF9C);
	}

	-(void) controlTextDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xE6F09C);
	}

	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidatesForSelectedRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_120 (self, _cmd, &managed_method, p0, p1, p2, 0xE6F19C);
	}

	-(NSArray *) control:(NSControl *)p0 textView:(NSTextView *)p1 completions:(NSArray *)p2 forPartialWordRange:(NSRange)p3 indexOfSelectedItem:(NSInteger*)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_121 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0xE6F29C);
	}

	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidates:(NSArray *)p2 forSelectedRange:(NSRange)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_122 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xE6F39C);
	}

	-(BOOL) control:(NSControl *)p0 isValidObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_123 (self, _cmd, &managed_method, p0, p1, 0xE6F49C);
	}

	-(BOOL) textField:(NSTextField *)p0 textView:(NSTextView *)p1 shouldSelectCandidateAtIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_124 (self, _cmd, &managed_method, p0, p1, p2, 0xE6F59C);
	}

	-(BOOL) control:(NSControl *)p0 textShouldBeginEditing:(NSText *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, p1, 0xE6F69C);
	}

	-(BOOL) control:(NSControl *)p0 textShouldEndEditing:(NSText *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, p1, 0xE6F79C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xE6EA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSComboBox__NSComboBoxDelegate : AppKit_NSTextField__NSTextFieldDelegate<NSComboBoxDelegate, NSTextFieldDelegate> {
}
	-(void) comboBoxSelectionDidChange:(NSNotification *)p0;
	-(void) comboBoxSelectionIsChanging:(NSNotification *)p0;
	-(void) comboBoxWillDismiss:(NSNotification *)p0;
	-(void) comboBoxWillPopUp:(NSNotification *)p0;
	-(id) init;
@end

@implementation AppKit_NSComboBox__NSComboBoxDelegate {
}

	-(void) comboBoxSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x5C269C);
	}

	-(void) comboBoxSelectionIsChanging:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x5C279C);
	}

	-(void) comboBoxWillDismiss:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x5C289C);
	}

	-(void) comboBoxWillPopUp:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x5C299C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5C259C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSTextField__NSTextFieldDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDatePicker__NSDatePickerCellDelegate : NSObject<NSDatePickerCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDatePicker__NSDatePickerCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, p2, 0x60499C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x60489C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDatePickerCell__NSDatePickerCellDelegate : NSObject<NSDatePickerCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDatePickerCell__NSDatePickerCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, p2, 0x61879C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x61869C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebFrameLoadDelegate : NSObject<WebFrameLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 didCancelClientRedirectForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didChangeLocationWithinPageForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didClearWindowObject:(WebScriptObject *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didCommitLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didCreateJavaScriptContext:(JSContext *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFailProvisionalLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didReceiveIcon:(NSImage *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didReceiveServerRedirectForProvisionalLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didReceiveTitle:(NSString *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didStartProvisionalLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 willCloseFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 willPerformClientRedirectToURL:(NSURL *)p1 delay:(double)p2 fireDate:(NSDate *)p3 forFrame:(WebFrame *)p4;
	-(void) webView:(WebView *)p0 windowScriptObjectAvailable:(WebScriptObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebFrameLoadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 didCancelClientRedirectForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x64919C);
	}

	-(void) webView:(WebView *)p0 didChangeLocationWithinPageForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x64929C);
	}

	-(void) webView:(WebView *)p0 didClearWindowObject:(WebScriptObject *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_128 (self, _cmd, &managed_method, p0, p1, p2, 0x64939C);
	}

	-(void) webView:(WebView *)p0 didCommitLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x64949C);
	}

	-(void) webView:(WebView *)p0 didCreateJavaScriptContext:(JSContext *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, p2, 0x64959C);
	}

	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_130 (self, _cmd, &managed_method, p0, p1, p2, 0x64969C);
	}

	-(void) webView:(WebView *)p0 didFailProvisionalLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_130 (self, _cmd, &managed_method, p0, p1, p2, 0x64979C);
	}

	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x64989C);
	}

	-(void) webView:(WebView *)p0 didReceiveIcon:(NSImage *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, p2, 0x64999C);
	}

	-(void) webView:(WebView *)p0 didReceiveServerRedirectForProvisionalLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x649A9C);
	}

	-(void) webView:(WebView *)p0 didReceiveTitle:(NSString *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, p1, p2, 0x649B9C);
	}

	-(void) webView:(WebView *)p0 didStartProvisionalLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x649C9C);
	}

	-(void) webView:(WebView *)p0 willCloseFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x649D9C);
	}

	-(void) webView:(WebView *)p0 willPerformClientRedirectToURL:(NSURL *)p1 delay:(double)p2 fireDate:(NSDate *)p3 forFrame:(WebFrame *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_133 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x649E9C);
	}

	-(void) webView:(WebView *)p0 windowScriptObjectAvailable:(WebScriptObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_134 (self, _cmd, &managed_method, p0, p1, 0x649F9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x64909C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebDownloadDelegate : NSObject<WebDownloadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSWindow *) downloadWindowForAuthenticationSheet:(WebDownload *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebDownloadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSWindow *) downloadWindowForAuthenticationSheet:(WebDownload *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_135 (self, _cmd, &managed_method, p0, 0x64A19C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x64A09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebResourceLoadDelegate : NSObject<WebResourceLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFailLoadingWithError:(NSError *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFinishLoadingFromDataSource:(WebDataSource *)p2;
	-(NSObject *) webView:(WebView *)p0 identifierForInitialRequest:(NSURLRequest *)p1 fromDataSource:(WebDataSource *)p2;
	-(void) webView:(WebView *)p0 plugInFailedWithError:(NSError *)p1 dataSource:(WebDataSource *)p2;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveContentLength:(NSInteger)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveResponse:(NSURLResponse *)p2 fromDataSource:(WebDataSource *)p3;
	-(NSURLRequest *) webView:(WebView *)p0 resource:(NSObject *)p1 willSendRequest:(NSURLRequest *)p2 redirectResponse:(NSURLResponse *)p3 fromDataSource:(WebDataSource *)p4;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebResourceLoadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_136 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x64A39C);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFailLoadingWithError:(NSError *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_137 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x64A49C);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFinishLoadingFromDataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_138 (self, _cmd, &managed_method, p0, p1, p2, 0x64A59C);
	}

	-(NSObject *) webView:(WebView *)p0 identifierForInitialRequest:(NSURLRequest *)p1 fromDataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_139 (self, _cmd, &managed_method, p0, p1, p2, 0x64A69C);
	}

	-(void) webView:(WebView *)p0 plugInFailedWithError:(NSError *)p1 dataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_140 (self, _cmd, &managed_method, p0, p1, p2, 0x64A79C);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_136 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x64A89C);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveContentLength:(NSInteger)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_141 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x64A99C);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveResponse:(NSURLResponse *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_142 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x64AA9C);
	}

	-(NSURLRequest *) webView:(WebView *)p0 resource:(NSObject *)p1 willSendRequest:(NSURLRequest *)p2 redirectResponse:(NSURLResponse *)p3 fromDataSource:(WebDataSource *)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_143 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x64AB9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x64A29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebUIDelegate : NSObject<WebUIDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) webViewAreToolbarsVisible:(WebView *)p0;
	-(void) webViewClose:(WebView *)p0;
	-(WebView *) webView:(WebView *)p0 createWebViewModalDialogWithRequest:(NSURLRequest *)p1;
	-(WebView *) webView:(WebView *)p0 createWebViewWithRequest:(NSURLRequest *)p1;
	-(NSUInteger) webView:(WebView *)p0 dragSourceActionMaskForPoint:(CGPoint)p1;
	-(void) webView:(WebView *)p0 drawFooterInRect:(CGRect)p1;
	-(void) webView:(WebView *)p0 drawHeaderInRect:(CGRect)p1;
	-(void) webViewFocus:(WebView *)p0;
	-(CGRect) webViewContentRect:(WebView *)p0;
	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2;
	-(NSUInteger) webView:(WebView *)p0 dragDestinationActionMaskForDraggingInfo:(id<NSDraggingInfo>)p1;
	-(NSResponder *) webViewFirstResponder:(WebView *)p0;
	-(float) webViewFooterHeight:(WebView *)p0;
	-(CGRect) webViewFrame:(WebView *)p0;
	-(float) webViewHeaderHeight:(WebView *)p0;
	-(NSString *) webViewStatusText:(WebView *)p0;
	-(BOOL) webViewIsResizable:(WebView *)p0;
	-(BOOL) webViewIsStatusBarVisible:(WebView *)p0;
	-(void) webView:(WebView *)p0 makeFirstResponder:(NSResponder *)p1;
	-(void) webView:(WebView *)p0 mouseDidMoveOverElement:(NSDictionary *)p1 modifierFlags:(NSUInteger)p2;
	-(void) webView:(WebView *)p0 printFrameView:(WebFrameView *)p1;
	-(BOOL) webView:(WebView *)p0 runBeforeUnloadConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1;
	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1;
	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2;
	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WebFrame *)p3;
	-(void) webViewRunModal:(WebView *)p0;
	-(void) webView:(WebView *)p0 runOpenPanelForFileButtonWithResultListener:(id)p1;
	-(void) webView:(WebView *)p0 setContentRect:(CGRect)p1;
	-(void) webView:(WebView *)p0 setFrame:(CGRect)p1;
	-(void) webView:(WebView *)p0 setResizable:(BOOL)p1;
	-(void) webView:(WebView *)p0 setStatusBarVisible:(BOOL)p1;
	-(void) webView:(WebView *)p0 setStatusText:(NSString *)p1;
	-(void) webView:(WebView *)p0 setToolbarsVisible:(BOOL)p1;
	-(BOOL) webView:(WebView *)p0 shouldPerformAction:(SEL)p1 fromSender:(NSObject *)p2;
	-(void) webViewShow:(WebView *)p0;
	-(void) webViewUnfocus:(WebView *)p0;
	-(BOOL) webView:(WebView *)p0 validateUserInterfaceItem:(NSObject *)p1 defaultValidation:(BOOL)p2;
	-(void) webView:(WebView *)p0 willPerformDragDestinationAction:(unsigned long long)p1 forDraggingInfo:(id<NSDraggingInfo>)p2;
	-(void) webView:(WebView *)p0 willPerformDragSourceAction:(unsigned long long)p1 fromPoint:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebUIDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) webViewAreToolbarsVisible:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, 0x64AD9C);
	}

	-(void) webViewClose:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, 0x64AE9C);
	}

	-(WebView *) webView:(WebView *)p0 createWebViewModalDialogWithRequest:(NSURLRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x64AF9C);
	}

	-(WebView *) webView:(WebView *)p0 createWebViewWithRequest:(NSURLRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x64B09C);
	}

	-(NSUInteger) webView:(WebView *)p0 dragSourceActionMaskForPoint:(CGPoint)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, p1, 0x64B19C);
	}

	-(void) webView:(WebView *)p0 drawFooterInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_148 (self, _cmd, &managed_method, p0, p1, 0x64B29C);
	}

	-(void) webView:(WebView *)p0 drawHeaderInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_148 (self, _cmd, &managed_method, p0, p1, 0x64B39C);
	}

	-(void) webViewFocus:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, 0x64B49C);
	}

	-(CGRect) webViewContentRect:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_149 (self, _cmd, &managed_method, p0, 0x64B59C);
	}

	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x64B69C);
	}

	-(NSUInteger) webView:(WebView *)p0 dragDestinationActionMaskForDraggingInfo:(id<NSDraggingInfo>)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_151 (self, _cmd, &managed_method, p0, p1, 0x64B79C);
	}

	-(NSResponder *) webViewFirstResponder:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, 0x64B89C);
	}

	-(float) webViewFooterHeight:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, p0, 0x64B99C);
	}

	-(CGRect) webViewFrame:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_149 (self, _cmd, &managed_method, p0, 0x64BA9C);
	}

	-(float) webViewHeaderHeight:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, p0, 0x64BB9C);
	}

	-(NSString *) webViewStatusText:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x64BC9C);
	}

	-(BOOL) webViewIsResizable:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, 0x64BD9C);
	}

	-(BOOL) webViewIsStatusBarVisible:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, 0x64BE9C);
	}

	-(void) webView:(WebView *)p0 makeFirstResponder:(NSResponder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_155 (self, _cmd, &managed_method, p0, p1, 0x64BF9C);
	}

	-(void) webView:(WebView *)p0 mouseDidMoveOverElement:(NSDictionary *)p1 modifierFlags:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_156 (self, _cmd, &managed_method, p0, p1, p2, 0x64C09C);
	}

	-(void) webView:(WebView *)p0 printFrameView:(WebFrameView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_157 (self, _cmd, &managed_method, p0, p1, 0x64C19C);
	}

	-(BOOL) webView:(WebView *)p0 runBeforeUnloadConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_158 (self, _cmd, &managed_method, p0, p1, p2, 0x64C29C);
	}

	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_159 (self, _cmd, &managed_method, p0, p1, 0x64C39C);
	}

	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, p1, p2, 0x64C49C);
	}

	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_160 (self, _cmd, &managed_method, p0, p1, 0x64C59C);
	}

	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_158 (self, _cmd, &managed_method, p0, p1, p2, 0x64C69C);
	}

	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_161 (self, _cmd, &managed_method, p0, p1, p2, 0x64C79C);
	}

	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WebFrame *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_162 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x64C89C);
	}

	-(void) webViewRunModal:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, 0x64C99C);
	}

	-(void) webView:(WebView *)p0 runOpenPanelForFileButtonWithResultListener:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_163 (self, _cmd, &managed_method, p0, p1, 0x64CA9C);
	}

	-(void) webView:(WebView *)p0 setContentRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_148 (self, _cmd, &managed_method, p0, p1, 0x64CB9C);
	}

	-(void) webView:(WebView *)p0 setFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_148 (self, _cmd, &managed_method, p0, p1, 0x64CC9C);
	}

	-(void) webView:(WebView *)p0 setResizable:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, p1, 0x64CD9C);
	}

	-(void) webView:(WebView *)p0 setStatusBarVisible:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, p1, 0x64CE9C);
	}

	-(void) webView:(WebView *)p0 setStatusText:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_159 (self, _cmd, &managed_method, p0, p1, 0x64CF9C);
	}

	-(void) webView:(WebView *)p0 setToolbarsVisible:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, p1, 0x64D09C);
	}

	-(BOOL) webView:(WebView *)p0 shouldPerformAction:(SEL)p1 fromSender:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_165 (self, _cmd, &managed_method, p0, p1, p2, 0x64D19C);
	}

	-(void) webViewShow:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, 0x64D29C);
	}

	-(void) webViewUnfocus:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, 0x64D39C);
	}

	-(BOOL) webView:(WebView *)p0 validateUserInterfaceItem:(NSObject *)p1 defaultValidation:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_166 (self, _cmd, &managed_method, p0, p1, p2, 0x64D49C);
	}

	-(void) webView:(WebView *)p0 willPerformDragDestinationAction:(unsigned long long)p1 forDraggingInfo:(id<NSDraggingInfo>)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_167 (self, _cmd, &managed_method, p0, p1, p2, 0x64D59C);
	}

	-(void) webView:(WebView *)p0 willPerformDragSourceAction:(unsigned long long)p1 fromPoint:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_168 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x64D69C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x64AC9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebPolicyDelegate : NSObject<WebPolicyDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 decidePolicyForMIMEType:(NSString *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 decidePolicyForNewWindowAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 newFrameName:(NSString *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 unableToImplementPolicyWithError:(NSError *)p1 frame:(WebFrame *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebPolicyDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 decidePolicyForMIMEType:(NSString *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x64D89C);
	}

	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x64D99C);
	}

	-(void) webView:(WebView *)p0 decidePolicyForNewWindowAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 newFrameName:(NSString *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_171 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x64DA9C);
	}

	-(void) webView:(WebView *)p0 unableToImplementPolicyWithError:(NSError *)p1 frame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_130 (self, _cmd, &managed_method, p0, p1, p2, 0x64DB9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x64D79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSDocumentDuplicateCallback : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) document:(NSDocument *)p0 didDuplicate:(BOOL)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __NSDocumentDuplicateCallback {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) document:(NSDocument *)p0 didDuplicate:(BOOL)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, p1, p2, 0xCBDD9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate : NSObject<NSUserNotificationCenterDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didActivateNotification:(NSUserNotification *)p1;
	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didDeliverNotification:(NSUserNotification *)p1;
	-(BOOL) userNotificationCenter:(NSUserNotificationCenter *)p0 shouldPresentNotification:(NSUserNotification *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didActivateNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_173 (self, _cmd, &managed_method, p0, p1, 0x7E039C);
	}

	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didDeliverNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_173 (self, _cmd, &managed_method, p0, p1, 0x7E049C);
	}

	-(BOOL) userNotificationCenter:(NSUserNotificationCenter *)p0 shouldPresentNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_174 (self, _cmd, &managed_method, p0, p1, 0x7E059C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x7E029C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate : NSObject<NSGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldAttemptToRecognizeWithEvent:(NSEvent *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) gestureRecognizerShouldBegin:(NSGestureRecognizer *)p0;
	-(BOOL) xamarinselector:(NSGestureRecognizer *)p0 removed:(NSEvent *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldReceiveTouch:(NSTouch *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldAttemptToRecognizeWithEvent:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x82819C);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, p1, 0x82829C);
	}

	-(BOOL) gestureRecognizerShouldBegin:(NSGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, 0x82839C);
	}

	-(BOOL) xamarinselector:(NSGestureRecognizer *)p0 removed:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x82849C);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldReceiveTouch:(NSTouch *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_178 (self, _cmd, &managed_method, p0, p1, 0x82859C);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, p1, 0x82869C);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, p1, 0x82879C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x82809C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation __NSGestureRecognizerParameterlessToken {
}

	-(void) target
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0xCD189C);
	}
@end

@implementation __NSGestureRecognizerParametrizedToken {
}

	-(void) target:(NSGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, 0xCD1A9C);
	}
@end

@interface AppKit_NSDrawer__NSDrawerDelegate : NSObject<NSDrawerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawerDidClose:(NSNotification *)p0;
	-(void) drawerDidOpen:(NSNotification *)p0;
	-(BOOL) drawerShouldClose:(NSDrawer *)p0;
	-(BOOL) drawerShouldOpen:(NSDrawer *)p0;
	-(void) drawerWillClose:(NSNotification *)p0;
	-(void) drawerWillOpen:(NSNotification *)p0;
	-(CGSize) drawerWillResizeContents:(NSDrawer *)p0 toSize:(CGSize)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDrawer__NSDrawerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawerDidClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x84549C);
	}

	-(void) drawerDidOpen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x84559C);
	}

	-(BOOL) drawerShouldClose:(NSDrawer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_180 (self, _cmd, &managed_method, p0, 0x84569C);
	}

	-(BOOL) drawerShouldOpen:(NSDrawer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_180 (self, _cmd, &managed_method, p0, 0x84579C);
	}

	-(void) drawerWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x84589C);
	}

	-(void) drawerWillOpen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x84599C);
	}

	-(CGSize) drawerWillResizeContents:(NSDrawer *)p0 toSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_181 (self, _cmd, &managed_method, p0, p1, 0x845A9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x84539C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate : NSObject<GKGameCenterControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_182 (self, _cmd, &managed_method, p0, 0x8D739C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x8D729C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKAchievementViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate {
}

	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_183 (self, _cmd, &managed_method, p0, 0x88CF9C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x88CE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBCentralManager__CBCentralManagerDelegate : NSObject<CBCentralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3;
	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1;
	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0;
	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBCentralManager__CBCentralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_184 (self, _cmd, &managed_method, p0, p1, 0xEC9E9C);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_185 (self, _cmd, &managed_method, p0, p1, p2, 0xEC9F9C);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_186 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xECA09C);
	}

	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_185 (self, _cmd, &managed_method, p0, p1, p2, 0xECA19C);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_187 (self, _cmd, &managed_method, p0, p1, 0xECA29C);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_187 (self, _cmd, &managed_method, p0, p1, 0xECA39C);
	}

	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_188 (self, _cmd, &managed_method, p0, 0xECA49C);
	}

	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, p1, 0xECA59C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xEC9D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate : NSObject<CBPeripheralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1;
	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_190 (self, _cmd, &managed_method, p0, p1, 0xF4469C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, p1, p2, 0xF4479C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, p1, p2, 0xF4489C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_192 (self, _cmd, &managed_method, p0, p1, p2, 0xF4499C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, p1, p2, 0xF44A9C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, p1, p2, 0xF44B9C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_194 (self, _cmd, &managed_method, p0, p1, 0xF44C9C);
	}

	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_195 (self, _cmd, &managed_method, p0, 0xF44D9C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_196 (self, _cmd, &managed_method, p0, p1, p2, 0xF44E9C);
	}

	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_195 (self, _cmd, &managed_method, p0, 0xF44F9C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_197 (self, _cmd, &managed_method, p0, p1, 0xF4509C);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_198 (self, _cmd, &managed_method, p0, p1, 0xF4519C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xF4459C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate : NSObject<GKFriendRequestComposeViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_199 (self, _cmd, &managed_method, p0, 0x8BFF9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x8BFE9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheral__CBPeripheralDelegate : NSObject<CBPeripheralDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1;
	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0;
	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateName:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheral__CBPeripheralDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_200 (self, _cmd, &managed_method, p0, p1, p2, 0xF2869C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, p2, 0xF2879C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0xF2889C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, p2, 0xF2899C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_203 (self, _cmd, &managed_method, p0, p1, 0xF28A9C);
	}

	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, 0xF28B9C);
	}

	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, 0xF28C9C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_205 (self, _cmd, &managed_method, p0, p1, 0xF28D9C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, p2, 0xF28E9C);
	}

	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_203 (self, _cmd, &managed_method, p0, p1, 0xF28F9C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0xF2909C);
	}

	-(void) peripheralDidUpdateName:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, 0xF2919C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0xF2929C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, p2, 0xF2939C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0xF2949C);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, p2, 0xF2959C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xF2859C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSImage__NSImageDelegate : NSObject<NSImageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) image:(NSImage *)p0 didLoadPartOfRepresentation:(NSImageRep *)p1 withValidRows:(NSInteger)p2;
	-(void) image:(NSImage *)p0 didLoadRepresentation:(NSImageRep *)p1 withStatus:(NSUInteger)p2;
	-(void) image:(NSImage *)p0 didLoadRepresentationHeader:(NSImageRep *)p1;
	-(NSImage *) imageDidNotDraw:(NSObject *)p0 inRect:(CGRect)p1;
	-(void) image:(NSImage *)p0 willLoadRepresentation:(NSImageRep *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSImage__NSImageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) image:(NSImage *)p0 didLoadPartOfRepresentation:(NSImageRep *)p1 withValidRows:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_208 (self, _cmd, &managed_method, p0, p1, p2, 0x8E599C);
	}

	-(void) image:(NSImage *)p0 didLoadRepresentation:(NSImageRep *)p1 withStatus:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_209 (self, _cmd, &managed_method, p0, p1, p2, 0x8E5A9C);
	}

	-(void) image:(NSImage *)p0 didLoadRepresentationHeader:(NSImageRep *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_210 (self, _cmd, &managed_method, p0, p1, 0x8E5B9C);
	}

	-(NSImage *) imageDidNotDraw:(NSObject *)p0 inRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_211 (self, _cmd, &managed_method, p0, p1, 0x8E5C9C);
	}

	-(void) image:(NSImage *)p0 willLoadRepresentation:(NSImageRep *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_210 (self, _cmd, &managed_method, p0, p1, 0x8E5D9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x8E589C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface PdfKit_PdfDocument__PdfDocumentDelegate : NSObject<PDFDocumentDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(Class) classForAnnotationClass:(Class)p0;
	-(void) documentDidBeginDocumentFind:(NSNotification *)p0;
	-(void) didMatchString:(PDFSelection *)p0;
	-(void) documentDidUnlock:(NSNotification *)p0;
	-(void) documentDidEndDocumentFind:(NSNotification *)p0;
	-(Class) classForAnnotationType:(NSString *)p0;
	-(void) documentDidFindMatch:(NSNotification *)p0;
	-(void) documentDidEndPageFind:(NSNotification *)p0;
	-(void) documentDidBeginPageFind:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfDocument__PdfDocumentDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(Class) classForAnnotationClass:(Class)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_212 (self, _cmd, &managed_method, p0, 0x90619C);
	}

	-(void) documentDidBeginDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x90629C);
	}

	-(void) didMatchString:(PDFSelection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_213 (self, _cmd, &managed_method, p0, 0x90639C);
	}

	-(void) documentDidUnlock:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x90649C);
	}

	-(void) documentDidEndDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x90659C);
	}

	-(Class) classForAnnotationType:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_214 (self, _cmd, &managed_method, p0, 0x90669C);
	}

	-(void) documentDidFindMatch:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x90679C);
	}

	-(void) documentDidEndPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x90689C);
	}

	-(void) documentDidBeginPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x90699C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x90609C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSMagnificationGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSMagnificationGestureRecognizer *)p0;
@end

@implementation __NSMagnificationGestureRecognizer {
}

	-(void) target:(NSMagnificationGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_215 (self, _cmd, &managed_method, p0, 0xCD1E9C);
	}
@end

@interface AppKit_NSMatrix__NSMatrixDelegate : NSObject<NSMatrixDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSMatrix__NSMatrixDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x939A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKLeaderboardViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate {
}

	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_216 (self, _cmd, &managed_method, p0, 0x94299C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x94289C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatch__GKMatchDelegate : NSObject<GKMatchDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarin:(GKMatch *)p0 selector:(NSString *)p1 removed:(NSError *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2;
	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1;
	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2;
	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatch__GKMatchDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarin:(GKMatch *)p0 selector:(NSString *)p1 removed:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_217 (self, _cmd, &managed_method, p0, p1, p2, 0x97769C);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_218 (self, _cmd, &managed_method, p0, p1, p2, 0x97779C);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_219 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x97789C);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_220 (self, _cmd, &managed_method, p0, p1, p2, 0x97799C);
	}

	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_221 (self, _cmd, &managed_method, p0, p1, 0x977A9C);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_222 (self, _cmd, &managed_method, p0, p1, 0x977B9C);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_223 (self, _cmd, &managed_method, p0, p1, 0x977C9C);
	}

	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, p1, p2, 0x977D9C);
	}

	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_225 (self, _cmd, &managed_method, p0, p1, p2, 0x977E9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x97759C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate : NSObject<GKMatchmakerViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1;
	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_226 (self, _cmd, &managed_method, p0, p1, 0x99C09C);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_227 (self, _cmd, &managed_method, p0, p1, 0x99C19C);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_228 (self, _cmd, &managed_method, p0, p1, 0x99C29C);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_229 (self, _cmd, &managed_method, p0, p1, 0x99C39C);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_230 (self, _cmd, &managed_method, p0, p1, 0x99C49C);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_231 (self, _cmd, &managed_method, p0, p1, 0x99C59C);
	}

	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_232 (self, _cmd, &managed_method, p0, 0x99C69C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x99BF9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface PdfKit_PdfView__PdfViewDelegate : NSObject<PDFViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1;
	-(void) PDFViewPerformFind:(PDFView *)p0;
	-(void) PDFViewPerformGoToPage:(PDFView *)p0;
	-(void) PDFViewPerformPrint:(PDFView *)p0;
	-(NSString *) PDFViewPrintJobTitle:(PDFView *)p0;
	-(CGFloat) PDFViewWillChangeScaleFactor:(PDFView *)p0 toScale:(CGFloat)p1;
	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfView__PdfViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_233 (self, _cmd, &managed_method, p0, p1, 0x9B019C);
	}

	-(void) PDFViewPerformFind:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_234 (self, _cmd, &managed_method, p0, 0x9B029C);
	}

	-(void) PDFViewPerformGoToPage:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_234 (self, _cmd, &managed_method, p0, 0x9B039C);
	}

	-(void) PDFViewPerformPrint:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_234 (self, _cmd, &managed_method, p0, 0x9B049C);
	}

	-(NSString *) PDFViewPrintJobTitle:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_235 (self, _cmd, &managed_method, p0, 0x9B059C);
	}

	-(CGFloat) PDFViewWillChangeScaleFactor:(PDFView *)p0 toScale:(CGFloat)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_236 (self, _cmd, &managed_method, p0, p1, 0x9B069C);
	}

	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_237 (self, _cmd, &managed_method, p0, p1, 0x9B079C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x9B009C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSPageController__NSPageControllerDelegate : NSObject<NSPageControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pageControllerDidEndLiveTransition:(NSPageController *)p0;
	-(void) pageController:(NSPageController *)p0 didTransitionToObject:(NSObject *)p1;
	-(CGRect) pageController:(NSPageController *)p0 frameForObject:(NSObject *)p1;
	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1;
	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1;
	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2;
	-(void) pageControllerWillStartLiveTransition:(NSPageController *)p0;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSPageController__NSPageControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pageControllerDidEndLiveTransition:(NSPageController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_238 (self, _cmd, &managed_method, p0, 0xA2839C);
	}

	-(void) pageController:(NSPageController *)p0 didTransitionToObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_239 (self, _cmd, &managed_method, p0, p1, 0xA2849C);
	}

	-(CGRect) pageController:(NSPageController *)p0 frameForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_240 (self, _cmd, &managed_method, p0, p1, 0xA2859C);
	}

	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_241 (self, _cmd, &managed_method, p0, p1, 0xA2869C);
	}

	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_242 (self, _cmd, &managed_method, p0, p1, 0xA2879C);
	}

	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_243 (self, _cmd, &managed_method, p0, p1, p2, 0xA2889C);
	}

	-(void) pageControllerWillStartLiveTransition:(NSPageController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_238 (self, _cmd, &managed_method, p0, 0xA2899C);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_244 (self, _cmd, &managed_method, p0, 0xA28A9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xA2829C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSPanGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSPanGestureRecognizer *)p0;
@end

@implementation __NSPanGestureRecognizer {
}

	-(void) target:(NSPanGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_245 (self, _cmd, &managed_method, p0, 0xCD209C);
	}
@end

@interface Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate : NSObject<NSKeyedArchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1;
	-(void) archiverDidFinish:(NSKeyedArchiver *)p0;
	-(void) archiverWillFinish:(NSKeyedArchiver *)p0;
	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_246 (self, _cmd, &managed_method, p0, p1, 0xECD39C);
	}

	-(void) archiverDidFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_247 (self, _cmd, &managed_method, p0, 0xECD49C);
	}

	-(void) archiverWillFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_247 (self, _cmd, &managed_method, p0, 0xECD59C);
	}

	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_248 (self, _cmd, &managed_method, p0, p1, p2, 0xECD69C);
	}

	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_249 (self, _cmd, &managed_method, p0, p1, 0xECD79C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xECD29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate : NSObject<NSKeyedUnarchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2;
	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1;
	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_250 (self, _cmd, &managed_method, p0, p1, p2, 0xEE469C);
	}

	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_251 (self, _cmd, &managed_method, p0, p1, 0xEE479C);
	}

	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_252 (self, _cmd, &managed_method, p0, 0xEE489C);
	}

	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_252 (self, _cmd, &managed_method, p0, 0xEE499C);
	}

	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_253 (self, _cmd, &managed_method, p0, p1, p2, 0xEE4A9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xEE459C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSPathCell__NSPathCellDelegate : NSObject<NSPathCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pathCell:(NSPathCell *)p0 willDisplayOpenPanel:(NSOpenPanel *)p1;
	-(void) pathCell:(NSPathCell *)p0 willPopUpMenu:(NSMenu *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSPathCell__NSPathCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pathCell:(NSPathCell *)p0 willDisplayOpenPanel:(NSOpenPanel *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_254 (self, _cmd, &managed_method, p0, p1, 0xAC0C9C);
	}

	-(void) pathCell:(NSPathCell *)p0 willPopUpMenu:(NSMenu *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_255 (self, _cmd, &managed_method, p0, p1, 0xAC0D9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xAC0B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end


@interface ExternalAccessory_EAAccessory__EAAccessoryDelegate : NSObject<EAAccessoryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) accessoryDidDisconnect:(id)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ExternalAccessory_EAAccessory__EAAccessoryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) accessoryDidDisconnect:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_256 (self, _cmd, &managed_method, p0, 0xACA69C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xACA59C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end




@interface __NSPressGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSPressGestureRecognizer *)p0;
@end

@implementation __NSPressGestureRecognizer {
}

	-(void) target:(NSPressGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_257 (self, _cmd, &managed_method, p0, 0xCD229C);
	}
@end

@interface Foundation_NSCache__NSCacheDelegate : NSObject<NSCacheDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSCache__NSCacheDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_258 (self, _cmd, &managed_method, p0, p1, 0xB70F9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xB70E9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSRotationGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSRotationGestureRecognizer *)p0;
@end

@implementation __NSRotationGestureRecognizer {
}

	-(void) target:(NSRotationGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_259 (self, _cmd, &managed_method, p0, 0xCD249C);
	}
@end

@interface AppKit_NSRuleEditor__NSRuleEditorDelegate : NSObject<NSRuleEditorDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) controlTextDidChange:(NSNotification *)p0;
	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 child:(NSInteger)p1 forCriterion:(NSObject *)p2 withRowType:(NSUInteger)p3;
	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 displayValueForCriterion:(NSObject *)p1 inRow:(NSInteger)p2;
	-(void) controlTextDidBeginEditing:(NSNotification *)p0;
	-(void) controlTextDidEndEditing:(NSNotification *)p0;
	-(NSInteger) ruleEditor:(NSRuleEditor *)p0 numberOfChildrenForCriterion:(NSObject *)p1 withRowType:(NSUInteger)p2;
	-(NSDictionary *) ruleEditor:(NSRuleEditor *)p0 predicatePartsForCriterion:(NSObject *)p1 withDisplayValue:(NSObject *)p2 inRow:(NSInteger)p3;
	-(void) ruleEditorRowsDidChange:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSRuleEditor__NSRuleEditorDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) controlTextDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xB94D9C);
	}

	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 child:(NSInteger)p1 forCriterion:(NSObject *)p2 withRowType:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_260 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xB94E9C);
	}

	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 displayValueForCriterion:(NSObject *)p1 inRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_261 (self, _cmd, &managed_method, p0, p1, p2, 0xB94F9C);
	}

	-(void) controlTextDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xB9509C);
	}

	-(void) controlTextDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xB9519C);
	}

	-(NSInteger) ruleEditor:(NSRuleEditor *)p0 numberOfChildrenForCriterion:(NSObject *)p1 withRowType:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_262 (self, _cmd, &managed_method, p0, p1, p2, 0xB9529C);
	}

	-(NSDictionary *) ruleEditor:(NSRuleEditor *)p0 predicatePartsForCriterion:(NSObject *)p1 withDisplayValue:(NSObject *)p2 inRow:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_263 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xB9539C);
	}

	-(void) ruleEditorRowsDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xB9549C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xB94C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSearchField__NSSearchFieldDelegate : AppKit_NSTextField__NSTextFieldDelegate<NSSearchFieldDelegate, NSTextFieldDelegate> {
}
	-(void) searchFieldDidEndSearching:(NSSearchField *)p0;
	-(void) searchFieldDidStartSearching:(NSSearchField *)p0;
	-(id) init;
@end

@implementation AppKit_NSSearchField__NSSearchFieldDelegate {
}

	-(void) searchFieldDidEndSearching:(NSSearchField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_264 (self, _cmd, &managed_method, p0, 0xBF7B9C);
	}

	-(void) searchFieldDidStartSearching:(NSSearchField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_264 (self, _cmd, &managed_method, p0, 0xBF7C9C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xBF7A9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSTextField__NSTextFieldDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSavePanel__NSOpenSavePanelDelegate : NSObject<NSOpenSavePanelDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSInteger) panel:(NSSavePanel *)p0 compareFilename:(NSString *)p1 with:(NSString *)p2 caseSensitive:(BOOL)p3;
	-(void) panel:(NSSavePanel *)p0 didChangeToDirectoryURL:(NSURL *)p1;
	-(void) panel:(NSSavePanel *)p0 directoryDidChange:(NSString *)p1;
	-(BOOL) panel:(NSSavePanel *)p0 isValidFilename:(NSString *)p1;
	-(void) panelSelectionDidChange:(NSSavePanel *)p0;
	-(BOOL) panel:(NSSavePanel *)p0 shouldEnableURL:(NSURL *)p1;
	-(BOOL) panel:(NSSavePanel *)p0 shouldShowFilename:(NSString *)p1;
	-(NSString *) panel:(NSSavePanel *)p0 userEnteredFilename:(NSString *)p1 confirmed:(BOOL)p2;
	-(BOOL) panel:(NSSavePanel *)p0 validateURL:(NSURL *)p1 error:(NSError **)p2;
	-(void) panel:(NSSavePanel *)p0 willExpand:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSavePanel__NSOpenSavePanelDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) panel:(NSSavePanel *)p0 compareFilename:(NSString *)p1 with:(NSString *)p2 caseSensitive:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_265 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xC0C49C);
	}

	-(void) panel:(NSSavePanel *)p0 didChangeToDirectoryURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_266 (self, _cmd, &managed_method, p0, p1, 0xC0C59C);
	}

	-(void) panel:(NSSavePanel *)p0 directoryDidChange:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_267 (self, _cmd, &managed_method, p0, p1, 0xC0C69C);
	}

	-(BOOL) panel:(NSSavePanel *)p0 isValidFilename:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_268 (self, _cmd, &managed_method, p0, p1, 0xC0C79C);
	}

	-(void) panelSelectionDidChange:(NSSavePanel *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_269 (self, _cmd, &managed_method, p0, 0xC0C89C);
	}

	-(BOOL) panel:(NSSavePanel *)p0 shouldEnableURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_270 (self, _cmd, &managed_method, p0, p1, 0xC0C99C);
	}

	-(BOOL) panel:(NSSavePanel *)p0 shouldShowFilename:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_268 (self, _cmd, &managed_method, p0, p1, 0xC0CA9C);
	}

	-(NSString *) panel:(NSSavePanel *)p0 userEnteredFilename:(NSString *)p1 confirmed:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_271 (self, _cmd, &managed_method, p0, p1, p2, 0xC0CB9C);
	}

	-(BOOL) panel:(NSSavePanel *)p0 validateURL:(NSURL *)p1 error:(NSError **)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_272 (self, _cmd, &managed_method, p0, p1, p2, 0xC0CC9C);
	}

	-(void) panel:(NSSavePanel *)p0 willExpand:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_273 (self, _cmd, &managed_method, p0, p1, 0xC0CD9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xC0C39C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTableView__NSTableViewDelegate : NSObject<NSTableViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tableViewColumnDidMove:(NSNotification *)p0;
	-(void) tableViewColumnDidResize:(NSNotification *)p0;
	-(NSTableRowView *) tableView:(NSTableView *)p0 rowViewForRow:(NSInteger)p1;
	-(void) tableView:(NSTableView *)p0 didAddRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2;
	-(void) tableView:(NSTableView *)p0 didClickTableColumn:(NSTableColumn *)p1;
	-(void) tableView:(NSTableView *)p0 didDragTableColumn:(NSTableColumn *)p1;
	-(void) tableView:(NSTableView *)p0 didRemoveRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2;
	-(NSCell *) tableView:(NSTableView *)p0 dataCellForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSInteger) tableView:(NSTableView *)p0 nextTypeSelectMatchFromRow:(NSInteger)p1 toRow:(NSInteger)p2 forString:(NSString *)p3;
	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1;
	-(NSString *) tableView:(NSTableView *)p0 typeSelectStringForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSIndexSet *) tableView:(NSTableView *)p0 selectionIndexesForProposedSelection:(NSIndexSet *)p1;
	-(CGFloat) tableView:(NSTableView *)p0 sizeToFitWidthOfColumn:(NSInteger)p1;
	-(NSString *) tableView:(NSTableView *)p0 toolTipForCell:(NSCell *)p1 rect:(CGRect*)p2 tableColumn:(NSTableColumn *)p3 row:(NSInteger)p4 mouseLocation:(CGPoint)p5;
	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1;
	-(void) tableView:(NSTableView *)p0 mouseDownInHeaderOfTableColumn:(NSTableColumn *)p1;
	-(NSArray *) tableView:(NSTableView *)p0 rowActionsForRow:(NSInteger)p1 edge:(NSInteger)p2;
	-(void) tableViewSelectionDidChange:(NSNotification *)p0;
	-(void) tableViewSelectionIsChanging:(NSNotification *)p0;
	-(BOOL) selectionShouldChangeInTableView:(NSTableView *)p0;
	-(BOOL) tableView:(NSTableView *)p0 shouldEditTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldReorderColumn:(NSInteger)p1 toColumn:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectTableColumn:(NSTableColumn *)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldShowCellExpansionForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldTrackCell:(NSCell *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(BOOL) tableView:(NSTableView *)p0 shouldTypeSelectForEvent:(NSEvent *)p1 withCurrentSearchString:(NSString *)p2;
	-(void) tableView:(NSTableView *)p0 willDisplayCell:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTableView__NSTableViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tableViewColumnDidMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xE35D9C);
	}

	-(void) tableViewColumnDidResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xE35E9C);
	}

	-(NSTableRowView *) tableView:(NSTableView *)p0 rowViewForRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_274 (self, _cmd, &managed_method, p0, p1, 0xE35F9C);
	}

	-(void) tableView:(NSTableView *)p0 didAddRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_275 (self, _cmd, &managed_method, p0, p1, p2, 0xE3609C);
	}

	-(void) tableView:(NSTableView *)p0 didClickTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_276 (self, _cmd, &managed_method, p0, p1, 0xE3619C);
	}

	-(void) tableView:(NSTableView *)p0 didDragTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_276 (self, _cmd, &managed_method, p0, p1, 0xE3629C);
	}

	-(void) tableView:(NSTableView *)p0 didRemoveRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_275 (self, _cmd, &managed_method, p0, p1, p2, 0xE3639C);
	}

	-(NSCell *) tableView:(NSTableView *)p0 dataCellForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_277 (self, _cmd, &managed_method, p0, p1, p2, 0xE3649C);
	}

	-(NSInteger) tableView:(NSTableView *)p0 nextTypeSelectMatchFromRow:(NSInteger)p1 toRow:(NSInteger)p2 forString:(NSString *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_278 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xE3659C);
	}

	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_279 (self, _cmd, &managed_method, p0, p1, 0xE3669C);
	}

	-(NSString *) tableView:(NSTableView *)p0 typeSelectStringForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_280 (self, _cmd, &managed_method, p0, p1, p2, 0xE3679C);
	}

	-(NSIndexSet *) tableView:(NSTableView *)p0 selectionIndexesForProposedSelection:(NSIndexSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_281 (self, _cmd, &managed_method, p0, p1, 0xE3689C);
	}

	-(CGFloat) tableView:(NSTableView *)p0 sizeToFitWidthOfColumn:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_279 (self, _cmd, &managed_method, p0, p1, 0xE3699C);
	}

	-(NSString *) tableView:(NSTableView *)p0 toolTipForCell:(NSCell *)p1 rect:(CGRect*)p2 tableColumn:(NSTableColumn *)p3 row:(NSInteger)p4 mouseLocation:(CGPoint)p5
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_282 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, 0xE36A9C);
	}

	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_283 (self, _cmd, &managed_method, p0, p1, p2, 0xE36B9C);
	}

	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_284 (self, _cmd, &managed_method, p0, p1, 0xE36C9C);
	}

	-(void) tableView:(NSTableView *)p0 mouseDownInHeaderOfTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_276 (self, _cmd, &managed_method, p0, p1, 0xE36D9C);
	}

	-(NSArray *) tableView:(NSTableView *)p0 rowActionsForRow:(NSInteger)p1 edge:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_285 (self, _cmd, &managed_method, p0, p1, p2, 0xE36E9C);
	}

	-(void) tableViewSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xE36F9C);
	}

	-(void) tableViewSelectionIsChanging:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xE3709C);
	}

	-(BOOL) selectionShouldChangeInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_286 (self, _cmd, &managed_method, p0, 0xE3719C);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldEditTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_287 (self, _cmd, &managed_method, p0, p1, p2, 0xE3729C);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldReorderColumn:(NSInteger)p1 toColumn:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_288 (self, _cmd, &managed_method, p0, p1, p2, 0xE3739C);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_284 (self, _cmd, &managed_method, p0, p1, 0xE3749C);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_289 (self, _cmd, &managed_method, p0, p1, 0xE3759C);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldShowCellExpansionForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_287 (self, _cmd, &managed_method, p0, p1, p2, 0xE3769C);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldTrackCell:(NSCell *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_290 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xE3779C);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldTypeSelectForEvent:(NSEvent *)p1 withCurrentSearchString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_291 (self, _cmd, &managed_method, p0, p1, p2, 0xE3789C);
	}

	-(void) tableView:(NSTableView *)p0 willDisplayCell:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_292 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xE3799C);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_244 (self, _cmd, &managed_method, p0, 0xE37A9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xE35C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSharingService__NSSharingServiceDelegate : NSObject<NSSharingServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSView *) anchoringViewForSharingService:(NSSharingService *)p0 showRelativeToRect:(CGRect*)p1 preferredEdge:(NSUInteger*)p2;
	-(void) sharingService:(NSSharingService *)p0 didFailToShareItems:(NSArray *)p1 error:(NSError *)p2;
	-(void) sharingService:(NSSharingService *)p0 didShareItems:(NSArray *)p1;
	-(CGRect) sharingService:(NSSharingService *)p0 sourceFrameOnScreenForShareItem:(id)p1;
	-(NSWindow *) sharingService:(NSSharingService *)p0 sourceWindowForShareItems:(NSArray *)p1 sharingContentScope:(NSInteger)p2;
	-(NSImage *) sharingService:(NSSharingService *)p0 transitionImageForShareItem:(id)p1 contentRect:(CGRect)p2;
	-(void) sharingService:(NSSharingService *)p0 willShareItems:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSharingService__NSSharingServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSView *) anchoringViewForSharingService:(NSSharingService *)p0 showRelativeToRect:(CGRect*)p1 preferredEdge:(NSUInteger*)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_293 (self, _cmd, &managed_method, p0, p1, p2, 0xC9579C);
	}

	-(void) sharingService:(NSSharingService *)p0 didFailToShareItems:(NSArray *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_294 (self, _cmd, &managed_method, p0, p1, p2, 0xC9589C);
	}

	-(void) sharingService:(NSSharingService *)p0 didShareItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_295 (self, _cmd, &managed_method, p0, p1, 0xC9599C);
	}

	-(CGRect) sharingService:(NSSharingService *)p0 sourceFrameOnScreenForShareItem:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_296 (self, _cmd, &managed_method, p0, p1, 0xC95A9C);
	}

	-(NSWindow *) sharingService:(NSSharingService *)p0 sourceWindowForShareItems:(NSArray *)p1 sharingContentScope:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, p1, p2, 0xC95B9C);
	}

	-(NSImage *) sharingService:(NSSharingService *)p0 transitionImageForShareItem:(id)p1 contentRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_298 (self, _cmd, &managed_method, p0, p1, p2, 0xC95C9C);
	}

	-(void) sharingService:(NSSharingService *)p0 willShareItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_295 (self, _cmd, &managed_method, p0, p1, 0xC95D9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xC9569C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSound__NSSoundDelegate : NSObject<NSSoundDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) sound:(NSSound *)p0 didFinishPlaying:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSound__NSSoundDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) sound:(NSSound *)p0 didFinishPlaying:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_299 (self, _cmd, &managed_method, p0, p1, 0xC9E89C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xC9E79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate : NSObject<NSSharingServicePickerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(id) sharingServicePicker:(NSSharingServicePicker *)p0 delegateForSharingService:(NSSharingService *)p1;
	-(void) sharingServicePicker:(NSSharingServicePicker *)p0 didChooseSharingService:(NSSharingService *)p1;
	-(NSArray *) sharingServicePicker:(NSSharingServicePicker *)p0 sharingServicesForItems:(NSArray *)p1 proposedSharingServices:(NSArray *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(id) sharingServicePicker:(NSSharingServicePicker *)p0 delegateForSharingService:(NSSharingService *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_300 (self, _cmd, &managed_method, p0, p1, 0xCA3C9C);
	}

	-(void) sharingServicePicker:(NSSharingServicePicker *)p0 didChooseSharingService:(NSSharingService *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_301 (self, _cmd, &managed_method, p0, p1, 0xCA3D9C);
	}

	-(NSArray *) sharingServicePicker:(NSSharingServicePicker *)p0 sharingServicesForItems:(NSArray *)p1 proposedSharingServices:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_302 (self, _cmd, &managed_method, p0, p1, p2, 0xCA3E9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xCA3B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTextStorage__NSTextStorageDelegate : NSObject<NSTextStorageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(void) textStorageDidProcessEditing:(NSNotification *)p0;
	-(void) textStorageWillProcessEditing:(NSNotification *)p0;
	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTextStorage__NSTextStorageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_303 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xEE569C);
	}

	-(void) textStorageDidProcessEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xEE579C);
	}

	-(void) textStorageWillProcessEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xEE589C);
	}

	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_303 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xEE599C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xEE559C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSWindow__NSWindowDelegate : NSObject<NSWindowDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) customWindowsToEnterFullScreenForWindow:(NSWindow *)p0;
	-(NSArray *) customWindowsToExitFullScreenForWindow:(NSWindow *)p0;
	-(void) windowDidBecomeKey:(NSNotification *)p0;
	-(void) windowDidBecomeMain:(NSNotification *)p0;
	-(void) windowDidChangeBackingProperties:(NSNotification *)p0;
	-(void) windowDidChangeScreen:(NSNotification *)p0;
	-(void) windowDidChangeScreenProfile:(NSNotification *)p0;
	-(void) window:(NSWindow *)p0 didDecodeRestorableState:(NSCoder *)p1;
	-(void) windowDidDeminiaturize:(NSNotification *)p0;
	-(void) windowDidEndLiveResize:(NSNotification *)p0;
	-(void) windowDidEndSheet:(NSNotification *)p0;
	-(void) windowDidEnterFullScreen:(NSNotification *)p0;
	-(void) windowDidEnterVersionBrowser:(NSNotification *)p0;
	-(void) windowDidExitFullScreen:(NSNotification *)p0;
	-(void) windowDidExitVersionBrowser:(NSNotification *)p0;
	-(void) windowDidExpose:(NSNotification *)p0;
	-(void) windowDidFailToEnterFullScreen:(NSWindow *)p0;
	-(void) windowDidFailToExitFullScreen:(NSWindow *)p0;
	-(void) windowDidMiniaturize:(NSNotification *)p0;
	-(void) windowDidMove:(NSNotification *)p0;
	-(void) windowDidResignKey:(NSNotification *)p0;
	-(void) windowDidResignMain:(NSNotification *)p0;
	-(void) windowDidResize:(NSNotification *)p0;
	-(void) windowDidUpdate:(NSNotification *)p0;
	-(BOOL) window:(NSWindow *)p0 shouldDragDocumentWithEvent:(NSEvent *)p1 from:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3;
	-(BOOL) window:(NSWindow *)p0 shouldPopUpDocumentPathMenu:(NSMenu *)p1;
	-(BOOL) windowShouldZoom:(NSWindow *)p0 toFrame:(CGRect)p1;
	-(void) window:(NSWindow *)p0 startCustomAnimationToEnterFullScreenWithDuration:(double)p1;
	-(void) window:(NSWindow *)p0 startCustomAnimationToExitFullScreenWithDuration:(double)p1;
	-(void) windowWillBeginSheet:(NSNotification *)p0;
	-(void) windowWillClose:(NSNotification *)p0;
	-(void) window:(NSWindow *)p0 willEncodeRestorableState:(NSCoder *)p1;
	-(void) windowWillEnterFullScreen:(NSNotification *)p0;
	-(void) windowWillEnterVersionBrowser:(NSNotification *)p0;
	-(void) windowWillExitFullScreen:(NSNotification *)p0;
	-(void) windowWillExitVersionBrowser:(NSNotification *)p0;
	-(void) windowWillMiniaturize:(NSNotification *)p0;
	-(void) windowWillMove:(NSNotification *)p0;
	-(CGRect) window:(NSWindow *)p0 willPositionSheet:(NSWindow *)p1 usingRect:(CGRect)p2;
	-(CGSize) windowWillResize:(NSWindow *)p0 toSize:(CGSize)p1;
	-(CGSize) window:(NSWindow *)p0 willResizeForVersionBrowserWithMaxPreferredSize:(CGSize)p1 maxAllowedSize:(CGSize)p2;
	-(NSObject *) windowWillReturnFieldEditor:(NSWindow *)p0 toObject:(NSObject *)p1;
	-(NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)p0;
	-(void) windowWillStartLiveResize:(NSNotification *)p0;
	-(CGSize) window:(NSWindow *)p0 willUseFullScreenContentSize:(CGSize)p1;
	-(NSUInteger) window:(NSWindow *)p0 willUseFullScreenPresentationOptions:(NSUInteger)p1;
	-(CGRect) windowWillUseStandardFrame:(NSWindow *)p0 defaultFrame:(CGRect)p1;
	-(BOOL) windowShouldClose:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSWindow__NSWindowDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) customWindowsToEnterFullScreenForWindow:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_304 (self, _cmd, &managed_method, p0, 0x11A599C);
	}

	-(NSArray *) customWindowsToExitFullScreenForWindow:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_304 (self, _cmd, &managed_method, p0, 0x11A5A9C);
	}

	-(void) windowDidBecomeKey:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A5B9C);
	}

	-(void) windowDidBecomeMain:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A5C9C);
	}

	-(void) windowDidChangeBackingProperties:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A5D9C);
	}

	-(void) windowDidChangeScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A5E9C);
	}

	-(void) windowDidChangeScreenProfile:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A5F9C);
	}

	-(void) window:(NSWindow *)p0 didDecodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_305 (self, _cmd, &managed_method, p0, p1, 0x11A609C);
	}

	-(void) windowDidDeminiaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A619C);
	}

	-(void) windowDidEndLiveResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A629C);
	}

	-(void) windowDidEndSheet:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A639C);
	}

	-(void) windowDidEnterFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A649C);
	}

	-(void) windowDidEnterVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A659C);
	}

	-(void) windowDidExitFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A669C);
	}

	-(void) windowDidExitVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A679C);
	}

	-(void) windowDidExpose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A689C);
	}

	-(void) windowDidFailToEnterFullScreen:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_306 (self, _cmd, &managed_method, p0, 0x11A699C);
	}

	-(void) windowDidFailToExitFullScreen:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_306 (self, _cmd, &managed_method, p0, 0x11A6A9C);
	}

	-(void) windowDidMiniaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A6B9C);
	}

	-(void) windowDidMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A6C9C);
	}

	-(void) windowDidResignKey:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A6D9C);
	}

	-(void) windowDidResignMain:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A6E9C);
	}

	-(void) windowDidResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A6F9C);
	}

	-(void) windowDidUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A709C);
	}

	-(BOOL) window:(NSWindow *)p0 shouldDragDocumentWithEvent:(NSEvent *)p1 from:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_307 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x11A719C);
	}

	-(BOOL) window:(NSWindow *)p0 shouldPopUpDocumentPathMenu:(NSMenu *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_308 (self, _cmd, &managed_method, p0, p1, 0x11A729C);
	}

	-(BOOL) windowShouldZoom:(NSWindow *)p0 toFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_309 (self, _cmd, &managed_method, p0, p1, 0x11A739C);
	}

	-(void) window:(NSWindow *)p0 startCustomAnimationToEnterFullScreenWithDuration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_310 (self, _cmd, &managed_method, p0, p1, 0x11A749C);
	}

	-(void) window:(NSWindow *)p0 startCustomAnimationToExitFullScreenWithDuration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_310 (self, _cmd, &managed_method, p0, p1, 0x11A759C);
	}

	-(void) windowWillBeginSheet:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A769C);
	}

	-(void) windowWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A779C);
	}

	-(void) window:(NSWindow *)p0 willEncodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_305 (self, _cmd, &managed_method, p0, p1, 0x11A789C);
	}

	-(void) windowWillEnterFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A799C);
	}

	-(void) windowWillEnterVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A7A9C);
	}

	-(void) windowWillExitFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A7B9C);
	}

	-(void) windowWillExitVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A7C9C);
	}

	-(void) windowWillMiniaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A7D9C);
	}

	-(void) windowWillMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A7E9C);
	}

	-(CGRect) window:(NSWindow *)p0 willPositionSheet:(NSWindow *)p1 usingRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_311 (self, _cmd, &managed_method, p0, p1, p2, 0x11A7F9C);
	}

	-(CGSize) windowWillResize:(NSWindow *)p0 toSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_312 (self, _cmd, &managed_method, p0, p1, 0x11A809C);
	}

	-(CGSize) window:(NSWindow *)p0 willResizeForVersionBrowserWithMaxPreferredSize:(CGSize)p1 maxAllowedSize:(CGSize)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_313 (self, _cmd, &managed_method, p0, p1, p2, 0x11A819C);
	}

	-(NSObject *) windowWillReturnFieldEditor:(NSWindow *)p0 toObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_314 (self, _cmd, &managed_method, p0, p1, 0x11A829C);
	}

	-(NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_315 (self, _cmd, &managed_method, p0, 0x11A839C);
	}

	-(void) windowWillStartLiveResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x11A849C);
	}

	-(CGSize) window:(NSWindow *)p0 willUseFullScreenContentSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_312 (self, _cmd, &managed_method, p0, p1, 0x11A859C);
	}

	-(NSUInteger) window:(NSWindow *)p0 willUseFullScreenPresentationOptions:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_316 (self, _cmd, &managed_method, p0, p1, 0x11A869C);
	}

	-(CGRect) windowWillUseStandardFrame:(NSWindow *)p0 defaultFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_317 (self, _cmd, &managed_method, p0, p1, 0x11A879C);
	}

	-(BOOL) windowShouldClose:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_318 (self, _cmd, &managed_method, p0, 0x11A889C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x11A589C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate : NSObject<IKCameraDeviceViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didEncounterError:(NSError *)p1;
	-(void) cameraDeviceViewSelectionDidChange:(IKCameraDeviceView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_319 (self, _cmd, &managed_method, p0, p1, 0xE1B89C);
	}

	-(void) cameraDeviceViewSelectionDidChange:(IKCameraDeviceView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_320 (self, _cmd, &managed_method, p0, 0xE1B99C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xE1B79C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate : NSObject<IKDeviceBrowserViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 didEncounterError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_321 (self, _cmd, &managed_method, p0, p1, 0xE31C9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xE31B9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTabView__NSTabViewDelegate : NSObject<NSTabViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tabView:(NSTabView *)p0 didSelectTabViewItem:(NSTabViewItem *)p1;
	-(void) tabViewDidChangeNumberOfTabViewItems:(NSTabView *)p0;
	-(BOOL) tabView:(NSTabView *)p0 shouldSelectTabViewItem:(NSTabViewItem *)p1;
	-(void) tabView:(NSTabView *)p0 willSelectTabViewItem:(NSTabViewItem *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTabView__NSTabViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tabView:(NSTabView *)p0 didSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_322 (self, _cmd, &managed_method, p0, p1, 0xE8169C);
	}

	-(void) tabViewDidChangeNumberOfTabViewItems:(NSTabView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_323 (self, _cmd, &managed_method, p0, 0xE8179C);
	}

	-(BOOL) tabView:(NSTabView *)p0 shouldSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_324 (self, _cmd, &managed_method, p0, p1, 0xE8189C);
	}

	-(void) tabView:(NSTabView *)p0 willSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_322 (self, _cmd, &managed_method, p0, p1, 0xE8199C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xE8159C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKImageBrowserView__IKImageBrowserDelegate : NSObject<IKImageBrowserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) imageBrowser:(IKImageBrowserView *)p0 backgroundWasRightClickedWithEvent:(NSEvent *)p1;
	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasDoubleClickedAtIndex:(NSInteger)p1;
	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasRightClickedAtIndex:(NSInteger)p1 withEvent:(NSEvent *)p2;
	-(void) imageBrowserSelectionDidChange:(IKImageBrowserView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKImageBrowserView__IKImageBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) imageBrowser:(IKImageBrowserView *)p0 backgroundWasRightClickedWithEvent:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_325 (self, _cmd, &managed_method, p0, p1, 0xE8C39C);
	}

	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasDoubleClickedAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_326 (self, _cmd, &managed_method, p0, p1, 0xE8C49C);
	}

	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasRightClickedAtIndex:(NSInteger)p1 withEvent:(NSEvent *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_327 (self, _cmd, &managed_method, p0, p1, p2, 0xE8C59C);
	}

	-(void) imageBrowserSelectionDidChange:(IKImageBrowserView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_328 (self, _cmd, &managed_method, p0, 0xE8C69C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xE8C29C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKSaveOptions__IKSaveOptionsDelegate : NSObject<IKSaveOptionsDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) saveOptions:(IKSaveOptions *)p0 shouldShowUTType:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKSaveOptions__IKSaveOptionsDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) saveOptions:(IKSaveOptions *)p0 shouldShowUTType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_329 (self, _cmd, &managed_method, p0, p1, 0xEB8D9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xEB8C9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSText__NSTextDelegate : NSObject<NSTextDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textDidBeginEditing:(NSNotification *)p0;
	-(void) textDidChange:(NSNotification *)p0;
	-(void) textDidEndEditing:(NSNotification *)p0;
	-(BOOL) textShouldBeginEditing:(NSText *)p0;
	-(BOOL) textShouldEndEditing:(NSText *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSText__NSTextDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xEC299C);
	}

	-(void) textDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xEC2A9C);
	}

	-(void) textDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xEC2B9C);
	}

	-(BOOL) textShouldBeginEditing:(NSText *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_330 (self, _cmd, &managed_method, p0, 0xEC2C9C);
	}

	-(BOOL) textShouldEndEditing:(NSText *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_330 (self, _cmd, &managed_method, p0, 0xEC2D9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xEC289C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate : NSObject<IKScannerDeviceViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didEncounterError:(NSError *)p1;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 fileData:(NSData *)p2 error:(NSError *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_331 (self, _cmd, &managed_method, p0, p1, 0xEC919C);
	}

	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 fileData:(NSData *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_332 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xEC929C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xEC909C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end






@interface ScriptingBridge_SBApplication__SBApplicationDelegate : NSObject<SBApplicationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) eventDidFail:(void *)p0 withError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ScriptingBridge_SBApplication__SBApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) eventDidFail:(void *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, p1, 0x10E689C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x10E679C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end


@interface AppKit_NSTouchBar__NSTouchBarDelegate : NSObject<NSTouchBarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSTouchBarItem *) touchBar:(NSTouchBar *)p0 makeItemForIdentifier:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTouchBar__NSTouchBarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSTouchBarItem *) touchBar:(NSTouchBar *)p0 makeItemForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_334 (self, _cmd, &managed_method, p0, p1, 0xF0109C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xF00F9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end



@interface AppKit_NSTextView__NSTextViewDelegate : AppKit_NSText__NSTextDelegate<NSTextViewDelegate, NSTextDelegate> {
}
	-(void) textView:(NSTextView *)p0 clickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3;
	-(void) textView:(NSTextView *)p0 doubleClickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3;
	-(void) textViewDidChangeSelection:(NSNotification *)p0;
	-(void) textViewDidChangeTypingAttributes:(NSNotification *)p0;
	-(NSArray *) textView:(NSTextView *)p0 didCheckTextInRange:(NSRange)p1 types:(unsigned long long)p2 options:(NSDictionary *)p3 results:(NSArray *)p4 orthography:(NSOrthography *)p5 wordCount:(NSInteger)p6;
	-(BOOL) textView:(NSTextView *)p0 doCommandBySelector:(SEL)p1;
	-(void) textView:(NSTextView *)p0 draggedCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 event:(NSEvent *)p3;
	-(NSArray *) textView:(NSTextView *)p0 candidatesForSelectedRange:(NSRange)p1;
	-(NSArray *) textView:(NSTextView *)p0 completions:(NSArray *)p1 forPartialWordRange:(NSRange)p2 indexOfSelectedItem:(NSInteger*)p3;
	-(NSArray *) textView:(NSTextView *)p0 candidates:(NSArray *)p1 forSelectedRange:(NSRange)p2;
	-(NSUndoManager *) undoManagerForTextView:(NSTextView *)p0;
	-(NSArray *) textView:(NSTextView *)p0 writablePasteboardTypesForCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2;
	-(BOOL) textView:(NSTextView *)p0 clickedOnLink:(NSObject *)p1 atIndex:(NSUInteger)p2;
	-(NSMenu *) textView:(NSTextView *)p0 menu:(NSMenu *)p1 forEvent:(NSEvent *)p2 atIndex:(NSUInteger)p3;
	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementString:(NSString *)p2;
	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRanges:(NSArray *)p1 replacementStrings:(NSArray *)p2;
	-(NSDictionary *) textView:(NSTextView *)p0 shouldChangeTypingAttributes:(NSDictionary *)p1 toAttributes:(NSDictionary *)p2;
	-(BOOL) textView:(NSTextView *)p0 shouldSelectCandidateAtIndex:(NSUInteger)p1;
	-(NSInteger) textView:(NSTextView *)p0 shouldSetSpellingState:(NSInteger)p1 range:(NSRange)p2;
	-(NSArray *) textView:(NSTextView *)p0 shouldUpdateTouchBarItemIdentifiers:(NSArray *)p1;
	-(NSRange) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRange:(NSRange)p1 toCharacterRange:(NSRange)p2;
	-(NSArray *) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRanges:(NSArray *)p1 toCharacterRanges:(NSArray *)p2;
	-(NSDictionary *) textView:(NSTextView *)p0 willCheckTextInRange:(NSRange)p1 options:(NSDictionary *)p2 types:(unsigned long long)p3;
	-(NSString *) textView:(NSTextView *)p0 willDisplayToolTip:(NSString *)p1 forCharacterAtIndex:(NSUInteger)p2;
	-(BOOL) textView:(NSTextView *)p0 writeCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2 toPasteboard:(NSPasteboard *)p3 type:(NSString *)p4;
	-(id) init;
@end

@implementation AppKit_NSTextView__NSTextViewDelegate {
}

	-(void) textView:(NSTextView *)p0 clickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_335 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xF7919C);
	}

	-(void) textView:(NSTextView *)p0 doubleClickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_335 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xF7929C);
	}

	-(void) textViewDidChangeSelection:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xF7939C);
	}

	-(void) textViewDidChangeTypingAttributes:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xF7949C);
	}

	-(NSArray *) textView:(NSTextView *)p0 didCheckTextInRange:(NSRange)p1 types:(unsigned long long)p2 options:(NSDictionary *)p3 results:(NSArray *)p4 orthography:(NSOrthography *)p5 wordCount:(NSInteger)p6
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_336 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, p6, 0xF7959C);
	}

	-(BOOL) textView:(NSTextView *)p0 doCommandBySelector:(SEL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_337 (self, _cmd, &managed_method, p0, p1, 0xF7969C);
	}

	-(void) textView:(NSTextView *)p0 draggedCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 event:(NSEvent *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_338 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xF7979C);
	}

	-(NSArray *) textView:(NSTextView *)p0 candidatesForSelectedRange:(NSRange)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_339 (self, _cmd, &managed_method, p0, p1, 0xF7989C);
	}

	-(NSArray *) textView:(NSTextView *)p0 completions:(NSArray *)p1 forPartialWordRange:(NSRange)p2 indexOfSelectedItem:(NSInteger*)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_340 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xF7999C);
	}

	-(NSArray *) textView:(NSTextView *)p0 candidates:(NSArray *)p1 forSelectedRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_341 (self, _cmd, &managed_method, p0, p1, p2, 0xF79A9C);
	}

	-(NSUndoManager *) undoManagerForTextView:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_342 (self, _cmd, &managed_method, p0, 0xF79B9C);
	}

	-(NSArray *) textView:(NSTextView *)p0 writablePasteboardTypesForCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_343 (self, _cmd, &managed_method, p0, p1, p2, 0xF79C9C);
	}

	-(BOOL) textView:(NSTextView *)p0 clickedOnLink:(NSObject *)p1 atIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_344 (self, _cmd, &managed_method, p0, p1, p2, 0xF79D9C);
	}

	-(NSMenu *) textView:(NSTextView *)p0 menu:(NSMenu *)p1 forEvent:(NSEvent *)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_345 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xF79E9C);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_346 (self, _cmd, &managed_method, p0, p1, p2, 0xF79F9C);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRanges:(NSArray *)p1 replacementStrings:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_347 (self, _cmd, &managed_method, p0, p1, p2, 0xF7A09C);
	}

	-(NSDictionary *) textView:(NSTextView *)p0 shouldChangeTypingAttributes:(NSDictionary *)p1 toAttributes:(NSDictionary *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_348 (self, _cmd, &managed_method, p0, p1, p2, 0xF7A19C);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldSelectCandidateAtIndex:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_349 (self, _cmd, &managed_method, p0, p1, 0xF7A29C);
	}

	-(NSInteger) textView:(NSTextView *)p0 shouldSetSpellingState:(NSInteger)p1 range:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_350 (self, _cmd, &managed_method, p0, p1, p2, 0xF7A39C);
	}

	-(NSArray *) textView:(NSTextView *)p0 shouldUpdateTouchBarItemIdentifiers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_351 (self, _cmd, &managed_method, p0, p1, 0xF7A49C);
	}

	-(NSRange) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRange:(NSRange)p1 toCharacterRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, p0, p1, p2, 0xF7A59C);
	}

	-(NSArray *) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRanges:(NSArray *)p1 toCharacterRanges:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, p1, p2, 0xF7A69C);
	}

	-(NSDictionary *) textView:(NSTextView *)p0 willCheckTextInRange:(NSRange)p1 options:(NSDictionary *)p2 types:(unsigned long long)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_354 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xF7A79C);
	}

	-(NSString *) textView:(NSTextView *)p0 willDisplayToolTip:(NSString *)p1 forCharacterAtIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_355 (self, _cmd, &managed_method, p0, p1, p2, 0xF7A89C);
	}

	-(BOOL) textView:(NSTextView *)p0 writeCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2 toPasteboard:(NSPasteboard *)p3 type:(NSString *)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_356 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0xF7A99C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xF7909C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSText__NSTextDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end


@interface Foundation_NSMetadataQuery__NSMetadataQueryDelegate : NSObject<NSMetadataQueryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSMetadataQuery__NSMetadataQueryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_357 (self, _cmd, &managed_method, p0, p1, 0xFCC19C);
	}

	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_358 (self, _cmd, &managed_method, p0, p1, p2, 0xFCC29C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xFCC09C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSToolbar__NSToolbarDelegate : NSObject<NSToolbarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0;
	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0;
	-(void) toolbarDidRemoveItem:(NSNotification *)p0;
	-(NSArray *) toolbarSelectableItemIdentifiers:(NSToolbar *)p0;
	-(void) toolbarWillAddItem:(NSNotification *)p0;
	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSToolbar__NSToolbarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, 0xFD4A9C);
	}

	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, 0xFD4B9C);
	}

	-(void) toolbarDidRemoveItem:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xFD4C9C);
	}

	-(NSArray *) toolbarSelectableItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, 0xFD4D9C);
	}

	-(void) toolbarWillAddItem:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0xFD4E9C);
	}

	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, p0, p1, p2, 0xFD4F9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xFD499C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end



@interface SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate : NSObject<SCNPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, p1, 0x1076E9C);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, p1, 0x1076F9C);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, p1, 0x107709C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1076D9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MapKit_MKMapView__MKMapViewDelegate : NSObject<MKMapViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3;
	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1;
	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1;
	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1;
	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1;
	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0;
	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1;
	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1;
	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0;
	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0;
	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MapKit_MKMapView__MKMapViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_362 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x10AE29C);
	}

	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_363 (self, _cmd, &managed_method, p0, p1, 0x10AE39C);
	}

	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_364 (self, _cmd, &managed_method, p0, p1, 0x10AE49C);
	}

	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_364 (self, _cmd, &managed_method, p0, p1, 0x10AE59C);
	}

	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_365 (self, _cmd, &managed_method, p0, p1, 0x10AE69C);
	}

	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_366 (self, _cmd, &managed_method, p0, p1, 0x10AE79C);
	}

	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_367 (self, _cmd, &managed_method, p0, p1, 0x10AE89C);
	}

	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_365 (self, _cmd, &managed_method, p0, p1, 0x10AE99C);
	}

	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_368 (self, _cmd, &managed_method, p0, 0x10AEA9C);
	}

	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_369 (self, _cmd, &managed_method, p0, p1, 0x10AEB9C);
	}

	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_370 (self, _cmd, &managed_method, p0, p1, 0x10AEC9C);
	}

	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_366 (self, _cmd, &managed_method, p0, p1, 0x10AED9C);
	}

	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_368 (self, _cmd, &managed_method, p0, 0x10AEE9C);
	}

	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_371 (self, _cmd, &managed_method, p0, p1, 0x10AEF9C);
	}

	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_367 (self, _cmd, &managed_method, p0, p1, 0x10AF09C);
	}

	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_367 (self, _cmd, &managed_method, p0, p1, 0x10AF19C);
	}

	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_368 (self, _cmd, &managed_method, p0, 0x10AF29C);
	}

	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_368 (self, _cmd, &managed_method, p0, 0x10AF39C);
	}

	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_368 (self, _cmd, &managed_method, p0, 0x10AF49C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x10AE19C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate : NSObject<SKPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) didBeginContact:(SKPhysicsContact *)p0;
	-(void) didEndContact:(SKPhysicsContact *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) didBeginContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_372 (self, _cmd, &managed_method, p0, 0x112AB9C);
	}

	-(void) didEndContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_372 (self, _cmd, &managed_method, p0, 0x112AC9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x112AA9C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKRequest__SKRequestDelegate : NSObject<SKRequestDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1;
	-(void) requestDidFinish:(SKRequest *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation StoreKit_SKRequest__SKRequestDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_373 (self, _cmd, &managed_method, p0, p1, 0x11ED99C);
	}

	-(void) requestDidFinish:(SKRequest *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_374 (self, _cmd, &managed_method, p0, 0x11EDA9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x11ED89C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKProductsRequest__SKProductsRequestDelegate : StoreKit_SKRequest__SKRequestDelegate<SKProductsRequestDelegate, SKRequestDelegate> {
}
	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1;
	-(id) init;
@end

@implementation StoreKit_SKProductsRequest__SKProductsRequestDelegate {
}

	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_375 (self, _cmd, &managed_method, p0, p1, 0x11D239C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x11D229C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [StoreKit_SKRequest__SKRequestDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate : NSObject<NSURLSessionDataDelegate, NSURLSessionTaskDelegate, NSURLSessionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(id)p3;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(id)p3;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(id)p4;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(id)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_376 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x159C);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_377 (self, _cmd, &managed_method, p0, p1, p2, 0x169C);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_378 (self, _cmd, &managed_method, p0, p1, p2, 0x179C);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_379 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x199C);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(id)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_380 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x1A9C);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_381 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B9C);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation Xwt_Gtk_Mac_GtkMacSaveFileDialogBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x819E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSavePanel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Gtk_Mac_WebViewBackend_XwtWebUIDelegate : NSObject<WebUIDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Gtk_Mac_WebViewBackend_XwtWebUIDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0xA29E);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation Xwt_Gtk_Mac_GtkMacOpenFileDialogBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x749E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSOpenPanel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Gtk_Mac_GtkMacSelectFolderBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x8E9E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSOpenPanel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_WidgetView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x606A2);
	}

	-(BOOL) acceptsFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x607A2);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x608A2);
	}

	-(void) updateTrackingAreas
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x609A2);
	}

	-(void) rightMouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x60AA2);
	}

	-(void) rightMouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x60BA2);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x60CA2);
	}

	-(void) mouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x60DA2);
	}

	-(void) mouseEntered:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x60EA2);
	}

	-(void) mouseExited:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x60FA2);
	}

	-(void) mouseMoved:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x610A2);
	}

	-(void) mouseDragged:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x611A2);
	}

	-(void) keyDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x612A2);
	}

	-(void) keyUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x613A2);
	}

	-(void) setFrameSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x614A2);
	}

	-(void) resetCursorRects
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x615A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_CustomAlignedContainer : Xwt_Mac_WidgetView {
}
	-(void) setFrameSize:(CGSize)p0;
@end

@implementation Xwt_Mac_CustomAlignedContainer {
}

	-(void) setFrameSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x43A2);
	}
@end

@interface Xwt_Mac_TextFieldView : NSTextField {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) acceptsFirstResponder;
	-(BOOL) allowsVibrancy;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_TextFieldView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) acceptsFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4BA2);
	}

	-(BOOL) allowsVibrancy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4CA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x49A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTextField class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CustomTextFieldCell : NSTextFieldCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGRect) titleRectForBounds:(CGRect)p0;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_CustomTextFieldCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGRect) titleRectForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x4EA2);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x4FA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x50A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTextFieldCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_AppDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x73A2);
	}

	-(void) applicationWillFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x74A2);
	}

	-(void) handleGetURLEvent:(NSAppleEventDescriptor *)p0 withReplyEvent:(NSAppleEventDescriptor *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_382 (self, _cmd, &managed_method, p0, p1, 0x75A2);
	}

	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x76A2);
	}

	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_96 (self, _cmd, &managed_method, p0, 0x77A2);
	}

	-(void) applicationDidUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x78A2);
	}

	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_103 (self, _cmd, &managed_method, p0, p1, 0x79A2);
	}

	-(NSMenu *) applicationDockMenu:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_93 (self, _cmd, &managed_method, p0, 0x7AA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_TabView : NSTabView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_TabView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x96A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTabView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_TreeItem : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) copy;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_TreeItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) copy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_383 (self, _cmd, &managed_method, 0xB4A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0xB1A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_TreeSource : NSObject<NSOutlineViewDataSource> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) outlineView:(NSOutlineView *)p0 acceptDrop:(id<NSDraggingInfo>)p1 item:(NSObject *)p2 childIndex:(NSInteger)p3;
	-(NSArray *) outlineView:(NSOutlineView *)p0 namesOfPromisedFilesDroppedAtDestination:(NSURL *)p1 forDraggedItems:(NSArray *)p2;
	-(NSObject *) outlineView:(NSOutlineView *)p0 child:(NSInteger)p1 ofItem:(NSObject *)p2;
	-(NSInteger) outlineView:(NSOutlineView *)p0 numberOfChildrenOfItem:(NSObject *)p1;
	-(NSObject *) outlineView:(NSOutlineView *)p0 objectValueForTableColumn:(NSTableColumn *)p1 byItem:(NSObject *)p2;
	-(void) outlineView:(NSOutlineView *)p0 setObjectValue:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 byItem:(NSObject *)p3;
	-(BOOL) outlineView:(NSOutlineView *)p0 isItemExpandable:(NSObject *)p1;
	-(NSObject *) outlineView:(NSOutlineView *)p0 itemForPersistentObject:(NSObject *)p1;
	-(BOOL) outlineView:(NSOutlineView *)p0 writeItems:(NSArray *)p1 toPasteboard:(NSPasteboard *)p2;
	-(NSObject *) outlineView:(NSOutlineView *)p0 persistentObjectForItem:(NSObject *)p1;
	-(void) outlineView:(NSOutlineView *)p0 sortDescriptorsDidChange:(NSArray *)p1;
	-(NSUInteger) outlineView:(NSOutlineView *)p0 validateDrop:(id<NSDraggingInfo>)p1 proposedItem:(NSObject *)p2 proposedChildIndex:(NSInteger)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_TreeSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) outlineView:(NSOutlineView *)p0 acceptDrop:(id<NSDraggingInfo>)p1 item:(NSObject *)p2 childIndex:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_384 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xB7A2);
	}

	-(NSArray *) outlineView:(NSOutlineView *)p0 namesOfPromisedFilesDroppedAtDestination:(NSURL *)p1 forDraggedItems:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_385 (self, _cmd, &managed_method, p0, p1, p2, 0xB8A2);
	}

	-(NSObject *) outlineView:(NSOutlineView *)p0 child:(NSInteger)p1 ofItem:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_386 (self, _cmd, &managed_method, p0, p1, p2, 0xB9A2);
	}

	-(NSInteger) outlineView:(NSOutlineView *)p0 numberOfChildrenOfItem:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_387 (self, _cmd, &managed_method, p0, p1, 0xBAA2);
	}

	-(NSObject *) outlineView:(NSOutlineView *)p0 objectValueForTableColumn:(NSTableColumn *)p1 byItem:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_388 (self, _cmd, &managed_method, p0, p1, p2, 0xBBA2);
	}

	-(void) outlineView:(NSOutlineView *)p0 setObjectValue:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 byItem:(NSObject *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_389 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xBCA2);
	}

	-(BOOL) outlineView:(NSOutlineView *)p0 isItemExpandable:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_390 (self, _cmd, &managed_method, p0, p1, 0xBDA2);
	}

	-(NSObject *) outlineView:(NSOutlineView *)p0 itemForPersistentObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_391 (self, _cmd, &managed_method, p0, p1, 0xBEA2);
	}

	-(BOOL) outlineView:(NSOutlineView *)p0 writeItems:(NSArray *)p1 toPasteboard:(NSPasteboard *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_392 (self, _cmd, &managed_method, p0, p1, p2, 0xBFA2);
	}

	-(NSObject *) outlineView:(NSOutlineView *)p0 persistentObjectForItem:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_391 (self, _cmd, &managed_method, p0, p1, 0xC0A2);
	}

	-(void) outlineView:(NSOutlineView *)p0 sortDescriptorsDidChange:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_393 (self, _cmd, &managed_method, p0, p1, 0xC1A2);
	}

	-(NSUInteger) outlineView:(NSOutlineView *)p0 validateDrop:(id<NSDraggingInfo>)p1 proposedItem:(NSObject *)p2 proposedChildIndex:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_394 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xC2A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_WidgetPlacementWrapper : NSControl {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) isFlipped;
	-(void) setFrameSize:(CGSize)p0;
	-(void) sizeToFit;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_WidgetPlacementWrapper {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x152A2);
	}

	-(void) setFrameSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x154A2);
	}

	-(void) sizeToFit
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x156A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x14EA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSControl class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_WindowBackendController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x19EA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSWindowController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_TextTableCell : NSCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGSize) cellSizeForBounds:(CGRect)p0;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_TextTableCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGSize) cellSizeForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_395 (self, _cmd, &managed_method, p0, 0x1D0A2);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x1D1A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1C8A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_ImageTableCell : NSImageCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGSize) cellSize;
	-(CGSize) cellSizeForBounds:(CGRect)p0;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_ImageTableCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGSize) cellSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x1FCA2);
	}

	-(CGSize) cellSizeForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_395 (self, _cmd, &managed_method, p0, 0x1FDA2);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x1FEA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x1F4A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSImageCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_TableRow : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_TableRow {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x289A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_ListSource : NSObject<NSTableViewDataSource> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) tableView:(NSTableView *)p0 acceptDrop:(id<NSDraggingInfo>)p1 row:(NSInteger)p2 dropOperation:(NSUInteger)p3;
	-(NSArray *) tableView:(NSTableView *)p0 namesOfPromisedFilesDroppedAtDestination:(NSURL *)p1 forDraggedRowsWithIndexes:(NSIndexSet *)p2;
	-(NSObject *) tableView:(NSTableView *)p0 objectValueForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0;
	-(void) tableView:(NSTableView *)p0 setObjectValue:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(void) tableView:(NSTableView *)p0 sortDescriptorsDidChange:(NSArray *)p1;
	-(NSUInteger) tableView:(NSTableView *)p0 validateDrop:(id<NSDraggingInfo>)p1 proposedRow:(NSInteger)p2 proposedDropOperation:(NSUInteger)p3;
	-(BOOL) tableView:(NSTableView *)p0 writeRowsWithIndexes:(NSIndexSet *)p1 toPasteboard:(NSPasteboard *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_ListSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) tableView:(NSTableView *)p0 acceptDrop:(id<NSDraggingInfo>)p1 row:(NSInteger)p2 dropOperation:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_396 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x28BA2);
	}

	-(NSArray *) tableView:(NSTableView *)p0 namesOfPromisedFilesDroppedAtDestination:(NSURL *)p1 forDraggedRowsWithIndexes:(NSIndexSet *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_397 (self, _cmd, &managed_method, p0, p1, p2, 0x28CA2);
	}

	-(NSObject *) tableView:(NSTableView *)p0 objectValueForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, p1, p2, 0x28DA2);
	}

	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_26 (self, _cmd, &managed_method, p0, 0x28EA2);
	}

	-(void) tableView:(NSTableView *)p0 setObjectValue:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_292 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x28FA2);
	}

	-(void) tableView:(NSTableView *)p0 sortDescriptorsDidChange:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_398 (self, _cmd, &managed_method, p0, p1, 0x290A2);
	}

	-(NSUInteger) tableView:(NSTableView *)p0 validateDrop:(id<NSDraggingInfo>)p1 proposedRow:(NSInteger)p2 proposedDropOperation:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_399 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x291A2);
	}

	-(BOOL) tableView:(NSTableView *)p0 writeRowsWithIndexes:(NSIndexSet *)p1 toPasteboard:(NSPasteboard *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_400 (self, _cmd, &managed_method, p0, p1, p2, 0x292A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_ScrollView : NSScrollView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_ScrollView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2BBA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSScrollView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_MenuBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x2C6A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSMenu class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_PopUpButton : NSPopUpButton {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) resetCursorRects;
	-(BOOL) allowsVibrancy;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_PopUpButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) resetCursorRects
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x304A2);
	}

	-(BOOL) allowsVibrancy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x305A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x306A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSPopUpButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_ComboDataSource : NSObject<NSComboBoxDataSource> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) comboBox:(NSComboBox *)p0 objectValueForItemAtIndex:(NSInteger)p1;
	-(NSInteger) numberOfItemsInComboBox:(NSComboBox *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_ComboDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) comboBox:(NSComboBox *)p0 objectValueForItemAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_401 (self, _cmd, &managed_method, p0, p1, 0x36AA2);
	}

	-(NSInteger) numberOfItemsInComboBox:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_402 (self, _cmd, &managed_method, p0, 0x36BA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_MacFrame : NSBox {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_MacFrame {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x385A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSBox class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CustomContentView : NSView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) isFlipped;
	-(void) setFrameSize:(CGSize)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_CustomContentView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x389A2);
	}

	-(void) setFrameSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x38AA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x38CA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CustomScrollView : NSScrollView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) isFlipped;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_CustomScrollView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x3ABA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3ACA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSScrollView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_DummyClipView : NSView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) isFlipped;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_DummyClipView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x3ADA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3AEA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CustomClipView : NSClipView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) isFlipped;
	-(void) setFrameSize:(CGSize)p0;
	-(void) scrollToPoint:(CGPoint)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_CustomClipView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x3B6A2);
	}

	-(void) setFrameSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x3B7A2);
	}

	-(void) scrollToPoint:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_403 (self, _cmd, &managed_method, p0, 0x3B8A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_NormalClipView : NSClipView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) scrollToPoint:(CGPoint)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_NormalClipView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) scrollToPoint:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_403 (self, _cmd, &managed_method, p0, 0x3BCA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3BDA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSClipView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_SeparatorWidget : NSBox {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) allowsVibrancy;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_SeparatorWidget {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) allowsVibrancy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x3C4A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3C0A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSBox class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CustomSplitView : NSSplitView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_CustomSplitView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3D1A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSplitView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_ProgressIndicatorView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) resetCursorRects
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x3FEA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x3FAA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSProgressIndicator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_MacExpander : Xwt_Mac_WidgetView {
}
	-(BOOL) isFlipped;
	-(void) setFrameSize:(CGSize)p0;
@end

@implementation Xwt_Mac_MacExpander {
}

	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x441A2);
	}

	-(void) setFrameSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x446A2);
	}
@end

@interface Xwt_Mac_ExpanderWidget : NSView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_ExpanderWidget {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x451A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x44AA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_CollapsibleBox {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x459A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x453A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSBox class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_LinkLabelView : Xwt_Mac_TextFieldView {
}
	-(void) resetCursorRects;
	-(void) mouseUp:(NSEvent *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_LinkLabelView {
}

	-(void) resetCursorRects
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x483A2);
	}

	-(void) mouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x484A2);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x485A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xwt_Mac_TextFieldView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_FileDialogBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x486A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSOpenPanel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_OpenFileDialogBackend {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x499A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xwt_Mac_FileDialogBackend class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface XwtPasteboardOwner : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pasteboard:(NSPasteboard *)p0 provideDataForType:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation XwtPasteboardOwner {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pasteboard:(NSPasteboard *)p0 provideDataForType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_404 (self, _cmd, &managed_method, p0, p1, 0x4A3A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x4A4A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CustomWidgetView : Xwt_Mac_WidgetView {
}
	-(BOOL) becomeFirstResponder;
	-(BOOL) acceptsFirstResponder;
	-(void) setFrameSize:(CGSize)p0;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) accessibilityPerformPress;
@end

@implementation Xwt_Mac_CustomWidgetView {
}

	-(BOOL) becomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4BEA2);
	}

	-(BOOL) acceptsFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4BFA2);
	}

	-(void) setFrameSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x4C2A2);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_244 (self, _cmd, &managed_method, p0, 0x4C3A2);
	}

	-(BOOL) accessibilityPerformPress
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x4C4A2);
	}
@end

@interface Xwt_Mac_CustomScroller : NSScroller {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_CustomScroller {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_MacDatePicker : NSDatePicker {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) resetCursorRects;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_MacDatePicker {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) resetCursorRects
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x56FA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x570A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSDatePicker class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_MacSlider {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) resetCursorRects
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x587A2);
	}

	-(BOOL) allowsVibrancy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x58AA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x583A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSlider class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_MacSliderCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(double) maxValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_405 (self, _cmd, &managed_method, 0x58BA2);
	}

	-(void) setMaxValue:(double)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_406 (self, _cmd, &managed_method, p0, 0x58CA2);
	}

	-(double) minValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_405 (self, _cmd, &managed_method, 0x58DA2);
	}

	-(void) setMinValue:(double)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_406 (self, _cmd, &managed_method, p0, 0x58EA2);
	}

	-(BOOL) allowsTickMarkValuesOnly
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x591A2);
	}

	-(void) setAllowsTickMarkValuesOnly:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, 0x592A2);
	}

	-(double) tickMarkValueAtIndex:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_407 (self, _cmd, &managed_method, p0, 0x594A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x595A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSliderCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CheckBoxTableCell : NSButtonCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGSize) cellSizeForBounds:(CGRect)p0;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_CheckBoxTableCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGSize) cellSizeForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_395 (self, _cmd, &managed_method, p0, 0x59FA2);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x5A0A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x596A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButtonCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_MacWebView : WebView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_MacWebView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x5DDA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [WebView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_XwtWebUIDelegate : NSObject<WebUIDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_XwtWebUIDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x5DFA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation Xwt_Mac_SaveFileDialogBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x639A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSavePanel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_MacColorWell : NSColorWell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) activate:(BOOL)p0;
	-(NSColor *) color;
	-(void) setColor:(NSColor *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_MacColorWell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) activate:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, 0x651A2);
	}

	-(NSColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_408 (self, _cmd, &managed_method, 0x657A2);
	}

	-(void) setColor:(NSColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_409 (self, _cmd, &managed_method, p0, 0x658A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_MacCalendar : NSDatePicker {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_MacCalendar {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x683A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSDatePicker class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_FontPanelDelegate : NSObject<NSWindowDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSUInteger) validModesForFontPanel:(NSFontPanel *)p0;
	-(void) windowWillClose:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_FontPanelDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSUInteger) validModesForFontPanel:(NSFontPanel *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_410 (self, _cmd, &managed_method, p0, 0x68DA2);
	}

	-(void) windowWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x68EA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x68FA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_RadioButtonTableCell : NSButtonCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSInteger) state;
	-(void) setState:(NSInteger)p0;
	-(CGSize) cellSizeForBounds:(CGRect)p0;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_RadioButtonTableCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) state
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x692A2);
	}

	-(void) setState:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_411 (self, _cmd, &managed_method, p0, 0x693A2);
	}

	-(CGSize) cellSizeForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_395 (self, _cmd, &managed_method, p0, 0x69CA2);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x69DA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x691A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButtonCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_MacButton : NSButton {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) viewDidMoveToWindow;
	-(void) resetCursorRects;
	-(BOOL) allowsVibrancy;
	-(void) setButtonType:(NSUInteger)p0;
	-(NSAppearance *) effectiveAppearance;
	-(BOOL) accessibilityPerformPress;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_MacButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewDidMoveToWindow
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x1EA2);
	}

	-(void) resetCursorRects
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x20A2);
	}

	-(BOOL) allowsVibrancy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x23A2);
	}

	-(void) setButtonType:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_412 (self, _cmd, &managed_method, p0, 0x24A2);
	}

	-(NSAppearance *) effectiveAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_413 (self, _cmd, &managed_method, 0x25A2);
	}

	-(BOOL) accessibilityPerformPress
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x28A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x17A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_TreeViewBackend_TreeDelegate : NSObject<NSOutlineViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) outlineViewItemDidExpand:(NSNotification *)p0;
	-(void) outlineViewItemWillExpand:(NSNotification *)p0;
	-(void) outlineViewItemDidCollapse:(NSNotification *)p0;
	-(void) outlineViewItemWillCollapse:(NSNotification *)p0;
	-(CGFloat) outlineView:(NSOutlineView *)p0 heightOfRowByItem:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_TreeViewBackend_TreeDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) outlineViewItemDidExpand:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x713A2);
	}

	-(void) outlineViewItemWillExpand:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x714A2);
	}

	-(void) outlineViewItemDidCollapse:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x715A2);
	}

	-(void) outlineViewItemWillCollapse:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x716A2);
	}

	-(CGFloat) outlineView:(NSOutlineView *)p0 heightOfRowByItem:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_414 (self, _cmd, &managed_method, p0, p1, 0x717A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x718A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CompositeCell : NSCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(id) copyWithZone: (NSZone *)zone;
	-(NSObject *) objectValue;
	-(void) setObjectValue:(NSObject *)p0;
	-(BOOL) isOpaque;
	-(CGSize) cellSizeForBounds:(CGRect)p0;
	-(NSInteger) backgroundStyle;
	-(void) setBackgroundStyle:(NSInteger)p0;
	-(NSInteger) state;
	-(void) setState:(NSInteger)p0;
	-(BOOL) isHighlighted;
	-(void) setHighlighted:(BOOL)p0;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(void) highlight:(BOOL)p0 withFrame:(CGRect)p1 inView:(NSView *)p2;
	-(NSUInteger) hitTestForEvent:(NSEvent *)p0 inRect:(CGRect)p1 ofView:(NSView *)p2;
	-(BOOL) trackMouse:(NSEvent *)p0 inRect:(CGRect)p1 ofView:(NSView *)p2 untilMouseUp:(BOOL)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_CompositeCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}

	-(id) copyWithZone: (NSZone *) zone
	{
		return xamarin_copyWithZone_trampoline2 (self, _cmd, zone);
	}

	-(NSObject *) objectValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_21 (self, _cmd, &managed_method, 0x1A8A2);
	}

	-(void) setObjectValue:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_415 (self, _cmd, &managed_method, p0, 0x1A9A2);
	}

	-(BOOL) isOpaque
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x1AAA2);
	}

	-(CGSize) cellSizeForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_395 (self, _cmd, &managed_method, p0, 0x1AFA2);
	}

	-(NSInteger) backgroundStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x1B0A2);
	}

	-(void) setBackgroundStyle:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_411 (self, _cmd, &managed_method, p0, 0x1B1A2);
	}

	-(NSInteger) state
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x1B2A2);
	}

	-(void) setState:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_411 (self, _cmd, &managed_method, p0, 0x1B3A2);
	}

	-(BOOL) isHighlighted
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x1B4A2);
	}

	-(void) setHighlighted:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, 0x1B5A2);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x1B6A2);
	}

	-(void) highlight:(BOOL)p0 withFrame:(CGRect)p1 inView:(NSView *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_416 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7A2);
	}

	-(NSUInteger) hitTestForEvent:(NSEvent *)p0 inRect:(CGRect)p1 ofView:(NSView *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_417 (self, _cmd, &managed_method, p0, p1, p2, 0x1B8A2);
	}

	-(BOOL) trackMouse:(NSEvent *)p0 inRect:(CGRect)p1 ofView:(NSView *)p2 untilMouseUp:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_418 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B9A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation Xwt_Mac_CustomImage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawIt:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1EEA2);
	}

	-(NSObject *) copyWithZone:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_419 (self, _cmd, &managed_method, p0, 0x1F3A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_CanvasView : Xwt_Mac_WidgetView {
}
	-(void) drawRect:(CGRect)p0;
	-(NSObject *) accessibilityProxy;
	-(void) setAccessibilityProxy:(NSObject *)p0;
@end

@implementation Xwt_Mac_CanvasView {
}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x238A2);
	}

	-(NSObject *) accessibilityProxy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_21 (self, _cmd, &managed_method, 0x239A2);
	}

	-(void) setAccessibilityProxy:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x23AA2);
	}
@end

@interface Xwt_Mac_CustomTextField_CustomCell : NSTextFieldCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSTextView *) fieldEditorForView:(NSView *)p0;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(void) editWithFrame:(CGRect)p0 inView:(NSView *)p1 editor:(NSText *)p2 delegate:(NSObject *)p3 event:(NSEvent *)p4;
	-(void) selectWithFrame:(CGRect)p0 inView:(NSView *)p1 editor:(NSText *)p2 delegate:(NSObject *)p3 start:(NSInteger)p4 length:(NSInteger)p5;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_CustomTextField_CustomCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSTextView *) fieldEditorForView:(NSView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_420 (self, _cmd, &managed_method, p0, 0x757A2);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x759A2);
	}

	-(void) editWithFrame:(CGRect)p0 inView:(NSView *)p1 editor:(NSText *)p2 delegate:(NSObject *)p3 event:(NSEvent *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_28 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x75AA2);
	}

	-(void) selectWithFrame:(CGRect)p0 inView:(NSView *)p1 editor:(NSText *)p2 delegate:(NSObject *)p3 start:(NSInteger)p4 length:(NSInteger)p5
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, 0x75BA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x756A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTextFieldCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CustomTextField : NSTextField {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textDidChange:(NSNotification *)p0;
	-(NSString *) stringValue;
	-(void) setStringValue:(NSString *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_CustomTextField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x333A2);
	}

	-(NSString *) stringValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x334A2);
	}

	-(void) setStringValue:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_39 (self, _cmd, &managed_method, p0, 0x335A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_MacComboBox : NSComboBox<NSComboBoxDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) comboBoxSelectionDidChange:(NSNotification *)p0;
	-(void) textDidChange:(NSNotification *)p0;
	-(void) keyUp:(NSEvent *)p0;
	-(void) updateTrackingAreas;
	-(void) rightMouseDown:(NSEvent *)p0;
	-(void) rightMouseUp:(NSEvent *)p0;
	-(void) mouseDown:(NSEvent *)p0;
	-(void) mouseUp:(NSEvent *)p0;
	-(void) mouseEntered:(NSEvent *)p0;
	-(void) mouseExited:(NSEvent *)p0;
	-(void) mouseMoved:(NSEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_MacComboBox {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) comboBoxSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x35AA2);
	}

	-(void) textDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x35BA2);
	}

	-(void) keyUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x35CA2);
	}

	-(void) updateTrackingAreas
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x35DA2);
	}

	-(void) rightMouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x35EA2);
	}

	-(void) rightMouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x35FA2);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x360A2);
	}

	-(void) mouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x361A2);
	}

	-(void) mouseEntered:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x362A2);
	}

	-(void) mouseExited:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x363A2);
	}

	-(void) mouseMoved:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x364A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_PanedBackend_SplitViewDelegate : NSObject<NSSplitViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) splitViewDidResizeSubviews:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_PanedBackend_SplitViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) splitViewDidResizeSubviews:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x772A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x773A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_MacSpinButton_VibrancyStepper : NSStepper {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) allowsVibrancy;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_MacSpinButton_VibrancyStepper {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) allowsVibrancy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x779A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x77AA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSStepper class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_MacSpinButton {
}

	-(void) resizeSubviewsWithOldSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x419A2);
	}

	-(void) scrollWheel:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x41AA2);
	}
@end

@implementation Xwt_Mac_PopoverBackend_NSAppearanceCustomizationPopover {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x78BA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSPopover class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_SelectFolderDialogBackend {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x493A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xwt_Mac_FileDialogBackend class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_MacMenuButton : NSPopUpButton {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_MacMenuButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_CanvasTableCell : NSCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGSize) cellSizeForBounds:(CGRect)p0;
	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_CanvasTableCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGSize) cellSizeForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_395 (self, _cmd, &managed_method, p0, 0x4EBA2);
	}

	-(void) drawInteriorWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x4ECA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x4E3A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_MacTextView : NSTextView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) viewDidMoveToWindow;
	-(void) mouseUp:(NSEvent *)p0;
	-(void) resetCursorRects;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_MacTextView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewDidMoveToWindow
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x526A2);
	}

	-(void) mouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x527A2);
	}

	-(void) resetCursorRects
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x529A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_CustomSecureTextField : NSSecureTextField {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textDidChange:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_CustomSecureTextField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x5BAA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_NSTableViewBackend_ListDelegate : NSObject<NSTableViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_NSTableViewBackend_ListDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_279 (self, _cmd, &managed_method, p0, p1, 0x7BCA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x7BDA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xwt_Mac_NSTableViewBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) dataSource
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_21 (self, _cmd, &managed_method, 0x616A2);
	}

	-(void) setDataSource:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x617A2);
	}

	-(void) addTableColumn:(NSTableColumn *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_421 (self, _cmd, &managed_method, p0, 0x618A2);
	}

	-(void) reloadData
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x61CA2);
	}

	-(void) reloadDataForRowIndexes:(NSIndexSet *)p0 columnIndexes:(NSIndexSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_422 (self, _cmd, &managed_method, p0, p1, 0x61DA2);
	}

	-(void) updateTrackingAreas
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x623A2);
	}

	-(void) rightMouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x624A2);
	}

	-(void) rightMouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x625A2);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x626A2);
	}

	-(void) mouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x627A2);
	}

	-(void) mouseEntered:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x628A2);
	}

	-(void) mouseExited:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x629A2);
	}

	-(void) mouseMoved:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x62AA2);
	}

	-(void) mouseDragged:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x62BA2);
	}

	-(void) keyDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x62CA2);
	}

	-(void) keyUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x62DA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation Xwt_Mac_OutlineViewBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) dataSource
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_21 (self, _cmd, &managed_method, 0x65BA2);
	}

	-(void) setDataSource:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x65CA2);
	}

	-(void) addTableColumn:(NSTableColumn *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_421 (self, _cmd, &managed_method, p0, 0x65DA2);
	}

	-(void) expandItem:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x661A2);
	}

	-(void) expandItem:(NSObject *)p0 expandChildren:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_423 (self, _cmd, &managed_method, p0, p1, 0x662A2);
	}

	-(void) collapseItem:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x663A2);
	}

	-(void) collapseItem:(NSObject *)p0 collapseChildren:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_423 (self, _cmd, &managed_method, p0, p1, 0x664A2);
	}

	-(void) reloadData
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x665A2);
	}

	-(void) reloadDataForRowIndexes:(NSIndexSet *)p0 columnIndexes:(NSIndexSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_422 (self, _cmd, &managed_method, p0, p1, 0x666A2);
	}

	-(void) reloadItem:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x667A2);
	}

	-(void) reloadItem:(NSObject *)p0 reloadChildren:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_423 (self, _cmd, &managed_method, p0, p1, 0x668A2);
	}

	-(void) updateTrackingAreas
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x66AA2);
	}

	-(void) rightMouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x66BA2);
	}

	-(void) rightMouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x66CA2);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x66DA2);
	}

	-(void) mouseUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x66EA2);
	}

	-(void) mouseEntered:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x66FA2);
	}

	-(void) mouseExited:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x670A2);
	}

	-(void) mouseMoved:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x671A2);
	}

	-(void) mouseDragged:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x672A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@implementation Xwt_Mac_PopupWindowBackend {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) canBecomeKeyWindow
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x6BFA2);
	}

	-(void) mouseExited:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x6C7A2);
	}

	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x6E3A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x6BEA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSPanel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_MacButton_ColoredButtonCell : NSButtonCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawBezelWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_MacButton_ColoredButtonCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawBezelWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x709A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x70AA2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButtonCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_CustomTextField_CustomEditor : NSTextView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) keyDown:(NSEvent *)p0;
	-(void) keyUp:(NSEvent *)p0;
	-(BOOL) becomeFirstResponder;
	-(BOOL) resignFirstResponder;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xwt_Mac_CustomTextField_CustomEditor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) keyDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x762A2);
	}

	-(void) keyUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x763A2);
	}

	-(BOOL) becomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x764A2);
	}

	-(BOOL) resignFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x765A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x761A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTextView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xwt_Mac_PopoverBackend_FactoryViewController_ContainerView : NSView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) allowsVibrancy;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_PopoverBackend_FactoryViewController_ContainerView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) allowsVibrancy
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x7ECA2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_PopoverBackend_FactoryViewController : NSViewController<NSPopoverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) loadView;
	-(void) popoverWillShow:(NSNotification *)p0;
	-(void) popoverDidClose:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xwt_Mac_PopoverBackend_FactoryViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) loadView
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x785A2);
	}

	-(void) popoverWillShow:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x786A2);
	}

	-(void) popoverDidClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x787A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
@end

@interface Xwt_Mac_MacMenuButton_ColoredPopUpButtonCell : NSPopUpButtonCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawBezelWithFrame:(CGRect)p0 inView:(NSView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xwt_Mac_MacMenuButton_ColoredPopUpButtonCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawBezelWithFrame:(CGRect)p0 inView:(NSView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, 0x794A2);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x12D09C);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, &call_super, 0x795A2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSPopUpButtonCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

	static MTClassMap __xamarin_class_map [] = {
		{ NULL, 0x1B39C /* 'NSObject' => 'Foundation.NSObject, Xamarin.Mac' */ },
		{ NULL, 0x10959C /* 'NSResponder' => 'AppKit.NSResponder, Xamarin.Mac' */ },
		{ NULL, 0x12909C /* 'NSWindow' => 'AppKit.NSWindow, Xamarin.Mac' */ },
		{ NULL, 0x3979C /* 'NSAlert' => 'AppKit.NSAlert, Xamarin.Mac' */ },
		{ NULL, 0x128F9C /* 'NSView' => 'AppKit.NSView, Xamarin.Mac' */ },
		{ NULL, 0x6C59C /* 'NSControl' => 'AppKit.NSControl, Xamarin.Mac' */ },
		{ NULL, 0x127F9C /* 'NSTextField' => 'AppKit.NSTextField, Xamarin.Mac' */ },
		{ NULL, 0x5A09C /* 'NSButton' => 'AppKit.NSButton, Xamarin.Mac' */ },
		{ NULL, 0x5319C /* 'NSCell' => 'AppKit.NSCell, Xamarin.Mac' */ },
		{ NULL, 0x36A9C /* 'NSActionCell' => 'AppKit.NSActionCell, Xamarin.Mac' */ },
		{ NULL, 0x4359C /* 'NSButtonCell' => 'AppKit.NSButtonCell, Xamarin.Mac' */ },
		{ NULL, 0x13B09C /* 'NSTextFieldCell' => 'AppKit.NSTextFieldCell, Xamarin.Mac' */ },
		{ NULL, 0xF2B9C /* 'NSPanel' => 'AppKit.NSPanel, Xamarin.Mac' */ },
		{ NULL, 0x10AA9C /* 'NSPopUpButton' => 'AppKit.NSPopUpButton, Xamarin.Mac' */ },
		{ NULL, 0x111F9C /* 'NSSearchFieldCell' => 'AppKit.NSSearchFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x11149C /* 'NSSearchField' => 'AppKit.NSSearchField, Xamarin.Mac' */ },
		{ NULL, 0x11559C /* 'NSSegmentedCell' => 'AppKit.NSSegmentedCell, Xamarin.Mac' */ },
		{ NULL, 0x117B9C /* 'NSSegmentedControl' => 'AppKit.NSSegmentedControl, Xamarin.Mac' */ },
		{ NULL, 0xFB89C /* 'NSPathComponentCell' => 'AppKit.NSPathComponentCell, Xamarin.Mac' */ },
		{ NULL, 0xFCE9C /* 'NSPathControl' => 'AppKit.NSPathControl, Xamarin.Mac' */ },
		{ NULL, 0x1B49C /* 'NSAccessibilityElement' => 'AppKit.NSAccessibilityElement, Xamarin.Mac' */ },
		{ NULL, 0xF7C9C /* 'NSMenuItem' => 'AppKit.NSMenuItem, Xamarin.Mac' */ },
		{ NULL, 0xECF9C /* 'NSMenu' => 'AppKit.NSMenu, Xamarin.Mac' */ },
		{ NULL, 0x149C /* 'CKRecordZoneID' => 'CloudKit.CKRecordZoneID, Xamarin.Mac' */ },
		{ NULL, 0x1359C /* 'MPRemoteCommand' => 'MediaPlayer.MPRemoteCommand, Xamarin.Mac' */ },
		{ NULL, 0x159C /* 'MPChangePlaybackRateCommand' => 'MediaPlayer.MPChangePlaybackRateCommand, Xamarin.Mac' */ },
		{ NULL, 0x709C /* 'VNObservation' => 'Vision.VNObservation, Xamarin.Mac' */ },
		{ NULL, 0x1CCA9C /* 'VNImageAlignmentObservation' => 'Vision.VNImageAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x179C /* 'VNImageHomographicAlignmentObservation' => 'Vision.VNImageHomographicAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x1C9C /* 'CKUserIdentityLookupInfo' => 'CloudKit.CKUserIdentityLookupInfo, Xamarin.Mac' */ },
		{ NULL, 0x1459C /* 'MPRemoteCommandEvent' => 'MediaPlayer.MPRemoteCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x1D9C /* 'MPChangePlaybackRateCommandEvent' => 'MediaPlayer.MPChangePlaybackRateCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x209C /* 'AVAudioSequencer' => 'AVFoundation.AVAudioSequencer, Xamarin.Mac' */ },
		{ NULL, 0x229C /* 'MPChangeRepeatModeCommand' => 'MediaPlayer.MPChangeRepeatModeCommand, Xamarin.Mac' */ },
		{ NULL, 0x289C /* 'ACAccount' => 'Accounts.ACAccount, Xamarin.Mac' */ },
		{ NULL, 0xF719C /* 'NSIndexSet' => 'Foundation.NSIndexSet, Xamarin.Mac' */ },
		{ NULL, 0x2A9C /* 'NSMutableIndexSet' => 'Foundation.NSMutableIndexSet, Xamarin.Mac' */ },
		{ NULL, 0x2B9C /* 'MPChangeRepeatModeCommandEvent' => 'MediaPlayer.MPChangeRepeatModeCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x2D9C /* 'ACAccountCredential' => 'Accounts.ACAccountCredential, Xamarin.Mac' */ },
		{ NULL, 0x2E9C /* 'MPChangeShuffleModeCommand' => 'MediaPlayer.MPChangeShuffleModeCommand, Xamarin.Mac' */ },
		{ NULL, 0x319C /* 'MPChangeShuffleModeCommandEvent' => 'MediaPlayer.MPChangeShuffleModeCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x2039C /* 'NSOrderedSet' => 'Foundation.NSOrderedSet, Xamarin.Mac' */ },
		{ NULL, 0x389C /* 'NSMutableOrderedSet' => 'Foundation.NSMutableOrderedSet, Xamarin.Mac' */ },
		{ NULL, 0x3B9C /* 'MPContentItem' => 'MediaPlayer.MPContentItem, Xamarin.Mac' */ },
		{ NULL, 0x889C /* 'VNRequest' => 'Vision.VNRequest, Xamarin.Mac' */ },
		{ NULL, 0x1CD89C /* 'VNImageBasedRequest' => 'Vision.VNImageBasedRequest, Xamarin.Mac' */ },
		{ NULL, 0x1149C /* 'VNTargetedImageRequest' => 'Vision.VNTargetedImageRequest, Xamarin.Mac' */ },
		{ NULL, 0x3F9C /* 'VNImageRegistrationRequest' => 'Vision.VNImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x429C /* 'CNContactFetchRequest' => 'Contacts.CNContactFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0x3F29C /* 'NSSet' => 'Foundation.NSSet, Xamarin.Mac' */ },
		{ NULL, 0x489C /* 'NSMutableSet' => 'Foundation.NSMutableSet, Xamarin.Mac' */ },
		{ NULL, 0x4A9C /* 'MPFeedbackCommand' => 'MediaPlayer.MPFeedbackCommand, Xamarin.Mac' */ },
		{ NULL, 0x4B9C /* 'ACAccountType' => 'Accounts.ACAccountType, Xamarin.Mac' */ },
		{ NULL, 0x539C /* 'VNImageRequestHandler' => 'Vision.VNImageRequestHandler, Xamarin.Mac' */ },
		{ NULL, 0x569C /* 'CNInstantMessageAddress' => 'Contacts.CNInstantMessageAddress, Xamarin.Mac' */ },
		{ NULL, 0x579C /* 'MPFeedbackCommandEvent' => 'MediaPlayer.MPFeedbackCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x5F9C /* 'NSPersistentStoreDescription' => 'CoreData.NSPersistentStoreDescription, Xamarin.Mac' */ },
		{ NULL, 0x619C /* 'VNImageTranslationAlignmentObservation' => 'Vision.VNImageTranslationAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x4519C /* 'NSString' => 'Foundation.NSString, Xamarin.Mac' */ },
		{ NULL, 0x629C /* 'NSMutableString' => 'Foundation.NSMutableString, Xamarin.Mac' */ },
		{ NULL, 0x6D9C /* 'CNSocialProfile' => 'Contacts.CNSocialProfile, Xamarin.Mac' */ },
		{ NULL, 0x6E9C /* 'NSPersistentStoreRequest' => 'CoreData.NSPersistentStoreRequest, Xamarin.Mac' */ },
		{ NULL, 0x7F9C /* 'CAAnimation' => 'CoreAnimation.CAAnimation, Xamarin.Mac' */ },
		{ NULL, 0x13419C /* 'CAPropertyAnimation' => 'CoreAnimation.CAPropertyAnimation, Xamarin.Mac' */ },
		{ NULL, 0x759C /* 'CABasicAnimation' => 'CoreAnimation.CABasicAnimation, Xamarin.Mac' */ },
		{ NULL, 0x869C /* 'CALayer' => 'CoreAnimation.CALayer, Xamarin.Mac' */ },
		{ NULL, 0x7A9C /* 'CAScrollLayer' => 'CoreAnimation.CAScrollLayer, Xamarin.Mac' */ },
		{ NULL, 0x7B9C /* 'VNPixelBufferObservation' => 'Vision.VNPixelBufferObservation, Xamarin.Mac' */ },
		{ NULL, 0x7C9C /* 'NSPersistentStoreResult' => 'CoreData.NSPersistentStoreResult, Xamarin.Mac' */ },
		{ NULL, 0x6E49C /* 'NSURLRequest' => 'Foundation.NSUrlRequest, Xamarin.Mac' */ },
		{ NULL, 0x7E9C /* 'NSMutableURLRequest' => 'Foundation.NSMutableUrlRequest, Xamarin.Mac' */ },
		{ NULL, 0x809C /* 'CAGradientLayer' => 'CoreAnimation.CAGradientLayer, Xamarin.Mac' */ },
		{ NULL, 0x819C /* 'CAKeyframeAnimation' => 'CoreAnimation.CAKeyFrameAnimation, Xamarin.Mac' */ },
		{ NULL, 0x1AFC9C /* 'VNDetectedObjectObservation' => 'Vision.VNDetectedObjectObservation, Xamarin.Mac' */ },
		{ NULL, 0x839C /* 'VNRectangleObservation' => 'Vision.VNRectangleObservation, Xamarin.Mac' */ },
		{ NULL, 0x859C /* 'MPMediaItem' => 'MediaPlayer.MPMediaItem, Xamarin.Mac' */ },
		{ NULL, 0x879C /* 'NSAccessibilityCustomRotor' => 'AppKit.NSAccessibilityCustomRotor, Xamarin.Mac' */ },
		{ NULL, 0xAD9C /* 'MPMediaItemArtwork' => 'MediaPlayer.MPMediaItemArtwork, Xamarin.Mac' */ },
		{ NULL, 0xB09C /* 'NSPropertyDescription' => 'CoreData.NSPropertyDescription, Xamarin.Mac' */ },
		{ NULL, 0xB19C /* 'NSAccessibilityCustomRotorItemResult' => 'AppKit.NSAccessibilityCustomRotorItemResult, Xamarin.Mac' */ },
		{ NULL, 0xB39C /* 'CAMediaTimingFunction' => 'CoreAnimation.CAMediaTimingFunction, Xamarin.Mac' */ },
		{ NULL, 0xF49C /* 'AVAudioTime' => 'AVFoundation.AVAudioTime, Xamarin.Mac' */ },
		{ NULL, 0xF89C /* 'NSPropertyMapping' => 'CoreData.NSPropertyMapping, Xamarin.Mac' */ },
		{ NULL, 0xF99C /* 'VNSequenceRequestHandler' => 'Vision.VNSequenceRequestHandler, Xamarin.Mac' */ },
		{ NULL, 0xFB9C /* 'CATextLayer' => 'CoreAnimation.CATextLayer, Xamarin.Mac' */ },
		{ NULL, 0xFC9C /* 'NSAccessibilityCustomRotorSearchParameters' => 'AppKit.NSAccessibilityCustomRotorSearchParameters, Xamarin.Mac' */ },
		{ NULL, 0xFD9C /* 'NSQueryGenerationToken' => 'CoreData.NSQueryGenerationToken, Xamarin.Mac' */ },
		{ NULL, 0xFE9C /* 'NSAttributeDescription' => 'CoreData.NSAttributeDescription, Xamarin.Mac' */ },
		{ NULL, 0xFF9C /* 'MPNowPlayingInfoCenter' => 'MediaPlayer.MPNowPlayingInfoCenter, Xamarin.Mac' */ },
		{ NULL, 0x1059C /* 'NSEntityDescription' => 'CoreData.NSEntityDescription, Xamarin.Mac' */ },
		{ NULL, 0x1069C /* 'NSRelationshipDescription' => 'CoreData.NSRelationshipDescription, Xamarin.Mac' */ },
		{ NULL, 0x1079C /* 'NSMergeConflict' => 'CoreData.NSMergeConflict, Xamarin.Mac' */ },
		{ NULL, 0x1089C /* 'NSMergePolicy' => 'CoreData.NSMergePolicy, Xamarin.Mac' */ },
		{ NULL, 0x1099C /* 'NSPersistentStore' => 'CoreData.NSPersistentStore, Xamarin.Mac' */ },
		{ NULL, 0x10A9C /* 'MPNowPlayingInfoLanguageOption' => 'MediaPlayer.MPNowPlayingInfoLanguageOption, Xamarin.Mac' */ },
		{ NULL, 0x10F9C /* 'NSSaveChangesRequest' => 'CoreData.NSSaveChangesRequest, Xamarin.Mac' */ },
		{ NULL, 0x1109C /* 'MPNowPlayingInfoLanguageOptionGroup' => 'MediaPlayer.MPNowPlayingInfoLanguageOptionGroup, Xamarin.Mac' */ },
		{ NULL, 0x1179C /* 'AVAudioUnitComponentManager' => 'AVFoundation.AVAudioUnitComponentManager, Xamarin.Mac' */ },
		{ NULL, 0x1199C /* 'VNTextObservation' => 'Vision.VNTextObservation, Xamarin.Mac' */ },
		{ NULL, 0x1CAD9C /* 'AVAudioNode' => 'AVFoundation.AVAudioNode, Xamarin.Mac' */ },
		{ NULL, 0x1049C /* 'AVAudioUnit' => 'AVFoundation.AVAudioUnit, Xamarin.Mac' */ },
		{ NULL, 0x1379C /* 'AVAudioUnitEffect' => 'AVFoundation.AVAudioUnitEffect, Xamarin.Mac' */ },
		{ NULL, 0x1249C /* 'AVAudioUnitDelay' => 'AVFoundation.AVAudioUnitDelay, Xamarin.Mac' */ },
		{ NULL, 0x1259C /* 'VNTrackingRequest' => 'Vision.VNTrackingRequest, Xamarin.Mac' */ },
		{ NULL, 0x1279C /* 'NSNotification' => 'Foundation.NSNotification, Xamarin.Mac' */ },
		{ NULL, 0x1289C /* 'MPRatingCommand' => 'MediaPlayer.MPRatingCommand, Xamarin.Mac' */ },
		{ NULL, 0x1299C /* 'AVAudioUnitDistortion' => 'AVFoundation.AVAudioUnitDistortion, Xamarin.Mac' */ },
		{ NULL, 0x12D9C /* 'VNTrackObjectRequest' => 'Vision.VNTrackObjectRequest, Xamarin.Mac' */ },
		{ NULL, 0x12F9C /* 'MPRatingCommandEvent' => 'MediaPlayer.MPRatingCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x1349C /* 'VNTrackRectangleRequest' => 'Vision.VNTrackRectangleRequest, Xamarin.Mac' */ },
		{ NULL, 0x1399C /* 'NSNotificationQueue' => 'Foundation.NSNotificationQueue, Xamarin.Mac' */ },
		{ NULL, 0x13B9C /* 'AVAudioUnitEQ' => 'AVFoundation.AVAudioUnitEQ, Xamarin.Mac' */ },
		{ NULL, 0x13D9C /* 'NSNull' => 'Foundation.NSNull, Xamarin.Mac' */ },
		{ NULL, 0x13F9C /* 'MPRemoteCommandCenter' => 'MediaPlayer.MPRemoteCommandCenter, Xamarin.Mac' */ },
		{ NULL, 0x1409C /* 'AVAudioUnitEQFilterParameters' => 'AVFoundation.AVAudioUnitEQFilterParameters, Xamarin.Mac' */ },
		{ NULL, 0x1469C /* 'VNTranslationalImageRegistrationRequest' => 'Vision.VNTranslationalImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x6619C /* 'WebScriptObject' => 'WebKit.WebScriptObject, Xamarin.Mac' */ },
		{ NULL, 0x52E9C /* 'DOMObject' => 'WebKit.DomObject, Xamarin.Mac' */ },
		{ NULL, 0x14A9C /* 'DOMAbstractView' => 'WebKit.DomAbstractView, Xamarin.Mac' */ },
		{ NULL, 0xC849C /* 'NSValue' => 'Foundation.NSValue, Xamarin.Mac' */ },
		{ NULL, 0x14C9C /* 'NSNumber' => 'Foundation.NSNumber, Xamarin.Mac' */ },
		{ NULL, 0x5169C /* 'DOMNode' => 'WebKit.DomNode, Xamarin.Mac' */ },
		{ NULL, 0x15A9C /* 'DOMAttr' => 'WebKit.DomAttr, Xamarin.Mac' */ },
		{ NULL, 0x15B9C /* 'AVAudioUnitGenerator' => 'AVFoundation.AVAudioUnitGenerator, Xamarin.Mac' */ },
		{ NULL, 0x15C9C /* 'MPSeekCommandEvent' => 'MediaPlayer.MPSeekCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x15F9C /* 'DOMBlob' => 'WebKit.DomBlob, Xamarin.Mac' */ },
		{ NULL, 0x1699C /* 'DOMCharacterData' => 'WebKit.DomCharacterData, Xamarin.Mac' */ },
		{ NULL, 0x5689C /* 'DOMText' => 'WebKit.DomText, Xamarin.Mac' */ },
		{ NULL, 0x1629C /* 'DOMCDATASection' => 'WebKit.DomCDataSection, Xamarin.Mac' */ },
		{ NULL, 0x1649C /* 'MPSkipIntervalCommand' => 'MediaPlayer.MPSkipIntervalCommand, Xamarin.Mac' */ },
		{ NULL, 0x16B9C /* 'MPSkipIntervalCommandEvent' => 'MediaPlayer.MPSkipIntervalCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x16C9C /* 'DOMComment' => 'WebKit.DomComment, Xamarin.Mac' */ },
		{ NULL, 0x1749C /* 'AVAudioUnitMIDIInstrument' => 'AVFoundation.AVAudioUnitMidiInstrument, Xamarin.Mac' */ },
		{ NULL, 0x1889C /* 'DOMCSSRule' => 'WebKit.DomCssRule, Xamarin.Mac' */ },
		{ NULL, 0x1759C /* 'DOMCSSCharsetRule' => 'WebKit.DomCssCharsetRule, Xamarin.Mac' */ },
		{ NULL, 0x1769C /* 'AVAudioUnitReverb' => 'AVFoundation.AVAudioUnitReverb, Xamarin.Mac' */ },
		{ NULL, 0x1789C /* 'DOMCSSFontFaceRule' => 'WebKit.DomCssFontFaceRule, Xamarin.Mac' */ },
		{ NULL, 0x1E29C /* 'CIFilter' => 'CoreImage.CIFilter, Xamarin.Mac' */ },
		{ NULL, 0x17A9C /* 'CoreImage_CIAccordionFoldTransition' => 'CoreImage.CIAccordionFoldTransition, Xamarin.Mac' */ },
		{ NULL, 0x17B9C /* 'MTLArgument' => 'Metal.MTLArgument, Xamarin.Mac' */ },
		{ NULL, 0x17D9C /* 'DOMCSSMediaRule' => 'WebKit.DomCssMediaRule, Xamarin.Mac' */ },
		{ NULL, 0x34D9C /* 'CoreImage_CICompositingFilter' => 'CoreImage.CICompositingFilter, Xamarin.Mac' */ },
		{ NULL, 0x17E9C /* 'CoreImage_CIAdditionCompositing' => 'CoreImage.CIAdditionCompositing, Xamarin.Mac' */ },
		{ NULL, 0x1809C /* 'AVAudioUnitSampler' => 'AVFoundation.AVAudioUnitSampler, Xamarin.Mac' */ },
		{ NULL, 0x1839C /* 'DOMCSSPageRule' => 'WebKit.DomCssPageRule, Xamarin.Mac' */ },
		{ NULL, 0x1869C /* 'CoreImage_CIAffineFilter' => 'CoreImage.CIAffineFilter, Xamarin.Mac' */ },
		{ NULL, 0x1849C /* 'CoreImage_CIAffineClamp' => 'CoreImage.CIAffineClamp, Xamarin.Mac' */ },
		{ NULL, 0x1879C /* 'AVAudioUnitTimeEffect' => 'AVFoundation.AVAudioUnitTimeEffect, Xamarin.Mac' */ },
		{ NULL, 0xF5F9C /* 'NSFormatter' => 'Foundation.NSFormatter, Xamarin.Mac' */ },
		{ NULL, 0x18B9C /* 'NSNumberFormatter' => 'Foundation.NSNumberFormatter, Xamarin.Mac' */ },
		{ NULL, 0x18C9C /* 'CoreImage_CIAffineTile' => 'CoreImage.CIAffineTile, Xamarin.Mac' */ },
		{ NULL, 0x18D9C /* 'MTLArgumentDescriptor' => 'Metal.MTLArgumentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x18E9C /* 'DOMCSSRuleList' => 'WebKit.DomCssRuleList, Xamarin.Mac' */ },
		{ NULL, 0x1919C /* 'AVAudioUnitTimePitch' => 'AVFoundation.AVAudioUnitTimePitch, Xamarin.Mac' */ },
		{ NULL, 0x1959C /* 'CoreImage_CIAffineTransform' => 'CoreImage.CIAffineTransform, Xamarin.Mac' */ },
		{ NULL, 0x1989C /* 'CoreImage_CIAreaAverage' => 'CoreImage.CIAreaAverage, Xamarin.Mac' */ },
		{ NULL, 0x19A9C /* 'DOMCSSStyleDeclaration' => 'WebKit.DomCssStyleDeclaration, Xamarin.Mac' */ },
		{ NULL, 0x19C9C /* 'CoreImage_CIAreaHistogram' => 'CoreImage.CIAreaHistogram, Xamarin.Mac' */ },
		{ NULL, 0x19D9C /* 'AVAudioUnitVarispeed' => 'AVFoundation.AVAudioUnitVarispeed, Xamarin.Mac' */ },
		{ NULL, 0x19F9C /* 'DOMCSSStyleRule' => 'WebKit.DomCssStyleRule, Xamarin.Mac' */ },
		{ NULL, 0x1A59C /* 'CoreImage_CIAreaMaximum' => 'CoreImage.CIAreaMaximum, Xamarin.Mac' */ },
		{ NULL, 0x55A9C /* 'DOMStyleSheet' => 'WebKit.DomStyleSheet, Xamarin.Mac' */ },
		{ NULL, 0x1A89C /* 'DOMCSSStyleSheet' => 'WebKit.DomCssStyleSheet, Xamarin.Mac' */ },
		{ NULL, 0x1A99C /* 'CoreImage_CIAreaMaximumAlpha' => 'CoreImage.CIAreaMaximumAlpha, Xamarin.Mac' */ },
		{ NULL, 0x1AA9C /* 'AVCameraCalibrationData' => 'AVFoundation.AVCameraCalibrationData, Xamarin.Mac' */ },
		{ NULL, 0x1AB9C /* 'DOMCSSUnknownRule' => 'WebKit.DomCssUnknownRule, Xamarin.Mac' */ },
		{ NULL, 0x1AD9C /* 'CoreImage_CIAreaMinimum' => 'CoreImage.CIAreaMinimum, Xamarin.Mac' */ },
		{ NULL, 0x5CA9C /* 'MTLType' => 'Metal.MTLType, Xamarin.Mac' */ },
		{ NULL, 0x1AE9C /* 'MTLArrayType' => 'Metal.MTLArrayType, Xamarin.Mac' */ },
		{ NULL, 0x1AF9C /* 'CIColor' => 'CoreImage.CIColor, Xamarin.Mac' */ },
		{ NULL, 0x1B09C /* 'CoreImage_CIAreaMinimumAlpha' => 'CoreImage.CIAreaMinimumAlpha, Xamarin.Mac' */ },
		{ NULL, 0x1B19C /* 'DOMCSSValue' => 'WebKit.DomCssValue, Xamarin.Mac' */ },
		{ NULL, 0x1B29C /* 'AVCaptureAudioChannel' => 'AVFoundation.AVCaptureAudioChannel, Xamarin.Mac' */ },
		{ NULL, 0x1B69C /* 'CoreImage_CIAreaMinMaxRed' => 'CoreImage.CIAreaMinMaxRed, Xamarin.Mac' */ },
		{ NULL, 0x1B89C /* 'CIContext' => 'CoreImage.CIContext, Xamarin.Mac' */ },
		{ NULL, 0x1B99C /* 'MTLAttribute' => 'Metal.MTLAttribute, Xamarin.Mac' */ },
		{ NULL, 0x32E9C /* 'AVCaptureOutput' => 'AVFoundation.AVCaptureOutput, Xamarin.Mac' */ },
		{ NULL, 0x1BA9C /* 'AVCaptureAudioDataOutput' => 'AVFoundation.AVCaptureAudioDataOutput, Xamarin.Mac' */ },
		{ NULL, 0x5789C /* 'CoreImage_CIImageGenerator' => 'CoreImage.CIImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0x1BE9C /* 'CoreImage_CIAttributedTextImageGenerator' => 'CoreImage.CIAttributedTextImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0x1C09C /* 'CIDetector' => 'CoreImage.CIDetector, Xamarin.Mac' */ },
		{ NULL, 0x1C19C /* 'MTLAttributeDescriptor' => 'Metal.MTLAttributeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x1C99C /* 'MTLAttributeDescriptorArray' => 'Metal.MTLAttributeDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x1D59C /* 'CIBarcodeDescriptor' => 'CoreImage.CIBarcodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x1CA9C /* 'CIAztecCodeDescriptor' => 'CoreImage.CIAztecCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x2859C /* 'CoreImage_CICodeGenerator' => 'CoreImage.CICodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0x1D09C /* 'CoreImage_CIAztecCodeGenerator' => 'CoreImage.CIAztecCodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0x2989C /* 'AVCaptureFileOutput' => 'AVFoundation.AVCaptureFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x1D19C /* 'AVCaptureAudioFileOutput' => 'AVFoundation.AVCaptureAudioFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x1D89C /* 'AVCaptureAudioPreviewOutput' => 'AVFoundation.AVCaptureAudioPreviewOutput, Xamarin.Mac' */ },
		{ NULL, 0x1DC9C /* 'NSOperation' => 'Foundation.NSOperation, Xamarin.Mac' */ },
		{ NULL, 0x1DD9C /* 'CoreImage_CIBarcodeGenerator' => 'CoreImage.CIBarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0x1E19C /* 'DOMDocument' => 'WebKit.DomDocument, Xamarin.Mac' */ },
		{ NULL, 0x27B9C /* 'CoreImage_CICmykHalftone' => 'CoreImage.CICmykHalftone, Xamarin.Mac' */ },
		{ NULL, 0x1E39C /* 'CoreImage_CICMYKHalftone' => 'CoreImage.CICMYKHalftone, Xamarin.Mac' */ },
		{ NULL, 0x7F09C /* 'CoreImage_CITransitionFilter' => 'CoreImage.CITransitionFilter, Xamarin.Mac' */ },
		{ NULL, 0x1E49C /* 'CoreImage_CIBarsSwipeTransition' => 'CoreImage.CIBarsSwipeTransition, Xamarin.Mac' */ },
		{ NULL, 0x1E69C /* 'DOMDocumentFragment' => 'WebKit.DomDocumentFragment, Xamarin.Mac' */ },
		{ NULL, 0x1EB9C /* 'CoreImage_CIBicubicScaleTransform' => 'CoreImage.CIBicubicScaleTransform, Xamarin.Mac' */ },
		{ NULL, 0x1ED9C /* 'CIImage' => 'CoreImage.CIImage, Xamarin.Mac' */ },
		{ NULL, 0x1EE9C /* 'NSOperationQueue' => 'Foundation.NSOperationQueue, Xamarin.Mac' */ },
		{ NULL, 0x1F29C /* 'DOMDocumentType' => 'WebKit.DomDocumentType, Xamarin.Mac' */ },
		{ NULL, 0x1F39C /* 'CoreImage_CIBlendFilter' => 'CoreImage.CIBlendFilter, Xamarin.Mac' */ },
		{ NULL, 0x1F79C /* 'CISampler' => 'CoreImage.CISampler, Xamarin.Mac' */ },
		{ NULL, 0x1FB9C /* 'NSAccessibilityCustomAction' => 'AppKit.NSAccessibilityCustomAction, Xamarin.Mac' */ },
		{ NULL, 0x1FC9C /* 'CIVector' => 'CoreImage.CIVector, Xamarin.Mac' */ },
		{ NULL, 0x1FE9C /* 'AVCaptureConnection' => 'AVFoundation.AVCaptureConnection, Xamarin.Mac' */ },
		{ NULL, 0x2019C /* 'CLHeading' => 'CoreLocation.CLHeading, Xamarin.Mac' */ },
		{ NULL, 0x2029C /* 'CLLocation' => 'CoreLocation.CLLocation, Xamarin.Mac' */ },
		{ NULL, 0x2059C /* 'AVCaptureDataOutputSynchronizer' => 'AVFoundation.AVCaptureDataOutputSynchronizer, Xamarin.Mac' */ },
		{ NULL, 0x5C39C /* 'CIKernel' => 'CoreImage.CIKernel, Xamarin.Mac' */ },
		{ NULL, 0x32A9C /* 'CIColorKernel' => 'CoreImage.CIColorKernel, Xamarin.Mac' */ },
		{ NULL, 0x2069C /* 'CIBlendKernel' => 'CoreImage.CIBlendKernel, Xamarin.Mac' */ },
		{ NULL, 0x2189C /* 'CoreImage_CIBlendWithMask' => 'CoreImage.CIBlendWithMask, Xamarin.Mac' */ },
		{ NULL, 0x2079C /* 'CoreImage_CIBlendWithAlphaMask' => 'CoreImage.CIBlendWithAlphaMask, Xamarin.Mac' */ },
		{ NULL, 0x2089C /* 'NSOrthography' => 'Foundation.NSOrthography, Xamarin.Mac' */ },
		{ NULL, 0x2129C /* 'CoreImage_CIBlendWithBlueMask' => 'CoreImage.CIBlendWithBlueMask, Xamarin.Mac' */ },
		{ NULL, 0x41A9C /* 'NSStream' => 'Foundation.NSStream, Xamarin.Mac' */ },
		{ NULL, 0x2139C /* 'NSOutputStream' => 'Foundation.NSOutputStream, Xamarin.Mac' */ },
		{ NULL, 0x2149C /* 'DOMElement' => 'WebKit.DomElement, Xamarin.Mac' */ },
		{ NULL, 0x2159C /* 'MTLBufferLayoutDescriptor' => 'Metal.MTLBufferLayoutDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x2199C /* 'DOMEntityReference' => 'WebKit.DomEntityReference, Xamarin.Mac' */ },
		{ NULL, 0x21B9C /* 'MTLBufferLayoutDescriptorArray' => 'Metal.MTLBufferLayoutDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x21C9C /* 'CoreImage_CIBlendWithRedMask' => 'CoreImage.CIBlendWithRedMask, Xamarin.Mac' */ },
		{ NULL, 0x21E9C /* 'CoreImage_CIBloom' => 'CoreImage.CIBloom, Xamarin.Mac' */ },
		{ NULL, 0x21F9C /* 'DOMEvent' => 'WebKit.DomEvent, Xamarin.Mac' */ },
		{ NULL, 0x5E09C /* 'CoreImage_CILinearBlur' => 'CoreImage.CILinearBlur, Xamarin.Mac' */ },
		{ NULL, 0x2209C /* 'CoreImage_CIBokehBlur' => 'CoreImage.CIBokehBlur, Xamarin.Mac' */ },
		{ NULL, 0x2249C /* 'MTLCaptureManager' => 'Metal.MTLCaptureManager, Xamarin.Mac' */ },
		{ NULL, 0x2259C /* 'NSPersonNameComponents' => 'Foundation.NSPersonNameComponents, Xamarin.Mac' */ },
		{ NULL, 0x2299C /* 'CoreImage_CIBoxBlur' => 'CoreImage.CIBoxBlur, Xamarin.Mac' */ },
		{ NULL, 0x42E9C /* 'CoreImage_CIDistortionFilter' => 'CoreImage.CIDistortionFilter, Xamarin.Mac' */ },
		{ NULL, 0x2319C /* 'CoreImage_CIBumpDistortion' => 'CoreImage.CIBumpDistortion, Xamarin.Mac' */ },
		{ NULL, 0x2359C /* 'NSPersonNameComponentsFormatter' => 'Foundation.NSPersonNameComponentsFormatter, Xamarin.Mac' */ },
		{ NULL, 0x2399C /* 'CoreImage_CIBumpDistortionLinear' => 'CoreImage.CIBumpDistortionLinear, Xamarin.Mac' */ },
		{ NULL, 0x23F9C /* 'NSPipe' => 'Foundation.NSPipe, Xamarin.Mac' */ },
		{ NULL, 0x2419C /* 'DOMFile' => 'WebKit.DomFile, Xamarin.Mac' */ },
		{ NULL, 0x2429C /* 'CoreImage_CICheckerboardGenerator' => 'CoreImage.CICheckerboardGenerator, Xamarin.Mac' */ },
		{ NULL, 0x24F9C /* 'DOMFileList' => 'WebKit.DomFileList, Xamarin.Mac' */ },
		{ NULL, 0x2529C /* 'CoreImage_CICircleSplashDistortion' => 'CoreImage.CICircleSplashDistortion, Xamarin.Mac' */ },
		{ NULL, 0x2579C /* 'NSAppearance' => 'AppKit.NSAppearance, Xamarin.Mac' */ },
		{ NULL, 0x2589C /* 'NSPort' => 'Foundation.NSPort, Xamarin.Mac' */ },
		{ NULL, 0x74D9C /* 'CoreImage_CIScreenFilter' => 'CoreImage.CIScreenFilter, Xamarin.Mac' */ },
		{ NULL, 0x2599C /* 'CoreImage_CICircularScreen' => 'CoreImage.CICircularScreen, Xamarin.Mac' */ },
		{ NULL, 0x25A9C /* 'AVCaptureDeviceFormat' => 'AVFoundation.AVCaptureDeviceFormat, Xamarin.Mac' */ },
		{ NULL, 0x25B9C /* 'CoreImage_CICircularWrap' => 'CoreImage.CICircularWrap, Xamarin.Mac' */ },
		{ NULL, 0x2B79C /* 'AVCaptureInput' => 'AVFoundation.AVCaptureInput, Xamarin.Mac' */ },
		{ NULL, 0x26E9C /* 'AVCaptureDeviceInput' => 'AVFoundation.AVCaptureDeviceInput, Xamarin.Mac' */ },
		{ NULL, 0x26F9C /* 'CoreImage_CIClamp' => 'CoreImage.CIClamp, Xamarin.Mac' */ },
		{ NULL, 0x34C9C /* 'DOMHTMLElement' => 'WebKit.DomHtmlElement, Xamarin.Mac' */ },
		{ NULL, 0x2749C /* 'DOMHTMLAnchorElement' => 'WebKit.DomHtmlAnchorElement, Xamarin.Mac' */ },
		{ NULL, 0x2759C /* 'NSPortMessage' => 'Foundation.NSPortMessage, Xamarin.Mac' */ },
		{ NULL, 0x27A9C /* 'AVCaptureDeviceInputSource' => 'AVFoundation.AVCaptureDeviceInputSource, Xamarin.Mac' */ },
		{ NULL, 0x27E9C /* 'CoreImage_CICode128BarcodeGenerator' => 'CoreImage.CICode128BarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0x27F9C /* 'NSPortNameServer' => 'Foundation.NSPortNameServer, Xamarin.Mac' */ },
		{ NULL, 0x2869C /* 'DOMHTMLAppletElement' => 'WebKit.DomHtmlAppletElement, Xamarin.Mac' */ },
		{ NULL, 0x28E9C /* 'NSPredicate' => 'Foundation.NSPredicate, Xamarin.Mac' */ },
		{ NULL, 0x2969C /* 'DOMHTMLAreaElement' => 'WebKit.DomHtmlAreaElement, Xamarin.Mac' */ },
		{ NULL, 0x2999C /* 'DOMHTMLBaseElement' => 'WebKit.DomHtmlBaseElement, Xamarin.Mac' */ },
		{ NULL, 0x29A9C /* 'MTLCompileOptions' => 'Metal.MTLCompileOptions, Xamarin.Mac' */ },
		{ NULL, 0x2A09C /* 'DOMHTMLBaseFontElement' => 'WebKit.DomHtmlBaseFontElement, Xamarin.Mac' */ },
		{ NULL, 0x2A19C /* 'CoreImage_CIColorBlendMode' => 'CoreImage.CIColorBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x2A39C /* 'CoreImage_CIColorBurnBlendMode' => 'CoreImage.CIColorBurnBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x2A59C /* 'CoreImage_CIColorClamp' => 'CoreImage.CIColorClamp, Xamarin.Mac' */ },
		{ NULL, 0x2A69C /* 'DOMHTMLBodyElement' => 'WebKit.DomHtmlBodyElement, Xamarin.Mac' */ },
		{ NULL, 0x2AC9C /* 'CoreImage_CIColorControls' => 'CoreImage.CIColorControls, Xamarin.Mac' */ },
		{ NULL, 0x2AD9C /* 'DOMHTMLBRElement' => 'WebKit.DomHtmlBRElement, Xamarin.Mac' */ },
		{ NULL, 0x2AF9C /* 'CoreImage_CIColorCrossPolynomial' => 'CoreImage.CIColorCrossPolynomial, Xamarin.Mac' */ },
		{ NULL, 0x2B29C /* 'CoreImage_CIColorCube' => 'CoreImage.CIColorCube, Xamarin.Mac' */ },
		{ NULL, 0x2B39C /* 'DOMHTMLButtonElement' => 'WebKit.DomHtmlButtonElement, Xamarin.Mac' */ },
		{ NULL, 0x2B99C /* 'CoreImage_CIColorCubesMixedWithMask' => 'CoreImage.CIColorCubesMixedWithMask, Xamarin.Mac' */ },
		{ NULL, 0x3149C /* 'DOMHTMLCollection' => 'WebKit.DomHtmlCollection, Xamarin.Mac' */ },
		{ NULL, 0x3179C /* 'CoreImage_CIColorCubeWithColorSpace' => 'CoreImage.CIColorCubeWithColorSpace, Xamarin.Mac' */ },
		{ NULL, 0x3189C /* 'AVCaptureInputPort' => 'AVFoundation.AVCaptureInputPort, Xamarin.Mac' */ },
		{ NULL, 0x3199C /* 'MTLComputePipelineDescriptor' => 'Metal.MTLComputePipelineDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x31E9C /* 'DOMHTMLDirectoryElement' => 'WebKit.DomHtmlDirectoryElement, Xamarin.Mac' */ },
		{ NULL, 0x31F9C /* 'CoreImage_CIColorCurves' => 'CoreImage.CIColorCurves, Xamarin.Mac' */ },
		{ NULL, 0x3229C /* 'MTLComputePipelineReflection' => 'Metal.MTLComputePipelineReflection, Xamarin.Mac' */ },
		{ NULL, 0x3239C /* 'CoreImage_CIColorDodgeBlendMode' => 'CoreImage.CIColorDodgeBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x3249C /* 'CoreImage_CIColorInvert' => 'CoreImage.CIColorInvert, Xamarin.Mac' */ },
		{ NULL, 0x3259C /* 'DOMHTMLDivElement' => 'WebKit.DomHtmlDivElement, Xamarin.Mac' */ },
		{ NULL, 0x3269C /* 'AVCaptureMovieFileOutput' => 'AVFoundation.AVCaptureMovieFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x32C9C /* 'DOMHTMLDListElement' => 'WebKit.DomHtmlDListElement, Xamarin.Mac' */ },
		{ NULL, 0x32F9C /* 'CoreImage_CIColorMap' => 'CoreImage.CIColorMap, Xamarin.Mac' */ },
		{ NULL, 0x3319C /* 'CoreImage_CIColorMatrix' => 'CoreImage.CIColorMatrix, Xamarin.Mac' */ },
		{ NULL, 0x3329C /* 'CoreImage_CIColorMonochrome' => 'CoreImage.CIColorMonochrome, Xamarin.Mac' */ },
		{ NULL, 0x33B9C /* 'DOMHTMLDocument' => 'WebKit.DomHtmlDocument, Xamarin.Mac' */ },
		{ NULL, 0x33C9C /* 'CoreImage_CIColorPolynomial' => 'CoreImage.CIColorPolynomial, Xamarin.Mac' */ },
		{ NULL, 0x33E9C /* 'AVCaptureScreenInput' => 'AVFoundation.AVCaptureScreenInput, Xamarin.Mac' */ },
		{ NULL, 0x3429C /* 'CoreImage_CIColorPosterize' => 'CoreImage.CIColorPosterize, Xamarin.Mac' */ },
		{ NULL, 0x3479C /* 'CoreImage_CIColumnAverage' => 'CoreImage.CIColumnAverage, Xamarin.Mac' */ },
		{ NULL, 0x3489C /* 'MTLDepthStencilDescriptor' => 'Metal.MTLDepthStencilDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x34B9C /* 'CoreImage_CIComicEffect' => 'CoreImage.CIComicEffect, Xamarin.Mac' */ },
		{ NULL, 0x3559C /* 'CoreImage_CIConstantColorGenerator' => 'CoreImage.CIConstantColorGenerator, Xamarin.Mac' */ },
		{ NULL, 0x3569C /* 'DOMHTMLEmbedElement' => 'WebKit.DomHtmlEmbedElement, Xamarin.Mac' */ },
		{ NULL, 0x3599C /* 'DOMHTMLFieldSetElement' => 'WebKit.DomHtmlFieldSetElement, Xamarin.Mac' */ },
		{ NULL, 0x35D9C /* 'DOMHTMLFontElement' => 'WebKit.DomHtmlFontElement, Xamarin.Mac' */ },
		{ NULL, 0x35F9C /* 'AVCaptureSynchronizedData' => 'AVFoundation.AVCaptureSynchronizedData, Xamarin.Mac' */ },
		{ NULL, 0x3659C /* 'DOMHTMLFormElement' => 'WebKit.DomHtmlFormElement, Xamarin.Mac' */ },
		{ NULL, 0x3669C /* 'NSPropertyListSerialization' => 'Foundation.NSPropertyListSerialization, Xamarin.Mac' */ },
		{ NULL, 0x3679C /* 'AVCaptureSynchronizedDataCollection' => 'AVFoundation.AVCaptureSynchronizedDataCollection, Xamarin.Mac' */ },
		{ NULL, 0xF129C /* 'NSData' => 'Foundation.NSData, Xamarin.Mac' */ },
		{ NULL, 0xFE79C /* 'NSMutableData' => 'Foundation.NSMutableData, Xamarin.Mac' */ },
		{ NULL, 0x36B9C /* 'NSPurgeableData' => 'Foundation.NSPurgeableData, Xamarin.Mac' */ },
		{ NULL, 0x36E9C /* 'DOMHTMLFrameElement' => 'WebKit.DomHtmlFrameElement, Xamarin.Mac' */ },
		{ NULL, 0x36F9C /* 'AVCaptureVideoDataOutput' => 'AVFoundation.AVCaptureVideoDataOutput, Xamarin.Mac' */ },
		{ NULL, 0x3709C /* 'NSRecursiveLock' => 'Foundation.NSRecursiveLock, Xamarin.Mac' */ },
		{ NULL, 0x3719C /* 'DOMHTMLFrameSetElement' => 'WebKit.DomHtmlFrameSetElement, Xamarin.Mac' */ },
		{ NULL, 0x37C9C /* 'DOMHTMLHeadElement' => 'WebKit.DomHtmlHeadElement, Xamarin.Mac' */ },
		{ NULL, 0x37E9C /* 'DOMHTMLHeadingElement' => 'WebKit.DomHtmlHeadingElement, Xamarin.Mac' */ },
		{ NULL, 0x38D9C /* 'DOMHTMLHRElement' => 'WebKit.DomHtmlHRElement, Xamarin.Mac' */ },
		{ NULL, 0x3B79C /* 'CoreImage_CIConvolutionCore' => 'CoreImage.CIConvolutionCore, Xamarin.Mac' */ },
		{ NULL, 0x38E9C /* 'CoreImage_CIConvolution3X3' => 'CoreImage.CIConvolution3X3, Xamarin.Mac' */ },
		{ NULL, 0x38F9C /* 'NSRegularExpression' => 'Foundation.NSRegularExpression, Xamarin.Mac' */ },
		{ NULL, 0x3949C /* 'CoreImage_CIConvolution5X5' => 'CoreImage.CIConvolution5X5, Xamarin.Mac' */ },
		{ NULL, 0x3969C /* 'DOMHTMLHtmlElement' => 'WebKit.DomHtmlHtmlElement, Xamarin.Mac' */ },
		{ NULL, 0x39C9C /* 'CoreImage_CIConvolution7X7' => 'CoreImage.CIConvolution7X7, Xamarin.Mac' */ },
		{ NULL, 0x3A09C /* 'CoreImage_CIConvolution9Horizontal' => 'CoreImage.CIConvolution9Horizontal, Xamarin.Mac' */ },
		{ NULL, 0x3A79C /* 'NSRunLoop' => 'Foundation.NSRunLoop, Xamarin.Mac' */ },
		{ NULL, 0x3A89C /* 'CoreImage_CIConvolution9Vertical' => 'CoreImage.CIConvolution9Vertical, Xamarin.Mac' */ },
		{ NULL, 0x3A99C /* 'DOMHTMLIFrameElement' => 'WebKit.DomHtmlIFrameElement, Xamarin.Mac' */ },
		{ NULL, 0x3B99C /* 'CoreImage_CICopyMachineTransition' => 'CoreImage.CICopyMachineTransition, Xamarin.Mac' */ },
		{ NULL, 0x3BB9C /* 'NSScriptCommand' => 'Foundation.NSScriptCommand, Xamarin.Mac' */ },
		{ NULL, 0x3BC9C /* 'CoreImage_CICrop' => 'CoreImage.CICrop, Xamarin.Mac' */ },
		{ NULL, 0x3C49C /* 'CoreImage_CICrystallize' => 'CoreImage.CICrystallize, Xamarin.Mac' */ },
		{ NULL, 0x3C59C /* 'NSAlignmentFeedbackFilter' => 'AppKit.NSAlignmentFeedbackFilter, Xamarin.Mac' */ },
		{ NULL, 0xCE09C /* 'AVAsset' => 'AVFoundation.AVAsset, Xamarin.Mac' */ },
		{ NULL, 0x3C69C /* 'AVComposition' => 'AVFoundation.AVComposition, Xamarin.Mac' */ },
		{ NULL, 0x3C79C /* 'DOMHTMLImageElement' => 'WebKit.DomHtmlImageElement, Xamarin.Mac' */ },
		{ NULL, 0x3CE9C /* 'CoreImage_CIDarkenBlendMode' => 'CoreImage.CIDarkenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x3D39C /* 'NSScriptCommandDescription' => 'Foundation.NSScriptCommandDescription, Xamarin.Mac' */ },
		{ NULL, 0x3D49C /* 'MTLFunctionConstant' => 'Metal.MTLFunctionConstant, Xamarin.Mac' */ },
		{ NULL, 0xCE19C /* 'AVAssetTrack' => 'AVFoundation.AVAssetTrack, Xamarin.Mac' */ },
		{ NULL, 0x3D89C /* 'AVCompositionTrack' => 'AVFoundation.AVCompositionTrack, Xamarin.Mac' */ },
		{ NULL, 0x3DA9C /* 'CIDataMatrixCodeDescriptor' => 'CoreImage.CIDataMatrixCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x3DC9C /* 'MTLFunctionConstantValues' => 'Metal.MTLFunctionConstantValues, Xamarin.Mac' */ },
		{ NULL, 0x3DD9C /* 'CWConfiguration' => 'CoreWlan.CWConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x3E09C /* 'CoreImage_CIDepthBlurEffect' => 'CoreImage.CIDepthBlurEffect, Xamarin.Mac' */ },
		{ NULL, 0x17A09C /* 'AVAssetTrackSegment' => 'AVFoundation.AVAssetTrackSegment, Xamarin.Mac' */ },
		{ NULL, 0x3E29C /* 'AVCompositionTrackSegment' => 'AVFoundation.AVCompositionTrackSegment, Xamarin.Mac' */ },
		{ NULL, 0x3E39C /* 'CWInterface' => 'CoreWlan.CWInterface, Xamarin.Mac' */ },
		{ NULL, 0x3E49C /* 'CoreImage_CIDepthDisparityConverter' => 'CoreImage.CIDepthDisparityConverter, Xamarin.Mac' */ },
		{ NULL, 0x3E59C /* 'DOMHTMLInputElement' => 'WebKit.DomHtmlInputElement, Xamarin.Mac' */ },
		{ NULL, 0xF459C /* 'EKObject' => 'EventKit.EKObject, Xamarin.Mac' */ },
		{ NULL, 0x3E79C /* 'EKRecurrenceRule' => 'EventKit.EKRecurrenceRule, Xamarin.Mac' */ },
		{ NULL, 0x3E89C /* 'EKRecurrenceDayOfWeek' => 'EventKit.EKRecurrenceDayOfWeek, Xamarin.Mac' */ },
		{ NULL, 0xEEE9C /* 'EKCalendarItem' => 'EventKit.EKCalendarItem, Xamarin.Mac' */ },
		{ NULL, 0x3EA9C /* 'EKEvent' => 'EventKit.EKEvent, Xamarin.Mac' */ },
		{ NULL, 0x3EB9C /* 'EKAlarm' => 'EventKit.EKAlarm, Xamarin.Mac' */ },
		{ NULL, 0x3EF9C /* 'CoreImage_CIDepthOfField' => 'CoreImage.CIDepthOfField, Xamarin.Mac' */ },
		{ NULL, 0x3F19C /* 'DOMHTMLLabelElement' => 'WebKit.DomHtmlLabelElement, Xamarin.Mac' */ },
		{ NULL, 0x3F79C /* 'CoreImage_CIDepthToDisparity' => 'CoreImage.CIDepthToDisparity, Xamarin.Mac' */ },
		{ NULL, 0x3F99C /* 'MTLHeapDescriptor' => 'Metal.MTLHeapDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x3FA9C /* 'DOMHTMLLegendElement' => 'WebKit.DomHtmlLegendElement, Xamarin.Mac' */ },
		{ NULL, 0xCC29C /* 'GCExtendedGamepad' => 'GameController.GCExtendedGamepad, Xamarin.Mac' */ },
		{ NULL, 0x3FC9C /* 'GCExtendedGamepadSnapshot' => 'GameController.GCExtendedGamepadSnapshot, Xamarin.Mac' */ },
		{ NULL, 0x4009C /* 'NSSortDescriptor' => 'Foundation.NSSortDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x4019C /* 'DOMHTMLLIElement' => 'WebKit.DomHtmlLIElement, Xamarin.Mac' */ },
		{ NULL, 0xCD79C /* 'GCGamepad' => 'GameController.GCGamepad, Xamarin.Mac' */ },
		{ NULL, 0x4039C /* 'GCGamepadSnapshot' => 'GameController.GCGamepadSnapshot, Xamarin.Mac' */ },
		{ NULL, 0x4069C /* 'NSAnimationContext' => 'AppKit.NSAnimationContext, Xamarin.Mac' */ },
		{ NULL, 0x4089C /* 'DOMHTMLLinkElement' => 'WebKit.DomHtmlLinkElement, Xamarin.Mac' */ },
		{ NULL, 0x4099C /* 'CoreImage_CIDifferenceBlendMode' => 'CoreImage.CIDifferenceBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x40D9C /* 'GKBehavior' => 'GameplayKit.GKBehavior, Xamarin.Mac' */ },
		{ NULL, 0x40F9C /* 'DOMHTMLMapElement' => 'WebKit.DomHtmlMapElement, Xamarin.Mac' */ },
		{ NULL, 0x4109C /* 'CoreImage_CIDiscBlur' => 'CoreImage.CIDiscBlur, Xamarin.Mac' */ },
		{ NULL, 0x4159C /* 'DOMHTMLMarqueeElement' => 'WebKit.DomHtmlMarqueeElement, Xamarin.Mac' */ },
		{ NULL, 0x4169C /* 'GKComponentSystem' => 'GameplayKit.GKComponentSystem`1, Xamarin.Mac' */ },
		{ NULL, 0x4179C /* 'CoreImage_CIDisintegrateWithMaskTransition' => 'CoreImage.CIDisintegrateWithMaskTransition, Xamarin.Mac' */ },
		{ NULL, 0x41D9C /* 'GKCompositeBehavior' => 'GameplayKit.GKCompositeBehavior, Xamarin.Mac' */ },
		{ NULL, 0x41E9C /* 'DOMHTMLMenuElement' => 'WebKit.DomHtmlMenuElement, Xamarin.Mac' */ },
		{ NULL, 0x41F9C /* 'CoreImage_CIDisparityToDepth' => 'CoreImage.CIDisparityToDepth, Xamarin.Mac' */ },
		{ NULL, 0x4219C /* 'GKEntity' => 'GameplayKit.GKEntity, Xamarin.Mac' */ },
		{ NULL, 0x4229C /* 'AVContentKeyResponse' => 'AVFoundation.AVContentKeyResponse, Xamarin.Mac' */ },
		{ NULL, 0x4249C /* 'CoreImage_CIDisplacementDistortion' => 'CoreImage.CIDisplacementDistortion, Xamarin.Mac' */ },
		{ NULL, 0x4299C /* 'DOMHTMLMetaElement' => 'WebKit.DomHtmlMetaElement, Xamarin.Mac' */ },
		{ NULL, 0x42B9C /* 'CoreImage_CIDissolveTransition' => 'CoreImage.CIDissolveTransition, Xamarin.Mac' */ },
		{ NULL, 0x10619C /* 'GKGraph' => 'GameplayKit.GKGraph, Xamarin.Mac' */ },
		{ NULL, 0x42C9C /* 'GKGridGraph' => 'GameplayKit.GKGridGraph, Xamarin.Mac' */ },
		{ NULL, 0x42D9C /* 'DOMHTMLModElement' => 'WebKit.DomHtmlModElement, Xamarin.Mac' */ },
		{ NULL, 0x42F9C /* 'GKObstacleGraph' => 'GameplayKit.GKObstacleGraph, Xamarin.Mac' */ },
		{ NULL, 0x4349C /* 'AVContentKeySession' => 'AVFoundation.AVContentKeySession, Xamarin.Mac' */ },
		{ NULL, 0x4379C /* 'CoreImage_CIDivideBlendMode' => 'CoreImage.CIDivideBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x4389C /* 'GKPath' => 'GameplayKit.GKPath, Xamarin.Mac' */ },
		{ NULL, 0xD209C /* 'NSImageRep' => 'AppKit.NSImageRep, Xamarin.Mac' */ },
		{ NULL, 0x43A9C /* 'NSCachedImageRep' => 'AppKit.NSCachedImageRep, Xamarin.Mac' */ },
		{ NULL, 0x43B9C /* 'CoreImage_CIDotScreen' => 'CoreImage.CIDotScreen, Xamarin.Mac' */ },
		{ NULL, 0x43C9C /* 'MTLPipelineBufferDescriptor' => 'Metal.MTLPipelineBufferDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x10DE9C /* 'GKObstacle' => 'GameplayKit.GKObstacle, Xamarin.Mac' */ },
		{ NULL, 0x43D9C /* 'GKPolygonObstacle' => 'GameplayKit.GKPolygonObstacle, Xamarin.Mac' */ },
		{ NULL, 0x43E9C /* 'DOMHTMLObjectElement' => 'WebKit.DomHtmlObjectElement, Xamarin.Mac' */ },
		{ NULL, 0x43F9C /* 'CoreImage_CIDroste' => 'CoreImage.CIDroste, Xamarin.Mac' */ },
		{ NULL, 0x4409C /* 'MTLPipelineBufferDescriptorArray' => 'Metal.MTLPipelineBufferDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x4419C /* 'GKState' => 'GameplayKit.GKState, Xamarin.Mac' */ },
		{ NULL, 0x4479C /* 'DOMHTMLOListElement' => 'WebKit.DomHtmlOListElement, Xamarin.Mac' */ },
		{ NULL, 0x4489C /* 'CoreImage_CIEdgePreserveUpsampleFilter' => 'CoreImage.CIEdgePreserveUpsampleFilter, Xamarin.Mac' */ },
		{ NULL, 0x4499C /* 'GKStateMachine' => 'GameplayKit.GKStateMachine, Xamarin.Mac' */ },
		{ NULL, 0x14BA9C /* 'NSTouchBarItem' => 'AppKit.NSTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x44A9C /* 'NSCandidateListTouchBarItem' => 'AppKit.NSCandidateListTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x44E9C /* 'CoreImage_CIEdges' => 'CoreImage.CIEdges, Xamarin.Mac' */ },
		{ NULL, 0x44F9C /* 'DOMHTMLOptGroupElement' => 'WebKit.DomHtmlOptGroupElement, Xamarin.Mac' */ },
		{ NULL, 0x4529C /* 'CoreImage_CIEdgeWork' => 'CoreImage.CIEdgeWork, Xamarin.Mac' */ },
		{ NULL, 0x4539C /* 'GLKMesh' => 'GLKit.GLKMesh, Xamarin.Mac' */ },
		{ NULL, 0x5649C /* 'AVMetadataGroup' => 'AVFoundation.AVMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x4549C /* 'AVDateRangeMetadataGroup' => 'AVFoundation.AVDateRangeMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x4559C /* 'MTLPointerType' => 'Metal.MTLPointerType, Xamarin.Mac' */ },
		{ NULL, 0x45A9C /* 'DOMHTMLOptionElement' => 'WebKit.DomHtmlOptionElement, Xamarin.Mac' */ },
		{ NULL, 0x7DD9C /* 'CoreImage_CITileFilter' => 'CoreImage.CITileFilter, Xamarin.Mac' */ },
		{ NULL, 0x45B9C /* 'CoreImage_CIEightfoldReflectedTile' => 'CoreImage.CIEightfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0x4619C /* 'CoreImage_CIExclusionBlendMode' => 'CoreImage.CIExclusionBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x4639C /* 'DOMHTMLOptionsCollection' => 'WebKit.DomHtmlOptionsCollection, Xamarin.Mac' */ },
		{ NULL, 0x4649C /* 'AVDepthData' => 'AVFoundation.AVDepthData, Xamarin.Mac' */ },
		{ NULL, 0x4659C /* 'CoreImage_CIExposureAdjust' => 'CoreImage.CIExposureAdjust, Xamarin.Mac' */ },
		{ NULL, 0x4679C /* 'DOMHTMLParagraphElement' => 'WebKit.DomHtmlParagraphElement, Xamarin.Mac' */ },
		{ NULL, 0x46B9C /* 'CoreImage_CIFaceBalance' => 'CoreImage.CIFaceBalance, Xamarin.Mac' */ },
		{ NULL, 0x4729C /* 'DOMHTMLParamElement' => 'WebKit.DomHtmlParamElement, Xamarin.Mac' */ },
		{ NULL, 0x4849C /* 'DOMHTMLPreElement' => 'WebKit.DomHtmlPreElement, Xamarin.Mac' */ },
		{ NULL, 0x48C9C /* 'CIFeature' => 'CoreImage.CIFeature, Xamarin.Mac' */ },
		{ NULL, 0x4859C /* 'CIFaceFeature' => 'CoreImage.CIFaceFeature, Xamarin.Mac' */ },
		{ NULL, 0x4889C /* 'DOMHTMLQuoteElement' => 'WebKit.DomHtmlQuoteElement, Xamarin.Mac' */ },
		{ NULL, 0x48B9C /* 'CoreImage_CIFalseColor' => 'CoreImage.CIFalseColor, Xamarin.Mac' */ },
		{ NULL, 0x48D9C /* 'DOMHTMLScriptElement' => 'WebKit.DomHtmlScriptElement, Xamarin.Mac' */ },
		{ NULL, 0x4949C /* 'NSTextCheckingResult' => 'Foundation.NSTextCheckingResult, Xamarin.Mac' */ },
		{ NULL, 0x4979C /* 'DOMHTMLSelectElement' => 'WebKit.DomHtmlSelectElement, Xamarin.Mac' */ },
		{ NULL, 0xC919C /* 'AVURLAsset' => 'AVFoundation.AVUrlAsset, Xamarin.Mac' */ },
		{ NULL, 0x4999C /* 'AVFragmentedAsset' => 'AVFoundation.AVFragmentedAsset, Xamarin.Mac' */ },
		{ NULL, 0x49A9C /* 'INCallRecord' => 'Intents.INCallRecord, Xamarin.Mac' */ },
		{ NULL, 0x49C9C /* 'DOMHTMLStyleElement' => 'WebKit.DomHtmlStyleElement, Xamarin.Mac' */ },
		{ NULL, 0x4C69C /* 'INIntentResolutionResult' => 'Intents.INIntentResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x49D9C /* 'INCallRecordTypeResolutionResult' => 'Intents.INCallRecordTypeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x49F9C /* 'DOMHTMLTableCaptionElement' => 'WebKit.DomHtmlTableCaptionElement, Xamarin.Mac' */ },
		{ NULL, 0x4A19C /* 'AVFragmentedAssetMinder' => 'AVFoundation.AVFragmentedAssetMinder, Xamarin.Mac' */ },
		{ NULL, 0x4A69C /* 'AVFragmentedAssetTrack' => 'AVFoundation.AVFragmentedAssetTrack, Xamarin.Mac' */ },
		{ NULL, 0x4A79C /* 'DOMHTMLTableCellElement' => 'WebKit.DomHtmlTableCellElement, Xamarin.Mac' */ },
		{ NULL, 0x4A89C /* 'NSTimer' => 'Foundation.NSTimer, Xamarin.Mac' */ },
		{ NULL, 0x4B09C /* 'DOMHTMLTableColElement' => 'WebKit.DomHtmlTableColElement, Xamarin.Mac' */ },
		{ NULL, 0x4B39C /* 'MTLRenderPassAttachmentDescriptor' => 'Metal.MTLRenderPassAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x4B59C /* 'NSTimeZone' => 'Foundation.NSTimeZone, Xamarin.Mac' */ },
		{ NULL, 0x4B69C /* 'MTLRenderPassColorAttachmentDescriptor' => 'Metal.MTLRenderPassColorAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x4B79C /* 'AVFragmentedMovieMinder' => 'AVFoundation.AVFragmentedMovieMinder, Xamarin.Mac' */ },
		{ NULL, 0x4B89C /* 'MTLRenderPassColorAttachmentDescriptorArray' => 'Metal.MTLRenderPassColorAttachmentDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x4B99C /* 'CIFilterGenerator' => 'CoreImage.CIFilterGenerator, Xamarin.Mac' */ },
		{ NULL, 0x4BA9C /* 'DOMHTMLTableElement' => 'WebKit.DomHtmlTableElement, Xamarin.Mac' */ },
		{ NULL, 0x6CA9C /* 'NSController' => 'AppKit.NSController, Xamarin.Mac' */ },
		{ NULL, 0xFFB9C /* 'NSObjectController' => 'AppKit.NSObjectController, Xamarin.Mac' */ },
		{ NULL, 0x4BB9C /* 'NSArrayController' => 'AppKit.NSArrayController, Xamarin.Mac' */ },
		{ NULL, 0x4BE9C /* 'MTLRenderPassDepthAttachmentDescriptor' => 'Metal.MTLRenderPassDepthAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x15189C /* 'NSTypesetter' => 'AppKit.NSTypesetter, Xamarin.Mac' */ },
		{ NULL, 0x4C19C /* 'NSATSTypesetter' => 'AppKit.NSATSTypesetter, Xamarin.Mac' */ },
		{ NULL, 0x4C79C /* 'DOMHTMLTableRowElement' => 'WebKit.DomHtmlTableRowElement, Xamarin.Mac' */ },
		{ NULL, 0x4CA9C /* 'MTLRenderPassDescriptor' => 'Metal.MTLRenderPassDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x4CB9C /* 'AVFrameRateRange' => 'AVFoundation.AVFrameRateRange, Xamarin.Mac' */ },
		{ NULL, 0x4CC9C /* 'INMessageAttributeOptionsResolutionResult' => 'Intents.INMessageAttributeOptionsResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x4CE9C /* 'MTLRenderPassStencilAttachmentDescriptor' => 'Metal.MTLRenderPassStencilAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x4CF9C /* 'DOMHTMLTableSectionElement' => 'WebKit.DomHtmlTableSectionElement, Xamarin.Mac' */ },
		{ NULL, 0x4D19C /* 'INMessageAttributeResolutionResult' => 'Intents.INMessageAttributeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x4D49C /* 'CIFilterShape' => 'CoreImage.CIFilterShape, Xamarin.Mac' */ },
		{ NULL, 0x4D69C /* 'NSUnit' => 'Foundation.NSUnit, Xamarin.Mac' */ },
		{ NULL, 0x4D79C /* 'DOMHTMLTextAreaElement' => 'WebKit.DomHtmlTextAreaElement, Xamarin.Mac' */ },
		{ NULL, 0x4D89C /* 'MTLRenderPipelineColorAttachmentDescriptor' => 'Metal.MTLRenderPipelineColorAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x4D99C /* 'CoreImage_CIFlashTransition' => 'CoreImage.CIFlashTransition, Xamarin.Mac' */ },
		{ NULL, 0x12209C /* 'NSDimension' => 'Foundation.NSDimension, Xamarin.Mac' */ },
		{ NULL, 0x4DA9C /* 'NSUnitAcceleration' => 'Foundation.NSUnitAcceleration, Xamarin.Mac' */ },
		{ NULL, 0x4DD9C /* 'CoreImage_CIFourfoldReflectedTile' => 'CoreImage.CIFourfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0x4DE9C /* 'MTLRenderPipelineColorAttachmentDescriptorArray' => 'Metal.MTLRenderPipelineColorAttachmentDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x4DF9C /* 'DOMImplementation' => 'WebKit.DomImplementation, Xamarin.Mac' */ },
		{ NULL, 0x4E09C /* 'AVMediaDataStorage' => 'AVFoundation.AVMediaDataStorage, Xamarin.Mac' */ },
		{ NULL, 0x4E19C /* 'CoreImage_CIFourfoldRotatedTile' => 'CoreImage.CIFourfoldRotatedTile, Xamarin.Mac' */ },
		{ NULL, 0x4E29C /* 'DOMCSSImportRule' => 'WebKit.DomImportCssRule, Xamarin.Mac' */ },
		{ NULL, 0x4E39C /* 'NSUnitAngle' => 'Foundation.NSUnitAngle, Xamarin.Mac' */ },
		{ NULL, 0x4E49C /* 'CoreImage_CIFourfoldTranslatedTile' => 'CoreImage.CIFourfoldTranslatedTile, Xamarin.Mac' */ },
		{ NULL, 0x4E59C /* 'AVMediaSelection' => 'AVFoundation.AVMediaSelection, Xamarin.Mac' */ },
		{ NULL, 0x4E69C /* 'NSBezierPath' => 'AppKit.NSBezierPath, Xamarin.Mac' */ },
		{ NULL, 0x4E79C /* 'CoreImage_CIGammaAdjust' => 'CoreImage.CIGammaAdjust, Xamarin.Mac' */ },
		{ NULL, 0x4E89C /* 'NSUnitArea' => 'Foundation.NSUnitArea, Xamarin.Mac' */ },
		{ NULL, 0x14E89C /* 'INIntent' => 'Intents.INIntent, Xamarin.Mac' */ },
		{ NULL, 0x4E99C /* 'INSearchCallHistoryIntent' => 'Intents.INSearchCallHistoryIntent, Xamarin.Mac' */ },
		{ NULL, 0x56C9C /* 'DOMUIEvent' => 'WebKit.DomUIEvent, Xamarin.Mac' */ },
		{ NULL, 0x4EA9C /* 'DOMKeyboardEvent' => 'WebKit.DomKeyboardEvent, Xamarin.Mac' */ },
		{ NULL, 0x4EB9C /* 'CoreImage_CIGaussianBlur' => 'CoreImage.CIGaussianBlur, Xamarin.Mac' */ },
		{ NULL, 0x4EC9C /* 'AVMediaSelectionGroup' => 'AVFoundation.AVMediaSelectionGroup, Xamarin.Mac' */ },
		{ NULL, 0x4ED9C /* 'CoreImage_CIGaussianGradient' => 'CoreImage.CIGaussianGradient, Xamarin.Mac' */ },
		{ NULL, 0x4EE9C /* 'NSUnitConcentrationMass' => 'Foundation.NSUnitConcentrationMass, Xamarin.Mac' */ },
		{ NULL, 0x4EF9C /* 'DOMMediaList' => 'WebKit.DomMediaList, Xamarin.Mac' */ },
		{ NULL, 0x4F09C /* 'CoreImage_CIGlassDistortion' => 'CoreImage.CIGlassDistortion, Xamarin.Mac' */ },
		{ NULL, 0x4F19C /* 'NSUnitConverter' => 'Foundation.NSUnitConverter, Xamarin.Mac' */ },
		{ NULL, 0x4F29C /* 'MTLRenderPipelineDescriptor' => 'Metal.MTLRenderPipelineDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x4F39C /* 'CoreImage_CIGlassLozenge' => 'CoreImage.CIGlassLozenge, Xamarin.Mac' */ },
		{ NULL, 0x4F49C /* 'AVMediaSelectionOption' => 'AVFoundation.AVMediaSelectionOption, Xamarin.Mac' */ },
		{ NULL, 0x4F79C /* 'NSUnitConverterLinear' => 'Foundation.NSUnitConverterLinear, Xamarin.Mac' */ },
		{ NULL, 0x4F89C /* 'DOMMouseEvent' => 'WebKit.DomMouseEvent, Xamarin.Mac' */ },
		{ NULL, 0x4F99C /* 'CoreImage_CIGlideReflectedTile' => 'CoreImage.CIGlideReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0x4FA9C /* 'INSpeakableString' => 'Intents.INSpeakableString, Xamarin.Mac' */ },
		{ NULL, 0x4FB9C /* 'MTLRenderPipelineReflection' => 'Metal.MTLRenderPipelineReflection, Xamarin.Mac' */ },
		{ NULL, 0x4FD9C /* 'NSUnitDispersion' => 'Foundation.NSUnitDispersion, Xamarin.Mac' */ },
		{ NULL, 0x4FE9C /* 'CoreImage_CIGloom' => 'CoreImage.CIGloom, Xamarin.Mac' */ },
		{ NULL, 0x4FF9C /* 'NSBitmapImageRep' => 'AppKit.NSBitmapImageRep, Xamarin.Mac' */ },
		{ NULL, 0x5009C /* 'DOMNamedNodeMap' => 'WebKit.DomNamedNodeMap, Xamarin.Mac' */ },
		{ NULL, 0x5039C /* 'CoreImage_CIHardLightBlendMode' => 'CoreImage.CIHardLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x5089C /* 'NSUnitDuration' => 'Foundation.NSUnitDuration, Xamarin.Mac' */ },
		{ NULL, 0x5099C /* 'CoreImage_CIHatchedScreen' => 'CoreImage.CIHatchedScreen, Xamarin.Mac' */ },
		{ NULL, 0x50A9C /* 'CoreImage_CIHeightFieldFromMask' => 'CoreImage.CIHeightFieldFromMask, Xamarin.Mac' */ },
		{ NULL, 0x50E9C /* 'IOSurface' => 'IOSurface.IOSurface, Xamarin.Mac' */ },
		{ NULL, 0x50F9C /* 'NSUnitElectricCharge' => 'Foundation.NSUnitElectricCharge, Xamarin.Mac' */ },
		{ NULL, 0x5109C /* 'CoreImage_CIHexagonalPixellate' => 'CoreImage.CIHexagonalPixellate, Xamarin.Mac' */ },
		{ NULL, 0x5119C /* 'NSBox' => 'AppKit.NSBox, Xamarin.Mac' */ },
		{ NULL, 0x5179C /* 'NSUnitElectricCurrent' => 'Foundation.NSUnitElectricCurrent, Xamarin.Mac' */ },
		{ NULL, 0x5189C /* 'CoreImage_CIHighlightShadowAdjust' => 'CoreImage.CIHighlightShadowAdjust, Xamarin.Mac' */ },
		{ NULL, 0x5199C /* 'JSContext' => 'JavaScriptCore.JSContext, Xamarin.Mac' */ },
		{ NULL, 0x51A9C /* 'JSValue' => 'JavaScriptCore.JSValue, Xamarin.Mac' */ },
		{ NULL, 0x51F9C /* 'CoreImage_CIHistogramDisplayFilter' => 'CoreImage.CIHistogramDisplayFilter, Xamarin.Mac' */ },
		{ NULL, 0x5219C /* 'NSUnitElectricPotentialDifference' => 'Foundation.NSUnitElectricPotentialDifference, Xamarin.Mac' */ },
		{ NULL, 0x5249C /* 'CoreImage_CIHoleDistortion' => 'CoreImage.CIHoleDistortion, Xamarin.Mac' */ },
		{ NULL, 0x5259C /* 'DOMNodeIterator' => 'WebKit.DomNodeIterator, Xamarin.Mac' */ },
		{ NULL, 0x5269C /* 'NSUnitElectricResistance' => 'Foundation.NSUnitElectricResistance, Xamarin.Mac' */ },
		{ NULL, 0x5289C /* 'CoreImage_CIHueAdjust' => 'CoreImage.CIHueAdjust, Xamarin.Mac' */ },
		{ NULL, 0x5299C /* 'DOMNodeList' => 'WebKit.DomNodeList, Xamarin.Mac' */ },
		{ NULL, 0x17569C /* 'MKShape' => 'MapKit.MKShape, Xamarin.Mac' */ },
		{ NULL, 0x53F9C /* 'MKMultiPoint' => 'MapKit.MKMultiPoint, Xamarin.Mac' */ },
		{ NULL, 0x54B9C /* 'MKPolyline' => 'MapKit.MKPolyline, Xamarin.Mac' */ },
		{ NULL, 0x52A9C /* 'MKGeodesicPolyline' => 'MapKit.MKGeodesicPolyline, Xamarin.Mac' */ },
		{ NULL, 0x52B9C /* 'CoreImage_CIHueBlendMode' => 'CoreImage.CIHueBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x52C9C /* 'NSUnitEnergy' => 'Foundation.NSUnitEnergy, Xamarin.Mac' */ },
		{ NULL, 0x52D9C /* 'MTLSamplerDescriptor' => 'Metal.MTLSamplerDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x5309C /* 'CoreImage_CIHueSaturationValueGradient' => 'CoreImage.CIHueSaturationValueGradient, Xamarin.Mac' */ },
		{ NULL, 0x5349C /* 'DOMOverflowEvent' => 'WebKit.DomOverflowEvent, Xamarin.Mac' */ },
		{ NULL, 0x5359C /* 'NSUnitFrequency' => 'Foundation.NSUnitFrequency, Xamarin.Mac' */ },
		{ NULL, 0x5389C /* 'MKMapItem' => 'MapKit.MKMapItem, Xamarin.Mac' */ },
		{ NULL, 0x53A9C /* 'NSCIImageRep' => 'AppKit.NSCIImageRep, Xamarin.Mac' */ },
		{ NULL, 0x53B9C /* 'DOMProcessingInstruction' => 'WebKit.DomProcessingInstruction, Xamarin.Mac' */ },
		{ NULL, 0x53C9C /* 'NSUnitFuelEfficiency' => 'Foundation.NSUnitFuelEfficiency, Xamarin.Mac' */ },
		{ NULL, 0x5429C /* 'DOMProgressEvent' => 'WebKit.DomProgressEvent, Xamarin.Mac' */ },
		{ NULL, 0x5449C /* 'NSUnitIlluminance' => 'Foundation.NSUnitIlluminance, Xamarin.Mac' */ },
		{ NULL, 0x5479C /* 'MTLStageInputOutputDescriptor' => 'Metal.MTLStageInputOutputDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x5489C /* 'MKPolygon' => 'MapKit.MKPolygon, Xamarin.Mac' */ },
		{ NULL, 0x54A9C /* 'NSBrowserCell' => 'AppKit.NSBrowserCell, Xamarin.Mac' */ },
		{ NULL, 0x54C9C /* 'NSUnitLength' => 'Foundation.NSUnitLength, Xamarin.Mac' */ },
		{ NULL, 0x54D9C /* 'DOMRange' => 'WebKit.DomRange, Xamarin.Mac' */ },
		{ NULL, 0x54E9C /* 'MTLStencilDescriptor' => 'Metal.MTLStencilDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x54F9C /* 'NSClipView' => 'AppKit.NSClipView, Xamarin.Mac' */ },
		{ NULL, 0x5869C /* 'AVMetadataObject' => 'AVFoundation.AVMetadataObject, Xamarin.Mac' */ },
		{ NULL, 0x5509C /* 'AVMetadataFaceObject' => 'AVFoundation.AVMetadataFaceObject, Xamarin.Mac' */ },
		{ NULL, 0x55D9C /* 'NSUnitMass' => 'Foundation.NSUnitMass, Xamarin.Mac' */ },
		{ NULL, 0x5639C /* 'DOMStyleSheetList' => 'WebKit.DomStyleSheetList, Xamarin.Mac' */ },
		{ NULL, 0x56A9C /* 'NSUnitPower' => 'Foundation.NSUnitPower, Xamarin.Mac' */ },
		{ NULL, 0x56D9C /* 'MTLStructMember' => 'Metal.MTLStructMember, Xamarin.Mac' */ },
		{ NULL, 0x5739C /* 'CIImageAccumulator' => 'CoreImage.CIImageAccumulator, Xamarin.Mac' */ },
		{ NULL, 0x5749C /* 'DOMWheelEvent' => 'WebKit.DomWheelEvent, Xamarin.Mac' */ },
		{ NULL, 0x5759C /* 'NSUnitPressure' => 'Foundation.NSUnitPressure, Xamarin.Mac' */ },
		{ NULL, 0x5779C /* 'MTLStructType' => 'Metal.MTLStructType, Xamarin.Mac' */ },
		{ NULL, 0x5799C /* 'AVMetadataItemFilter' => 'AVFoundation.AVMetadataItemFilter, Xamarin.Mac' */ },
		{ NULL, 0x57C9C /* 'WebArchive' => 'WebKit.WebArchive, Xamarin.Mac' */ },
		{ NULL, 0x57D9C /* 'NSUnitSpeed' => 'Foundation.NSUnitSpeed, Xamarin.Mac' */ },
		{ NULL, 0x5809C /* 'AVMetadataItemValueRequest' => 'AVFoundation.AVMetadataItemValueRequest, Xamarin.Mac' */ },
		{ NULL, 0x5839C /* 'WebBackForwardList' => 'WebKit.WebBackForwardList, Xamarin.Mac' */ },
		{ NULL, 0x5849C /* 'NSUnitTemperature' => 'Foundation.NSUnitTemperature, Xamarin.Mac' */ },
		{ NULL, 0x58C9C /* 'WebDataSource' => 'WebKit.WebDataSource, Xamarin.Mac' */ },
		{ NULL, 0x58D9C /* 'CIImageProcessorKernel' => 'CoreImage.CIImageProcessorKernel, Xamarin.Mac' */ },
		{ NULL, 0x58F9C /* 'NSUnitVolume' => 'Foundation.NSUnitVolume, Xamarin.Mac' */ },
		{ NULL, 0x6B19C /* 'NSURLDownload' => 'Foundation.NSUrlDownload, Xamarin.Mac' */ },
		{ NULL, 0x59D9C /* 'WebDownload' => 'WebKit.WebDownload, Xamarin.Mac' */ },
		{ NULL, 0x5A19C /* 'MTLVertexAttributeDescriptorArray' => 'Metal.MTLVertexAttributeDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x5A29C /* 'MTLVertexBufferLayoutDescriptorArray' => 'Metal.MTLVertexBufferLayoutDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x5A39C /* 'AVMovie' => 'AVFoundation.AVMovie, Xamarin.Mac' */ },
		{ NULL, 0x5B29C /* 'MTLVertexDescriptor' => 'Metal.MTLVertexDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x5B39C /* 'MTLTextureDescriptor' => 'Metal.MTLTextureDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x5B49C /* 'MTKMesh' => 'MetalKit.MTKMesh, Xamarin.Mac' */ },
		{ NULL, 0x5B69C /* 'MTKMeshBufferAllocator' => 'MetalKit.MTKMeshBufferAllocator, Xamarin.Mac' */ },
		{ NULL, 0x5B79C /* 'AVMovieTrack' => 'AVFoundation.AVMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x5B89C /* 'CoreImage_CIKaleidoscope' => 'CoreImage.CIKaleidoscope, Xamarin.Mac' */ },
		{ NULL, 0x5B99C /* 'MTLTextureReferenceType' => 'Metal.MTLTextureReferenceType, Xamarin.Mac' */ },
		{ NULL, 0xE709C /* 'MPSKernel' => 'MetalPerformanceShaders.MPSKernel, Xamarin.Mac' */ },
		{ NULL, 0x100D9C /* 'MPSUnaryImageKernel' => 'MetalPerformanceShaders.MPSUnaryImageKernel, Xamarin.Mac' */ },
		{ NULL, 0x5BE9C /* 'MPSImageLanczosScale' => 'MetalPerformanceShaders.MPSImageLanczosScale, Xamarin.Mac' */ },
		{ NULL, 0x5BF9C /* 'WebFrame' => 'WebKit.WebFrame, Xamarin.Mac' */ },
		{ NULL, 0x5C19C /* 'MPSCNNConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x5C29C /* 'NSCollectionView' => 'AppKit.NSCollectionView, Xamarin.Mac' */ },
		{ NULL, 0x5FB9C /* 'NSCollectionViewLayout' => 'AppKit.NSCollectionViewLayout, Xamarin.Mac' */ },
		{ NULL, 0x5C49C /* 'NSCollectionViewFlowLayout' => 'AppKit.NSCollectionViewFlowLayout, Xamarin.Mac' */ },
		{ NULL, 0x76F9C /* 'MPSCNNKernel' => 'MetalPerformanceShaders.MPSCnnKernel, Xamarin.Mac' */ },
		{ NULL, 0x7999C /* 'MPSCNNNeuron' => 'MetalPerformanceShaders.MPSCnnNeuron, Xamarin.Mac' */ },
		{ NULL, 0x5C69C /* 'MPSCNNNeuronPReLU' => 'MetalPerformanceShaders.MPSCnnNeuronPReLU, Xamarin.Mac' */ },
		{ NULL, 0x5C79C /* 'CoreImage_CILabDeltaE' => 'CoreImage.CILabDeltaE, Xamarin.Mac' */ },
		{ NULL, 0x5C89C /* 'MPSCNNBinaryConvolution' => 'MetalPerformanceShaders.MPSCnnBinaryConvolution, Xamarin.Mac' */ },
		{ NULL, 0x5C99C /* 'MPSCNNBinaryFullyConnected' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0x5CB9C /* 'AVMusicTrack' => 'AVFoundation.AVMusicTrack, Xamarin.Mac' */ },
		{ NULL, 0x6179C /* 'NSCollectionViewLayoutInvalidationContext' => 'AppKit.NSCollectionViewLayoutInvalidationContext, Xamarin.Mac' */ },
		{ NULL, 0x5CC9C /* 'NSCollectionViewFlowLayoutInvalidationContext' => 'AppKit.NSCollectionViewFlowLayoutInvalidationContext, Xamarin.Mac' */ },
		{ NULL, 0x5CD9C /* 'CoreImage_CILanczosScaleTransform' => 'CoreImage.CILanczosScaleTransform, Xamarin.Mac' */ },
		{ NULL, 0x5D39C /* 'CoreImage_CILenticularHaloGenerator' => 'CoreImage.CILenticularHaloGenerator, Xamarin.Mac' */ },
		{ NULL, 0x5D49C /* 'MTLVertexAttribute' => 'Metal.MTLVertexAttribute, Xamarin.Mac' */ },
		{ NULL, 0x1ACE9C /* 'AVAudioMix' => 'AVFoundation.AVAudioMix, Xamarin.Mac' */ },
		{ NULL, 0x5D59C /* 'AVMutableAudioMix' => 'AVFoundation.AVMutableAudioMix, Xamarin.Mac' */ },
		{ NULL, 0x5D69C /* 'CoreImage_CILightenBlendMode' => 'CoreImage.CILightenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x5D79C /* 'NSCollectionViewGridLayout' => 'AppKit.NSCollectionViewGridLayout, Xamarin.Mac' */ },
		{ NULL, 0x5D99C /* 'MTLVertexAttributeDescriptor' => 'Metal.MTLVertexAttributeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x5DA9C /* 'CoreImage_CILightTunnel' => 'CoreImage.CILightTunnel, Xamarin.Mac' */ },
		{ NULL, 0x1C749C /* 'AVAudioMixInputParameters' => 'AVFoundation.AVAudioMixInputParameters, Xamarin.Mac' */ },
		{ NULL, 0x5DF9C /* 'AVMutableAudioMixInputParameters' => 'AVFoundation.AVMutableAudioMixInputParameters, Xamarin.Mac' */ },
		{ NULL, 0x175E9C /* 'NSViewController' => 'AppKit.NSViewController, Xamarin.Mac' */ },
		{ NULL, 0x5E19C /* 'NSCollectionViewItem' => 'AppKit.NSCollectionViewItem, Xamarin.Mac' */ },
		{ NULL, 0x5E29C /* 'CoreImage_CILinearBurnBlendMode' => 'CoreImage.CILinearBurnBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x5E39C /* 'MTLVertexBufferLayoutDescriptor' => 'Metal.MTLVertexBufferLayoutDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x5E49C /* 'WebFrameView' => 'WebKit.WebFrameView, Xamarin.Mac' */ },
		{ NULL, 0x5E59C /* 'AVMutableComposition' => 'AVFoundation.AVMutableComposition, Xamarin.Mac' */ },
		{ NULL, 0x5E69C /* 'CoreImage_CILinearDodgeBlendMode' => 'CoreImage.CILinearDodgeBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x5E89C /* 'CoreImage_CILinearGradient' => 'CoreImage.CILinearGradient, Xamarin.Mac' */ },
		{ NULL, 0x5E99C /* 'MDLAnimatedValue' => 'ModelIO.MDLAnimatedValue, Xamarin.Mac' */ },
		{ NULL, 0x5EA9C /* 'MDLAnimatedScalarArray' => 'ModelIO.MDLAnimatedScalarArray, Xamarin.Mac' */ },
		{ NULL, 0x5EB9C /* 'MDLAnimatedVector3Array' => 'ModelIO.MDLAnimatedVector3Array, Xamarin.Mac' */ },
		{ NULL, 0x5EC9C /* 'MDLAnimatedQuaternionArray' => 'ModelIO.MDLAnimatedQuaternionArray, Xamarin.Mac' */ },
		{ NULL, 0x5ED9C /* 'MDLAnimatedScalar' => 'ModelIO.MDLAnimatedScalar, Xamarin.Mac' */ },
		{ NULL, 0x5EE9C /* 'MDLAnimatedVector2' => 'ModelIO.MDLAnimatedVector2, Xamarin.Mac' */ },
		{ NULL, 0x5EF9C /* 'MDLAnimatedVector3' => 'ModelIO.MDLAnimatedVector3, Xamarin.Mac' */ },
		{ NULL, 0x5F09C /* 'MDLAnimatedVector4' => 'ModelIO.MDLAnimatedVector4, Xamarin.Mac' */ },
		{ NULL, 0x5F19C /* 'MDLAnimatedMatrix4x4' => 'ModelIO.MDLAnimatedMatrix4x4, Xamarin.Mac' */ },
		{ NULL, 0x5F29C /* 'MDLMatrix4x4Array' => 'ModelIO.MDLMatrix4x4Array, Xamarin.Mac' */ },
		{ NULL, 0x5F49C /* 'WebHistory' => 'WebKit.WebHistory, Xamarin.Mac' */ },
		{ NULL, 0x5F59C /* 'MDLAsset' => 'ModelIO.MDLAsset, Xamarin.Mac' */ },
		{ NULL, 0x5F69C /* 'CoreImage_CILinearToSRGBToneCurve' => 'CoreImage.CILinearToSRGBToneCurve, Xamarin.Mac' */ },
		{ NULL, 0x5F79C /* 'AVMutableCompositionTrack' => 'AVFoundation.AVMutableCompositionTrack, Xamarin.Mac' */ },
		{ NULL, 0x12959C /* 'MDLTexture' => 'ModelIO.MDLTexture, Xamarin.Mac' */ },
		{ NULL, 0x5FA9C /* 'MDLNoiseTexture' => 'ModelIO.MDLNoiseTexture, Xamarin.Mac' */ },
		{ NULL, 0x5FE9C /* 'CoreImage_CILineOverlay' => 'CoreImage.CILineOverlay, Xamarin.Mac' */ },
		{ NULL, 0x5FF9C /* 'MDLTransform' => 'ModelIO.MDLTransform, Xamarin.Mac' */ },
		{ NULL, 0x6019C /* 'AVMutableDateRangeMetadataGroup' => 'AVFoundation.AVMutableDateRangeMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x6029C /* 'CoreImage_CILineScreen' => 'CoreImage.CILineScreen, Xamarin.Mac' */ },
		{ NULL, 0x6099C /* 'AVMutableMediaSelection' => 'AVFoundation.AVMutableMediaSelection, Xamarin.Mac' */ },
		{ NULL, 0x60A9C /* 'NSCollectionViewLayoutAttributes' => 'AppKit.NSCollectionViewLayoutAttributes, Xamarin.Mac' */ },
		{ NULL, 0x60F9C /* 'CoreImage_CILuminosityBlendMode' => 'CoreImage.CILuminosityBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x6119C /* 'MDLVertexDescriptor' => 'ModelIO.MDLVertexDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x6169C /* 'CoreImage_CIMaskedVariableBlur' => 'CoreImage.CIMaskedVariableBlur, Xamarin.Mac' */ },
		{ NULL, 0x5769C /* 'AVMetadataItem' => 'AVFoundation.AVMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0x6189C /* 'AVMutableMetadataItem' => 'AVFoundation.AVMutableMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0x6199C /* 'CoreImage_CIMaskToAlpha' => 'CoreImage.CIMaskToAlpha, Xamarin.Mac' */ },
		{ NULL, 0x6209C /* 'MCPeerID' => 'MultipeerConnectivity.MCPeerID, Xamarin.Mac' */ },
		{ NULL, 0x6219C /* 'MCAdvertiserAssistant' => 'MultipeerConnectivity.MCAdvertiserAssistant, Xamarin.Mac' */ },
		{ NULL, 0x6229C /* 'CoreImage_CIMaximumComponent' => 'CoreImage.CIMaximumComponent, Xamarin.Mac' */ },
		{ NULL, 0x6239C /* 'MTKMeshBuffer' => 'MetalKit.MTKMeshBuffer, Xamarin.Mac' */ },
		{ NULL, 0x62C9C /* 'CoreImage_CIMaximumCompositing' => 'CoreImage.CIMaximumCompositing, Xamarin.Mac' */ },
		{ NULL, 0x62E9C /* 'CoreImage_CIMedianFilter' => 'CoreImage.CIMedianFilter, Xamarin.Mac' */ },
		{ NULL, 0x6339C /* 'AVMutableMovie' => 'AVFoundation.AVMutableMovie, Xamarin.Mac' */ },
		{ NULL, 0x6379C /* 'CoreImage_CIMinimumComponent' => 'CoreImage.CIMinimumComponent, Xamarin.Mac' */ },
		{ NULL, 0x6389C /* 'NSURLAuthenticationChallenge' => 'Foundation.NSUrlAuthenticationChallenge, Xamarin.Mac' */ },
		{ NULL, 0x6399C /* 'NSCollectionViewTransitionLayout' => 'AppKit.NSCollectionViewTransitionLayout, Xamarin.Mac' */ },
		{ NULL, 0x63C9C /* 'CoreImage_CIMinimumCompositing' => 'CoreImage.CIMinimumCompositing, Xamarin.Mac' */ },
		{ NULL, 0x63E9C /* 'CoreImage_CIModTransition' => 'CoreImage.CIModTransition, Xamarin.Mac' */ },
		{ NULL, 0x63F9C /* 'NSCollectionViewUpdateItem' => 'AppKit.NSCollectionViewUpdateItem, Xamarin.Mac' */ },
		{ NULL, 0x6419C /* 'MTKSubmesh' => 'MetalKit.MTKSubmesh, Xamarin.Mac' */ },
		{ NULL, 0x6469C /* 'NSColorPickerTouchBarItem' => 'AppKit.NSColorPickerTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x6489C /* 'CoreImage_CIMorphology' => 'CoreImage.CIMorphology, Xamarin.Mac' */ },
		{ NULL, 0x6499C /* 'WebPreferences' => 'WebKit.WebPreferences, Xamarin.Mac' */ },
		{ NULL, 0x64A9C /* 'CoreImage_CIMorphologyGradient' => 'CoreImage.CIMorphologyGradient, Xamarin.Mac' */ },
		{ NULL, 0x64C9C /* 'CoreImage_CIMorphologyMaximum' => 'CoreImage.CIMorphologyMaximum, Xamarin.Mac' */ },
		{ NULL, 0x64D9C /* 'WebResource' => 'WebKit.WebResource, Xamarin.Mac' */ },
		{ NULL, 0x64E9C /* 'NSColorSpace' => 'AppKit.NSColorSpace, Xamarin.Mac' */ },
		{ NULL, 0x64F9C /* 'CoreImage_CIMorphologyMinimum' => 'CoreImage.CIMorphologyMinimum, Xamarin.Mac' */ },
		{ NULL, 0x6509C /* 'AVMutableMovieTrack' => 'AVFoundation.AVMutableMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x6519C /* 'CoreImage_CIMotionBlur' => 'CoreImage.CIMotionBlur, Xamarin.Mac' */ },
		{ NULL, 0x6539C /* 'NSColorWell' => 'AppKit.NSColorWell, Xamarin.Mac' */ },
		{ NULL, 0x6549C /* 'CoreImage_CIMultiplyBlendMode' => 'CoreImage.CIMultiplyBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x65C9C /* 'CoreImage_CIMultiplyCompositing' => 'CoreImage.CIMultiplyCompositing, Xamarin.Mac' */ },
		{ NULL, 0x65F9C /* 'NSURLComponents' => 'Foundation.NSUrlComponents, Xamarin.Mac' */ },
		{ NULL, 0x6609C /* 'CoreImage_CINinePartStretched' => 'CoreImage.CINinePartStretched, Xamarin.Mac' */ },
		{ NULL, 0xC8A9C /* 'AVTimedMetadataGroup' => 'AVFoundation.AVTimedMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x6629C /* 'AVMutableTimedMetadataGroup' => 'AVFoundation.AVMutableTimedMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x6639C /* 'CoreImage_CINinePartTiled' => 'CoreImage.CINinePartTiled, Xamarin.Mac' */ },
		{ NULL, 0x6689C /* 'CoreImage_CINoiseReduction' => 'CoreImage.CINoiseReduction, Xamarin.Mac' */ },
		{ NULL, 0x66B9C /* 'CoreImage_CIOpTile' => 'CoreImage.CIOpTile, Xamarin.Mac' */ },
		{ NULL, 0x66E9C /* 'CoreImage_CIOverlayBlendMode' => 'CoreImage.CIOverlayBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xCD49C /* 'AVVideoComposition' => 'AVFoundation.AVVideoComposition, Xamarin.Mac' */ },
		{ NULL, 0x66F9C /* 'AVMutableVideoComposition' => 'AVFoundation.AVMutableVideoComposition, Xamarin.Mac' */ },
		{ NULL, 0x6709C /* 'CoreImage_CIPageCurlTransition' => 'CoreImage.CIPageCurlTransition, Xamarin.Mac' */ },
		{ NULL, 0x6719C /* 'CoreImage_CIPageCurlWithShadowTransition' => 'CoreImage.CIPageCurlWithShadowTransition, Xamarin.Mac' */ },
		{ NULL, 0xCE69C /* 'AVVideoCompositionInstruction' => 'AVFoundation.AVVideoCompositionInstruction, Xamarin.Mac' */ },
		{ NULL, 0x6769C /* 'AVMutableVideoCompositionInstruction' => 'AVFoundation.AVMutableVideoCompositionInstruction, Xamarin.Mac' */ },
		{ NULL, 0x6779C /* 'CoreImage_CIParallelogramTile' => 'CoreImage.CIParallelogramTile, Xamarin.Mac' */ },
		{ NULL, 0x6789C /* 'CoreImage_CIPdf417BarcodeGenerator' => 'CoreImage.CIPdf417BarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCED9C /* 'AVVideoCompositionLayerInstruction' => 'AVFoundation.AVVideoCompositionLayerInstruction, Xamarin.Mac' */ },
		{ NULL, 0x6799C /* 'AVMutableVideoCompositionLayerInstruction' => 'AVFoundation.AVMutableVideoCompositionLayerInstruction, Xamarin.Mac' */ },
		{ NULL, 0x67C9C /* 'NSComboBoxCell' => 'AppKit.NSComboBoxCell, Xamarin.Mac' */ },
		{ NULL, 0x67D9C /* 'CIPDF417CodeDescriptor' => 'CoreImage.CIPdf417CodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x6829C /* 'MTKView' => 'MetalKit.MTKView, Xamarin.Mac' */ },
		{ NULL, 0x68E9C /* 'CoreImage_CIPerspectiveTransform' => 'CoreImage.CIPerspectiveTransform, Xamarin.Mac' */ },
		{ NULL, 0x6839C /* 'CoreImage_CIPerspectiveCorrection' => 'CoreImage.CIPerspectiveCorrection, Xamarin.Mac' */ },
		{ NULL, 0x6849C /* 'AVOutputSettingsAssistant' => 'AVFoundation.AVOutputSettingsAssistant, Xamarin.Mac' */ },
		{ NULL, 0x6859C /* 'CoreImage_CIPerspectiveTile' => 'CoreImage.CIPerspectiveTile, Xamarin.Mac' */ },
		{ NULL, 0x68D9C /* 'NSColorList' => 'AppKit.NSColorList, Xamarin.Mac' */ },
		{ NULL, 0x4079C /* 'AVContentKeyRequest' => 'AVFoundation.AVContentKeyRequest, Xamarin.Mac' */ },
		{ NULL, 0x68F9C /* 'AVPersistableContentKeyRequest' => 'AVFoundation.AVPersistableContentKeyRequest, Xamarin.Mac' */ },
		{ NULL, 0x6999C /* 'CoreImage_CIPerspectiveTransformWithExtent' => 'CoreImage.CIPerspectiveTransformWithExtent, Xamarin.Mac' */ },
		{ NULL, 0x69B9C /* 'CoreImage_CIPhotoEffect' => 'CoreImage.CIPhotoEffect, Xamarin.Mac' */ },
		{ NULL, 0x69C9C /* 'NSURLCredential' => 'Foundation.NSUrlCredential, Xamarin.Mac' */ },
		{ NULL, 0x69D9C /* 'CoreImage_CIPhotoEffectChrome' => 'CoreImage.CIPhotoEffectChrome, Xamarin.Mac' */ },
		{ NULL, 0x6A29C /* 'MPSBinaryImageKernel' => 'MetalPerformanceShaders.MPSBinaryImageKernel, Xamarin.Mac' */ },
		{ NULL, 0x6A59C /* 'CoreImage_CIPhotoEffectFade' => 'CoreImage.CIPhotoEffectFade, Xamarin.Mac' */ },
		{ NULL, 0x6A69C /* 'CoreImage_CIPhotoEffectInstant' => 'CoreImage.CIPhotoEffectInstant, Xamarin.Mac' */ },
		{ NULL, 0x6AD9C /* 'CoreImage_CIPhotoEffectMono' => 'CoreImage.CIPhotoEffectMono, Xamarin.Mac' */ },
		{ NULL, 0xF5D9C /* 'MPSNNFilterNode' => 'MetalPerformanceShaders.MPSNNFilterNode, Xamarin.Mac' */ },
		{ NULL, 0x7189C /* 'MPSCNNConvolutionNode' => 'MetalPerformanceShaders.MPSCnnConvolutionNode, Xamarin.Mac' */ },
		{ NULL, 0x6AE9C /* 'MPSCNNBinaryConvolutionNode' => 'MetalPerformanceShaders.MPSCnnBinaryConvolutionNode, Xamarin.Mac' */ },
		{ NULL, 0x6AF9C /* 'NSColorPicker' => 'AppKit.NSColorPicker, Xamarin.Mac' */ },
		{ NULL, 0x6B09C /* 'CoreImage_CIPhotoEffectNoir' => 'CoreImage.CIPhotoEffectNoir, Xamarin.Mac' */ },
		{ NULL, 0x6B29C /* 'CoreImage_CIPhotoEffectProcess' => 'CoreImage.CIPhotoEffectProcess, Xamarin.Mac' */ },
		{ NULL, 0x6B39C /* 'CoreImage_CIPhotoEffectTonal' => 'CoreImage.CIPhotoEffectTonal, Xamarin.Mac' */ },
		{ NULL, 0x6B59C /* 'MPSCNNBinaryFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnectedNode, Xamarin.Mac' */ },
		{ NULL, 0x6B69C /* 'CoreImage_CIPhotoEffectTransfer' => 'CoreImage.CIPhotoEffectTransfer, Xamarin.Mac' */ },
		{ NULL, 0x6B89C /* 'CoreImage_CIPinchDistortion' => 'CoreImage.CIPinchDistortion, Xamarin.Mac' */ },
		{ NULL, 0x6B99C /* 'CoreImage_CIPinLightBlendMode' => 'CoreImage.CIPinLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x6BD9C /* 'CoreImage_CIPixellate' => 'CoreImage.CIPixellate, Xamarin.Mac' */ },
		{ NULL, 0x6BE9C /* 'CIPlugIn' => 'CoreImage.CIPlugIn, Xamarin.Mac' */ },
		{ NULL, 0x6BF9C /* 'CoreImage_CIPointillize' => 'CoreImage.CIPointillize, Xamarin.Mac' */ },
		{ NULL, 0x6C49C /* 'MPSCNNBinaryKernel' => 'MetalPerformanceShaders.MPSCnnBinaryKernel, Xamarin.Mac' */ },
		{ NULL, 0x6C89C /* 'CIQRCodeDescriptor' => 'CoreImage.CIQRCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x6C99C /* 'NSURLProtectionSpace' => 'Foundation.NSUrlProtectionSpace, Xamarin.Mac' */ },
		{ NULL, 0x6CB9C /* 'CIQRCodeFeature' => 'CoreImage.CIQRCodeFeature, Xamarin.Mac' */ },
		{ NULL, 0x6CC9C /* 'CoreImage_CIQRCodeGenerator' => 'CoreImage.CIQRCodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0x6CF9C /* 'MPSCNNConvolution' => 'MetalPerformanceShaders.MPSCnnConvolution, Xamarin.Mac' */ },
		{ NULL, 0x6D09C /* 'NSURLProtocol' => 'Foundation.NSUrlProtocol, Xamarin.Mac' */ },
		{ NULL, 0x6D19C /* 'CoreImage_CIRadialGradient' => 'CoreImage.CIRadialGradient, Xamarin.Mac' */ },
		{ NULL, 0x6DA9C /* 'NSURLQueryItem' => 'Foundation.NSUrlQueryItem, Xamarin.Mac' */ },
		{ NULL, 0x6DB9C /* 'CoreImage_CIRandomGenerator' => 'CoreImage.CIRandomGenerator, Xamarin.Mac' */ },
		{ NULL, 0x6E29C /* 'NSDictionaryController' => 'AppKit.NSDictionaryController, Xamarin.Mac' */ },
		{ NULL, 0x6E39C /* 'AVPlayerItemAccessLog' => 'AVFoundation.AVPlayerItemAccessLog, Xamarin.Mac' */ },
		{ NULL, 0x6E59C /* 'NSCursor' => 'AppKit.NSCursor, Xamarin.Mac' */ },
		{ NULL, 0x6E79C /* 'NSDictionaryControllerKeyValuePair' => 'AppKit.NSDictionaryControllerKeyValuePair, Xamarin.Mac' */ },
		{ NULL, 0x6E89C /* 'NSURLResponse' => 'Foundation.NSUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x6E99C /* 'NSCustomImageRep' => 'AppKit.NSCustomImageRep, Xamarin.Mac' */ },
		{ NULL, 0x6EB9C /* 'AVPlayerItemAccessLogEvent' => 'AVFoundation.AVPlayerItemAccessLogEvent, Xamarin.Mac' */ },
		{ NULL, 0x7169C /* 'NSDockTile' => 'AppKit.NSDockTile, Xamarin.Mac' */ },
		{ NULL, 0x7179C /* 'NSCustomTouchBarItem' => 'AppKit.NSCustomTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x7199C /* 'AVPlayerItemErrorLog' => 'AVFoundation.AVPlayerItemErrorLog, Xamarin.Mac' */ },
		{ NULL, 0x71B9C /* 'CIRectangleFeature' => 'CoreImage.CIRectangleFeature, Xamarin.Mac' */ },
		{ NULL, 0x71F9C /* 'NSDataAsset' => 'AppKit.NSDataAsset, Xamarin.Mac' */ },
		{ NULL, 0xFF39C /* 'MPSState' => 'MetalPerformanceShaders.MPSState, Xamarin.Mac' */ },
		{ NULL, 0x7209C /* 'MPSCNNConvolutionState' => 'MetalPerformanceShaders.MPSCnnConvolutionState, Xamarin.Mac' */ },
		{ NULL, 0x7219C /* 'WKBackForwardList' => 'WebKit.WKBackForwardList, Xamarin.Mac' */ },
		{ NULL, 0xF9D9C /* 'MPSNNStateNode' => 'MetalPerformanceShaders.MPSNNStateNode, Xamarin.Mac' */ },
		{ NULL, 0x7229C /* 'MPSCNNConvolutionStateNode' => 'MetalPerformanceShaders.MPSCnnConvolutionStateNode, Xamarin.Mac' */ },
		{ NULL, 0x7239C /* 'AVPlayerItemErrorLogEvent' => 'AVFoundation.AVPlayerItemErrorLogEvent, Xamarin.Mac' */ },
		{ NULL, 0x7249C /* 'WKBackForwardListItem' => 'WebKit.WKBackForwardListItem, Xamarin.Mac' */ },
		{ NULL, 0x7259C /* 'CIRenderDestination' => 'CoreImage.CIRenderDestination, Xamarin.Mac' */ },
		{ NULL, 0x7269C /* 'MPSCNNConvolutionTranspose' => 'MetalPerformanceShaders.MPSCnnConvolutionTranspose, Xamarin.Mac' */ },
		{ NULL, 0x72D9C /* 'WKContentRuleList' => 'WebKit.WKContentRuleList, Xamarin.Mac' */ },
		{ NULL, 0x7769C /* 'AVPlayerItemOutput' => 'AVFoundation.AVPlayerItemOutput, Xamarin.Mac' */ },
		{ NULL, 0x72E9C /* 'AVPlayerItemLegibleOutput' => 'AVFoundation.AVPlayerItemLegibleOutput, Xamarin.Mac' */ },
		{ NULL, 0x72F9C /* 'CIRenderInfo' => 'CoreImage.CIRenderInfo, Xamarin.Mac' */ },
		{ NULL, 0x7309C /* 'MPSCNNConvolutionTransposeNode' => 'MetalPerformanceShaders.MPSCnnConvolutionTransposeNode, Xamarin.Mac' */ },
		{ NULL, 0x7359C /* 'CIRenderTask' => 'CoreImage.CIRenderTask, Xamarin.Mac' */ },
		{ NULL, 0x7379C /* 'AVPlayerItemMediaDataCollector' => 'AVFoundation.AVPlayerItemMediaDataCollector, Xamarin.Mac' */ },
		{ NULL, 0x7389C /* 'MPSCNNCrossChannelNormalization' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalization, Xamarin.Mac' */ },
		{ NULL, 0x7399C /* 'CoreImage_CIRippleTransition' => 'CoreImage.CIRippleTransition, Xamarin.Mac' */ },
		{ NULL, 0x73C9C /* 'CoreImage_CIRowAverage' => 'CoreImage.CIRowAverage, Xamarin.Mac' */ },
		{ NULL, 0x8269C /* 'MPSCNNNormalizationNode' => 'MetalPerformanceShaders.MPSCnnNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x73D9C /* 'MPSCNNCrossChannelNormalizationNode' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x73E9C /* 'AVPlayerItemMetadataCollector' => 'AVFoundation.AVPlayerItemMetadataCollector, Xamarin.Mac' */ },
		{ NULL, 0x73F9C /* 'WKFrameInfo' => 'WebKit.WKFrameInfo, Xamarin.Mac' */ },
		{ NULL, 0x7409C /* 'MPSCNNDepthWiseConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnDepthWiseConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7419C /* 'CoreImage_CISaturationBlendMode' => 'CoreImage.CISaturationBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x7429C /* 'NSURLSessionConfiguration' => 'Foundation.NSUrlSessionConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x82D9C /* 'MPSCNNPooling' => 'MetalPerformanceShaders.MPSCnnPooling, Xamarin.Mac' */ },
		{ NULL, 0x7439C /* 'MPSCNNDilatedPoolingMax' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMax, Xamarin.Mac' */ },
		{ NULL, 0x74C9C /* 'CoreImage_CIScreenBlendMode' => 'CoreImage.CIScreenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x7519C /* 'MPSCNNDilatedPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x7529C /* 'CoreImage_CISepiaTone' => 'CoreImage.CISepiaTone, Xamarin.Mac' */ },
		{ NULL, 0x7579C /* 'CoreImage_CIShadedMaterial' => 'CoreImage.CIShadedMaterial, Xamarin.Mac' */ },
		{ NULL, 0x7589C /* 'MPSCNNFullyConnected' => 'MetalPerformanceShaders.MPSCnnFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0x7929C /* 'NSURLSessionTask' => 'Foundation.NSUrlSessionTask, Xamarin.Mac' */ },
		{ NULL, 0x7599C /* 'NSURLSessionDataTask' => 'Foundation.NSUrlSessionDataTask, Xamarin.Mac' */ },
		{ NULL, 0x75A9C /* 'CoreImage_CISharpenLuminance' => 'CoreImage.CISharpenLuminance, Xamarin.Mac' */ },
		{ NULL, 0x75B9C /* 'WKNavigation' => 'WebKit.WKNavigation, Xamarin.Mac' */ },
		{ NULL, 0x75C9C /* 'AVPlayerItemMetadataOutput' => 'AVFoundation.AVPlayerItemMetadataOutput, Xamarin.Mac' */ },
		{ NULL, 0x75D9C /* 'MPSCNNFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnFullyConnectedNode, Xamarin.Mac' */ },
		{ NULL, 0x75E9C /* 'CoreImage_CISixfoldReflectedTile' => 'CoreImage.CISixfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0x75F9C /* 'CoreImage_CISixfoldRotatedTile' => 'CoreImage.CISixfoldRotatedTile, Xamarin.Mac' */ },
		{ NULL, 0x7649C /* 'CoreImage_CISmoothLinearGradient' => 'CoreImage.CISmoothLinearGradient, Xamarin.Mac' */ },
		{ NULL, 0x7659C /* 'CoreImage_CISoftLightBlendMode' => 'CoreImage.CISoftLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x76E9C /* 'CoreImage_CISourceAtopCompositing' => 'CoreImage.CISourceAtopCompositing, Xamarin.Mac' */ },
		{ NULL, 0x7709C /* 'NSURLSessionDownloadTask' => 'Foundation.NSUrlSessionDownloadTask, Xamarin.Mac' */ },
		{ NULL, 0x7729C /* 'CoreImage_CISourceInCompositing' => 'CoreImage.CISourceInCompositing, Xamarin.Mac' */ },
		{ NULL, 0x7739C /* 'WKNavigationAction' => 'WebKit.WKNavigationAction, Xamarin.Mac' */ },
		{ NULL, 0x7749C /* 'CoreImage_CISourceOutCompositing' => 'CoreImage.CISourceOutCompositing, Xamarin.Mac' */ },
		{ NULL, 0x7759C /* 'NSEPSImageRep' => 'AppKit.NSEPSImageRep, Xamarin.Mac' */ },
		{ NULL, 0x77B9C /* 'MPSCNNLocalContrastNormalization' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalization, Xamarin.Mac' */ },
		{ NULL, 0x77D9C /* 'CoreImage_CISourceOverCompositing' => 'CoreImage.CISourceOverCompositing, Xamarin.Mac' */ },
		{ NULL, 0x7829C /* 'CoreImage_CISpotColor' => 'CoreImage.CISpotColor, Xamarin.Mac' */ },
		{ NULL, 0x7859C /* 'MPSCNNLocalContrastNormalizationNode' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x78A9C /* 'CoreImage_CISpotLight' => 'CoreImage.CISpotLight, Xamarin.Mac' */ },
		{ NULL, 0x78B9C /* 'MPSCNNLogSoftMax' => 'MetalPerformanceShaders.MPSCnnLogSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x7919C /* 'CoreImage_CISRGBToneCurveToLinear' => 'CoreImage.CISRGBToneCurveToLinear, Xamarin.Mac' */ },
		{ NULL, 0x7939C /* 'MPSCNNLogSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x7949C /* 'WKNavigationResponse' => 'WebKit.WKNavigationResponse, Xamarin.Mac' */ },
		{ NULL, 0x7959C /* 'CoreImage_CIStarShineGenerator' => 'CoreImage.CIStarShineGenerator, Xamarin.Mac' */ },
		{ NULL, 0x7969C /* 'NSDocumentController' => 'AppKit.NSDocumentController, Xamarin.Mac' */ },
		{ NULL, 0x7989C /* 'AVPlayerItemTrack' => 'AVFoundation.AVPlayerItemTrack, Xamarin.Mac' */ },
		{ NULL, 0x79A9C /* 'CoreImage_CIStraightenFilter' => 'CoreImage.CIStraightenFilter, Xamarin.Mac' */ },
		{ NULL, 0x79C9C /* 'MPSCNNNeuronAbsolute' => 'MetalPerformanceShaders.MPSCnnNeuronAbsolute, Xamarin.Mac' */ },
		{ NULL, 0x7A19C /* 'CoreImage_CIStretchCrop' => 'CoreImage.CIStretchCrop, Xamarin.Mac' */ },
		{ NULL, 0x7A39C /* 'WKOpenPanelParameters' => 'WebKit.WKOpenPanelParameters, Xamarin.Mac' */ },
		{ NULL, 0x7D69C /* 'MPSCNNNeuronNode' => 'MetalPerformanceShaders.MPSCnnNeuronNode, Xamarin.Mac' */ },
		{ NULL, 0x7A99C /* 'MPSCNNNeuronAbsoluteNode' => 'MetalPerformanceShaders.MPSCnnNeuronAbsoluteNode, Xamarin.Mac' */ },
		{ NULL, 0x7AA9C /* 'CoreImage_CIStripesGenerator' => 'CoreImage.CIStripesGenerator, Xamarin.Mac' */ },
		{ NULL, 0x7AB9C /* 'NSURLSessionTaskMetrics' => 'Foundation.NSUrlSessionTaskMetrics, Xamarin.Mac' */ },
		{ NULL, 0x7AD9C /* 'MPSCNNNeuronELU' => 'MetalPerformanceShaders.MPSCnnNeuronElu, Xamarin.Mac' */ },
		{ NULL, 0x7AF9C /* 'CoreImage_CISubtractBlendMode' => 'CoreImage.CISubtractBlendMode, Xamarin.Mac' */ },
		{ NULL, 0x7B19C /* 'WKPreferences' => 'WebKit.WKPreferences, Xamarin.Mac' */ },
		{ NULL, 0x7B39C /* 'NSDraggingImageComponent' => 'AppKit.NSDraggingImageComponent, Xamarin.Mac' */ },
		{ NULL, 0x7B49C /* 'MPSCNNNeuronELUNode' => 'MetalPerformanceShaders.MPSCnnNeuronEluNode, Xamarin.Mac' */ },
		{ NULL, 0x7B59C /* 'CoreImage_CISunbeamsGenerator' => 'CoreImage.CISunbeamsGenerator, Xamarin.Mac' */ },
		{ NULL, 0x7B69C /* 'WKProcessPool' => 'WebKit.WKProcessPool, Xamarin.Mac' */ },
		{ NULL, 0x7B79C /* 'MPSCNNNeuronHardSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoid, Xamarin.Mac' */ },
		{ NULL, 0x7B89C /* 'NSFilePromiseProvider' => 'AppKit.NSFilePromiseProvider, Xamarin.Mac' */ },
		{ NULL, 0x7B99C /* 'AVPlayerLayer' => 'AVFoundation.AVPlayerLayer, Xamarin.Mac' */ },
		{ NULL, 0x7BA9C /* 'CoreImage_CISwipeTransition' => 'CoreImage.CISwipeTransition, Xamarin.Mac' */ },
		{ NULL, 0x7BB9C /* 'NSURLSessionTaskTransactionMetrics' => 'Foundation.NSUrlSessionTaskTransactionMetrics, Xamarin.Mac' */ },
		{ NULL, 0x7BC9C /* 'WKScriptMessage' => 'WebKit.WKScriptMessage, Xamarin.Mac' */ },
		{ NULL, 0x7BD9C /* 'MPSCNNNeuronHardSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoidNode, Xamarin.Mac' */ },
		{ NULL, 0x7C19C /* 'CoreImage_CITemperatureAndTint' => 'CoreImage.CITemperatureAndTint, Xamarin.Mac' */ },
		{ NULL, 0x7C29C /* 'NSURLSessionUploadTask' => 'Foundation.NSUrlSessionUploadTask, Xamarin.Mac' */ },
		{ NULL, 0x7C69C /* 'AVPlayerLooper' => 'AVFoundation.AVPlayerLooper, Xamarin.Mac' */ },
		{ NULL, 0x7C79C /* 'MPSCNNNeuronLinear' => 'MetalPerformanceShaders.MPSCnnNeuronLinear, Xamarin.Mac' */ },
		{ NULL, 0x7C99C /* 'WKSecurityOrigin' => 'WebKit.WKSecurityOrigin, Xamarin.Mac' */ },
		{ NULL, 0x7CB9C /* 'CITextFeature' => 'CoreImage.CITextFeature, Xamarin.Mac' */ },
		{ NULL, 0x7D09C /* 'NSFilePromiseReceiver' => 'AppKit.NSFilePromiseReceiver, Xamarin.Mac' */ },
		{ NULL, 0x7D19C /* 'MPSCNNNeuronLinearNode' => 'MetalPerformanceShaders.MPSCnnNeuronLinearNode, Xamarin.Mac' */ },
		{ NULL, 0x7D49C /* 'CoreImage_CITextImageGenerator' => 'CoreImage.CITextImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0x7D59C /* 'AVPlayerMediaSelectionCriteria' => 'AVFoundation.AVPlayerMediaSelectionCriteria, Xamarin.Mac' */ },
		{ NULL, 0x7D79C /* 'NSDraggingItem' => 'AppKit.NSDraggingItem, Xamarin.Mac' */ },
		{ NULL, 0x7D89C /* 'WKSnapshotConfiguration' => 'WebKit.WKSnapshotConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x7DA9C /* 'CoreImage_CIThermal' => 'CoreImage.CIThermal, Xamarin.Mac' */ },
		{ NULL, 0x7DC9C /* 'NSDraggingSession' => 'AppKit.NSDraggingSession, Xamarin.Mac' */ },
		{ NULL, 0x7DE9C /* 'MPSCNNNeuronPReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronPReLUNode, Xamarin.Mac' */ },
		{ NULL, 0x7DF9C /* 'CoreImage_CIToneCurve' => 'CoreImage.CIToneCurve, Xamarin.Mac' */ },
		{ NULL, 0x7E09C /* 'MPSCNNNeuronReLU' => 'MetalPerformanceShaders.MPSCnnNeuronReLU, Xamarin.Mac' */ },
		{ NULL, 0x7E39C /* 'CoreImage_CITorusLensDistortion' => 'CoreImage.CITorusLensDistortion, Xamarin.Mac' */ },
		{ NULL, 0x7EF9C /* 'MPSCNNNeuronReLUN' => 'MetalPerformanceShaders.MPSCnnNeuronReLun, Xamarin.Mac' */ },
		{ NULL, 0x6B49C /* 'AVPlayer' => 'AVFoundation.AVPlayer, Xamarin.Mac' */ },
		{ NULL, 0x7F39C /* 'AVQueuePlayer' => 'AVFoundation.AVQueuePlayer, Xamarin.Mac' */ },
		{ NULL, 0x7F49C /* 'MPSCNNNeuronReLUNNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLunNode, Xamarin.Mac' */ },
		{ NULL, 0x7F59C /* 'CoreImage_CITriangleKaleidoscope' => 'CoreImage.CITriangleKaleidoscope, Xamarin.Mac' */ },
		{ NULL, 0x7FC9C /* 'CoreImage_CITriangleTile' => 'CoreImage.CITriangleTile, Xamarin.Mac' */ },
		{ NULL, 0x7FF9C /* 'MPSCNNNeuronReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLUNode, Xamarin.Mac' */ },
		{ NULL, 0x8019C /* 'WKUserContentController' => 'WebKit.WKUserContentController, Xamarin.Mac' */ },
		{ NULL, 0x8029C /* 'CoreImage_CITwelvefoldReflectedTile' => 'CoreImage.CITwelvefoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0x8039C /* 'MPSCNNNeuronSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoid, Xamarin.Mac' */ },
		{ NULL, 0x8049C /* 'CoreImage_CITwirlDistortion' => 'CoreImage.CITwirlDistortion, Xamarin.Mac' */ },
		{ NULL, 0x8079C /* 'WKUserScript' => 'WebKit.WKUserScript, Xamarin.Mac' */ },
		{ NULL, 0x80B9C /* 'MPSCNNNeuronSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoidNode, Xamarin.Mac' */ },
		{ NULL, 0x80D9C /* 'CoreImage_CIUnsharpMask' => 'CoreImage.CIUnsharpMask, Xamarin.Mac' */ },
		{ NULL, 0x80E9C /* 'MPSCNNNeuronSoftPlus' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlus, Xamarin.Mac' */ },
		{ NULL, 0x80F9C /* 'NSFontAssetRequest' => 'AppKit.NSFontAssetRequest, Xamarin.Mac' */ },
		{ NULL, 0x8109C /* 'WKWebsiteDataRecord' => 'WebKit.WKWebsiteDataRecord, Xamarin.Mac' */ },
		{ NULL, 0x8139C /* 'MPSCNNNeuronSoftPlusNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlusNode, Xamarin.Mac' */ },
		{ NULL, 0x8149C /* 'MPSCNNNeuronSoftSign' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSign, Xamarin.Mac' */ },
		{ NULL, 0x8199C /* 'MPSCNNNeuronSoftSignNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSignNode, Xamarin.Mac' */ },
		{ NULL, 0x81A9C /* 'CoreImage_CIVibrance' => 'CoreImage.CIVibrance, Xamarin.Mac' */ },
		{ NULL, 0x81C9C /* 'MPSCNNNeuronTanH' => 'MetalPerformanceShaders.MPSCnnNeuronTanH, Xamarin.Mac' */ },
		{ NULL, 0x81E9C /* 'CoreImage_CIVignette' => 'CoreImage.CIVignette, Xamarin.Mac' */ },
		{ NULL, 0x81F9C /* 'MPSCNNNeuronTanHNode' => 'MetalPerformanceShaders.MPSCnnNeuronTanHNode, Xamarin.Mac' */ },
		{ NULL, 0x8209C /* 'CoreImage_CIVignetteEffect' => 'CoreImage.CIVignetteEffect, Xamarin.Mac' */ },
		{ NULL, 0x8239C /* 'AVSampleBufferRequest' => 'AVFoundation.AVSampleBufferRequest, Xamarin.Mac' */ },
		{ NULL, 0x8249C /* 'CoreImage_CIVortexDistortion' => 'CoreImage.CIVortexDistortion, Xamarin.Mac' */ },
		{ NULL, 0x8259C /* 'NSUserNotification' => 'Foundation.NSUserNotification, Xamarin.Mac' */ },
		{ NULL, 0x8289C /* 'NSUserNotificationAction' => 'Foundation.NSUserNotificationAction, Xamarin.Mac' */ },
		{ NULL, 0x8299C /* 'CIWarpKernel' => 'CoreImage.CIWarpKernel, Xamarin.Mac' */ },
		{ NULL, 0x82B9C /* 'NSFontDescriptor' => 'AppKit.NSFontDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xC5B9C /* 'CoreImage_CIWhitePointAdjust' => 'CoreImage.CIWhitePointAdjust, Xamarin.Mac' */ },
		{ NULL, 0xC5C9C /* 'CoreImage_CIXRay' => 'CoreImage.CIXRay, Xamarin.Mac' */ },
		{ NULL, 0xC5D9C /* 'PDFAction' => 'PdfKit.PdfAction, Xamarin.Mac' */ },
		{ NULL, 0xC5E9C /* 'CoreImage_CIZoomBlur' => 'CoreImage.CIZoomBlur, Xamarin.Mac' */ },
		{ NULL, 0xC639C /* 'WKWebViewConfiguration' => 'WebKit.WKWebViewConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xC649C /* 'MPSCNNPoolingAverage' => 'MetalPerformanceShaders.MPSCnnPoolingAverage, Xamarin.Mac' */ },
		{ NULL, 0xC659C /* 'PDFActionGoTo' => 'PdfKit.PdfActionGoTo, Xamarin.Mac' */ },
		{ NULL, 0xC669C /* 'AVSampleCursor' => 'AVFoundation.AVSampleCursor, Xamarin.Mac' */ },
		{ NULL, 0xCDE9C /* 'CLRegion' => 'CoreLocation.CLRegion, Xamarin.Mac' */ },
		{ NULL, 0xC679C /* 'CLCircularRegion' => 'CoreLocation.CLCircularRegion, Xamarin.Mac' */ },
		{ NULL, 0xC6C9C /* 'WKWindowFeatures' => 'WebKit.WKWindowFeatures, Xamarin.Mac' */ },
		{ NULL, 0xC889C /* 'MPSCNNPoolingNode' => 'MetalPerformanceShaders.MPSCnnPoolingNode, Xamarin.Mac' */ },
		{ NULL, 0xC6D9C /* 'MPSCNNPoolingAverageNode' => 'MetalPerformanceShaders.MPSCnnPoolingAverageNode, Xamarin.Mac' */ },
		{ NULL, 0xC6F9C /* 'PDFActionNamed' => 'PdfKit.PdfActionNamed, Xamarin.Mac' */ },
		{ NULL, 0xC709C /* 'NSFontManager' => 'AppKit.NSFontManager, Xamarin.Mac' */ },
		{ NULL, 0xC739C /* 'MPSCNNPoolingL2Norm' => 'MetalPerformanceShaders.MPSCnnPoolingL2Norm, Xamarin.Mac' */ },
		{ NULL, 0xC749C /* 'NSUUID' => 'Foundation.NSUuid, Xamarin.Mac' */ },
		{ NULL, 0xC769C /* 'NSFontPanel' => 'AppKit.NSFontPanel, Xamarin.Mac' */ },
		{ NULL, 0xC779C /* 'PDFActionRemoteGoTo' => 'PdfKit.PdfActionRemoteGoTo, Xamarin.Mac' */ },
		{ NULL, 0xC789C /* 'MPSCNNPoolingL2NormNode' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormNode, Xamarin.Mac' */ },
		{ NULL, 0xC799C /* 'AVAssetImageGenerator' => 'AVFoundation.AVAssetImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0x16F19C /* 'AVAssetReaderOutput' => 'AVFoundation.AVAssetReaderOutput, Xamarin.Mac' */ },
		{ NULL, 0xC7C9C /* 'AVAssetReaderVideoCompositionOutput' => 'AVFoundation.AVAssetReaderVideoCompositionOutput, Xamarin.Mac' */ },
		{ NULL, 0xC7D9C /* 'AVSynchronizedLayer' => 'AVFoundation.AVSynchronizedLayer, Xamarin.Mac' */ },
		{ NULL, 0xC7E9C /* 'PDFActionResetForm' => 'PdfKit.PdfActionResetForm, Xamarin.Mac' */ },
		{ NULL, 0xC7F9C /* 'MPSCNNPoolingMax' => 'MetalPerformanceShaders.MPSCnnPoolingMax, Xamarin.Mac' */ },
		{ NULL, 0xC809C /* 'AVAssetResourceLoadingDataRequest' => 'AVFoundation.AVAssetResourceLoadingDataRequest, Xamarin.Mac' */ },
		{ NULL, 0xC819C /* 'PDFActionURL' => 'PdfKit.PdfActionUrl, Xamarin.Mac' */ },
		{ NULL, 0xC829C /* 'AVAudioBuffer' => 'AVFoundation.AVAudioBuffer, Xamarin.Mac' */ },
		{ NULL, 0xC839C /* 'MPSCNNPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnPoolingMaxNode, Xamarin.Mac' */ },
		{ NULL, 0xC859C /* 'AVTextStyleRule' => 'AVFoundation.AVTextStyleRule, Xamarin.Mac' */ },
		{ NULL, 0xC869C /* 'AVAudioChannelLayout' => 'AVFoundation.AVAudioChannelLayout, Xamarin.Mac' */ },
		{ NULL, 0xDEE9C /* 'NSMatrix' => 'AppKit.NSMatrix, Xamarin.Mac' */ },
		{ NULL, 0xC879C /* 'NSForm' => 'AppKit.NSForm, Xamarin.Mac' */ },
		{ NULL, 0xC899C /* 'AVAudioFormat' => 'AVFoundation.AVAudioFormat, Xamarin.Mac' */ },
		{ NULL, 0xC8B9C /* 'NSValueTransformer' => 'Foundation.NSValueTransformer, Xamarin.Mac' */ },
		{ NULL, 0xC8D9C /* 'MPSCNNSoftMax' => 'MetalPerformanceShaders.MPSCnnSoftMax, Xamarin.Mac' */ },
		{ NULL, 0xC8E9C /* 'AVAudioPlayer' => 'AVFoundation.AVAudioPlayer, Xamarin.Mac' */ },
		{ NULL, 0xC8F9C /* 'NSXPCListenerEndpoint' => 'Foundation.NSXpcListenerEndpoint, Xamarin.Mac' */ },
		{ NULL, 0xC909C /* 'MPSCNNSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnSoftMaxNode, Xamarin.Mac' */ },
		{ NULL, 0xC929C /* 'NSFormCell' => 'AppKit.NSFormCell, Xamarin.Mac' */ },
		{ NULL, 0xC939C /* 'AVAudioRecorder' => 'AVFoundation.AVAudioRecorder, Xamarin.Mac' */ },
		{ NULL, 0xC949C /* 'MPSCNNSpatialNormalization' => 'MetalPerformanceShaders.MPSCnnSpatialNormalization, Xamarin.Mac' */ },
		{ NULL, 0xC979C /* 'MPSCNNSpatialNormalizationNode' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0xCB09C /* 'GCControllerElement' => 'GameController.GCControllerElement, Xamarin.Mac' */ },
		{ NULL, 0xC989C /* 'GCControllerAxisInput' => 'GameController.GCControllerAxisInput, Xamarin.Mac' */ },
		{ NULL, 0xC999C /* 'PDFAnnotation' => 'PdfKit.PdfAnnotation, Xamarin.Mac' */ },
		{ NULL, 0xC9A9C /* 'MPSCNNSubPixelConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnSubPixelConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xCA39C /* 'MPSCNNUpsampling' => 'MetalPerformanceShaders.MPSCnnUpsampling, Xamarin.Mac' */ },
		{ NULL, 0xCA49C /* 'GCControllerButtonInput' => 'GameController.GCControllerButtonInput, Xamarin.Mac' */ },
		{ NULL, 0xCA79C /* 'PDFAnnotationButtonWidget' => 'PdfKit.PdfAnnotationButtonWidget, Xamarin.Mac' */ },
		{ NULL, 0xCA89C /* 'MPSCNNUpsamplingBilinear' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinear, Xamarin.Mac' */ },
		{ NULL, 0xCAB9C /* 'GCControllerDirectionPad' => 'GameController.GCControllerDirectionPad, Xamarin.Mac' */ },
		{ NULL, 0xCAF9C /* 'MPSCNNUpsamplingBilinearNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearNode, Xamarin.Mac' */ },
		{ NULL, 0xCB19C /* 'PDFAnnotationChoiceWidget' => 'PdfKit.PdfAnnotationChoiceWidget, Xamarin.Mac' */ },
		{ NULL, 0xCB39C /* 'MPSCNNUpsamplingNearest' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearest, Xamarin.Mac' */ },
		{ NULL, 0xCBC9C /* 'PDFAnnotationCircle' => 'PdfKit.PdfAnnotationCircle, Xamarin.Mac' */ },
		{ NULL, 0xCBD9C /* 'MPSCNNUpsamplingNearestNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestNode, Xamarin.Mac' */ },
		{ NULL, 0xCC79C /* 'NSImageCell' => 'AppKit.NSImageCell, Xamarin.Mac' */ },
		{ NULL, 0xCCA9C /* 'NSGlyphGenerator' => 'AppKit.NSGlyphGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCCB9C /* 'PDFAnnotationFreeText' => 'PdfKit.PdfAnnotationFreeText, Xamarin.Mac' */ },
		{ NULL, 0xCCC9C /* 'CLPlacemark' => 'CoreLocation.CLPlacemark, Xamarin.Mac' */ },
		{ NULL, 0xFB39C /* 'MPSRNNDescriptor' => 'MetalPerformanceShaders.MPSRnnDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xCD59C /* 'MPSGRUDescriptor' => 'MetalPerformanceShaders.MPSGRUDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xCD99C /* 'NSGlyphInfo' => 'AppKit.NSGlyphInfo, Xamarin.Mac' */ },
		{ NULL, 0xCDA9C /* 'PDFAnnotationInk' => 'PdfKit.PdfAnnotationInk, Xamarin.Mac' */ },
		{ NULL, 0xCDB9C /* 'AVVideoCompositionCoreAnimationTool' => 'AVFoundation.AVVideoCompositionCoreAnimationTool, Xamarin.Mac' */ },
		{ NULL, 0xCE29C /* 'AVAudioConnectionPoint' => 'AVFoundation.AVAudioConnectionPoint, Xamarin.Mac' */ },
		{ NULL, 0xCE39C /* 'GCMotion' => 'GameController.GCMotion, Xamarin.Mac' */ },
		{ NULL, 0xCE59C /* 'NSGradient' => 'AppKit.NSGradient, Xamarin.Mac' */ },
		{ NULL, 0xCE99C /* 'MPSImage' => 'MetalPerformanceShaders.MPSImage, Xamarin.Mac' */ },
		{ NULL, 0xCFE9C /* 'MPSImageArithmetic' => 'MetalPerformanceShaders.MPSImageArithmetic, Xamarin.Mac' */ },
		{ NULL, 0xCEB9C /* 'MPSImageAdd' => 'MetalPerformanceShaders.MPSImageAdd, Xamarin.Mac' */ },
		{ NULL, 0xCEC9C /* 'PDFAnnotationLine' => 'PdfKit.PdfAnnotationLine, Xamarin.Mac' */ },
		{ NULL, 0xCF09C /* 'NSGraphicsContext' => 'AppKit.NSGraphicsContext, Xamarin.Mac' */ },
		{ NULL, 0xCF59C /* 'MPSImageAreaMax' => 'MetalPerformanceShaders.MPSImageAreaMax, Xamarin.Mac' */ },
		{ NULL, 0xCF89C /* 'AVVideoCompositionRenderContext' => 'AVFoundation.AVVideoCompositionRenderContext, Xamarin.Mac' */ },
		{ NULL, 0xCF99C /* 'MPSImageAreaMin' => 'MetalPerformanceShaders.MPSImageAreaMin, Xamarin.Mac' */ },
		{ NULL, 0xCFA9C /* 'PDFAnnotationLink' => 'PdfKit.PdfAnnotationLink, Xamarin.Mac' */ },
		{ NULL, 0xD259C /* 'GKChallenge' => 'GameKit.GKChallenge, Xamarin.Mac' */ },
		{ NULL, 0xCFB9C /* 'GKAchievementChallenge' => 'GameKit.GKAchievementChallenge, Xamarin.Mac' */ },
		{ NULL, 0xCFC9C /* 'NSGridCell' => 'AppKit.NSGridCell, Xamarin.Mac' */ },
		{ NULL, 0xCFF9C /* 'PDFAnnotationMarkup' => 'PdfKit.PdfAnnotationMarkup, Xamarin.Mac' */ },
		{ NULL, 0xDCB9C /* 'MPSImageScale' => 'MetalPerformanceShaders.MPSImageScale, Xamarin.Mac' */ },
		{ NULL, 0xD089C /* 'MPSImageBilinearScale' => 'MetalPerformanceShaders.MPSImageBilinearScale, Xamarin.Mac' */ },
		{ NULL, 0xD0A9C /* 'NSGridColumn' => 'AppKit.NSGridColumn, Xamarin.Mac' */ },
		{ NULL, 0xD0B9C /* 'PDFAnnotationPopup' => 'PdfKit.PdfAnnotationPopup, Xamarin.Mac' */ },
		{ NULL, 0xD0F9C /* 'MPSImageBox' => 'MetalPerformanceShaders.MPSImageBox, Xamarin.Mac' */ },
		{ NULL, 0xD109C /* 'PDFAnnotationSquare' => 'PdfKit.PdfAnnotationSquare, Xamarin.Mac' */ },
		{ NULL, 0xD179C /* 'NSGridRow' => 'AppKit.NSGridRow, Xamarin.Mac' */ },
		{ NULL, 0xD199C /* 'GKBasePlayer' => 'GameKit.GKBasePlayer, Xamarin.Mac' */ },
		{ NULL, 0xD1A9C /* 'MPSImageConversion' => 'MetalPerformanceShaders.MPSImageConversion, Xamarin.Mac' */ },
		{ NULL, 0xD1B9C /* 'PDFAnnotationStamp' => 'PdfKit.PdfAnnotationStamp, Xamarin.Mac' */ },
		{ NULL, 0xD1C9C /* 'MLDictionaryConstraint' => 'CoreML.MLDictionaryConstraint, Xamarin.Mac' */ },
		{ NULL, 0xD1E9C /* 'MPSImageConvolution' => 'MetalPerformanceShaders.MPSImageConvolution, Xamarin.Mac' */ },
		{ NULL, 0xD1F9C /* 'MLDictionaryFeatureProvider' => 'CoreML.MLDictionaryFeatureProvider, Xamarin.Mac' */ },
		{ NULL, 0xD269C /* 'MPSImageCopyToMatrix' => 'MetalPerformanceShaders.MPSImageCopyToMatrix, Xamarin.Mac' */ },
		{ NULL, 0xD279C /* 'MLFeatureDescription' => 'CoreML.MLFeatureDescription, Xamarin.Mac' */ },
		{ NULL, 0xD289C /* 'NSGridView' => 'AppKit.NSGridView, Xamarin.Mac' */ },
		{ NULL, 0xD299C /* 'PDFAnnotationText' => 'PdfKit.PdfAnnotationText, Xamarin.Mac' */ },
		{ NULL, 0xD379C /* 'AVFoundation_InternalAVAudioPlayerDelegate' => 'AVFoundation.InternalAVAudioPlayerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xD389C /* 'AVFoundation_InternalAVAudioRecorderDelegate' => 'AVFoundation.InternalAVAudioRecorderDelegate, Xamarin.Mac' */ },
		{ NULL, 0xD3D9C /* 'NSGroupTouchBarItem' => 'AppKit.NSGroupTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0xD3E9C /* 'NSImageView' => 'AppKit.NSImageView, Xamarin.Mac' */ },
		{ NULL, 0xD409C /* 'MPSImageDescriptor' => 'MetalPerformanceShaders.MPSImageDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xD419C /* 'NSHapticFeedbackManager' => 'AppKit.NSHapticFeedbackManager, Xamarin.Mac' */ },
		{ NULL, 0xD429C /* 'GKCloudPlayer' => 'GameKit.GKCloudPlayer, Xamarin.Mac' */ },
		{ NULL, 0xD439C /* 'PDFAnnotationTextWidget' => 'PdfKit.PdfAnnotationTextWidget, Xamarin.Mac' */ },
		{ NULL, 0xD479C /* 'MLFeatureValue' => 'CoreML.MLFeatureValue, Xamarin.Mac' */ },
		{ NULL, 0xD4C9C /* 'MPSImageDilate' => 'MetalPerformanceShaders.MPSImageDilate, Xamarin.Mac' */ },
		{ NULL, 0xD4F9C /* 'MLImageConstraint' => 'CoreML.MLImageConstraint, Xamarin.Mac' */ },
		{ NULL, 0xD509C /* 'GKDialogController' => 'GameKit.GKDialogController, Xamarin.Mac' */ },
		{ NULL, 0xD519C /* 'MPSImageDivide' => 'MetalPerformanceShaders.MPSImageDivide, Xamarin.Mac' */ },
		{ NULL, 0xD549C /* 'CBUUID' => 'CoreBluetooth.CBUUID, Xamarin.Mac' */ },
		{ NULL, 0xD579C /* 'MLModel' => 'CoreML.MLModel, Xamarin.Mac' */ },
		{ NULL, 0xD589C /* 'MPSImageErode' => 'MetalPerformanceShaders.MPSImageErode, Xamarin.Mac' */ },
		{ NULL, 0xD599C /* 'NSLayoutAnchor' => 'AppKit.NSLayoutAnchor`1, Xamarin.Mac' */ },
		{ NULL, 0xD5A9C /* 'PDFAppearanceCharacteristics' => 'PdfKit.PdfAppearanceCharacteristics, Xamarin.Mac' */ },
		{ NULL, 0xD5D9C /* 'MLModelDescription' => 'CoreML.MLModelDescription, Xamarin.Mac' */ },
		{ NULL, 0xD5F9C /* 'MPSImageFindKeypoints' => 'MetalPerformanceShaders.MPSImageFindKeypoints, Xamarin.Mac' */ },
		{ NULL, 0xD669C /* 'MPSImageGaussianBlur' => 'MetalPerformanceShaders.MPSImageGaussianBlur, Xamarin.Mac' */ },
		{ NULL, 0xD6E9C /* 'PDFBorder' => 'PdfKit.PdfBorder, Xamarin.Mac' */ },
		{ NULL, 0xDBD9C /* 'MPSImagePyramid' => 'MetalPerformanceShaders.MPSImagePyramid, Xamarin.Mac' */ },
		{ NULL, 0xD6F9C /* 'MPSImageGaussianPyramid' => 'MetalPerformanceShaders.MPSImageGaussianPyramid, Xamarin.Mac' */ },
		{ NULL, 0xD789C /* 'NSLayoutConstraint' => 'AppKit.NSLayoutConstraint, Xamarin.Mac' */ },
		{ NULL, 0xD799C /* 'MPSImageHistogram' => 'MetalPerformanceShaders.MPSImageHistogram, Xamarin.Mac' */ },
		{ NULL, 0xD7A9C /* 'MLMultiArray' => 'CoreML.MLMultiArray, Xamarin.Mac' */ },
		{ NULL, 0xD7B9C /* 'PDFDestination' => 'PdfKit.PdfDestination, Xamarin.Mac' */ },
		{ NULL, 0xD7C9C /* 'MLMultiArrayConstraint' => 'CoreML.MLMultiArrayConstraint, Xamarin.Mac' */ },
		{ NULL, 0xD819C /* 'MPSImageHistogramEqualization' => 'MetalPerformanceShaders.MPSImageHistogramEqualization, Xamarin.Mac' */ },
		{ NULL, 0xD829C /* 'NSLayoutDimension' => 'AppKit.NSLayoutDimension, Xamarin.Mac' */ },
		{ NULL, 0xD899C /* 'MPSImageHistogramSpecification' => 'MetalPerformanceShaders.MPSImageHistogramSpecification, Xamarin.Mac' */ },
		{ NULL, 0xD8A9C /* 'MLPredictionOptions' => 'CoreML.MLPredictionOptions, Xamarin.Mac' */ },
		{ NULL, 0xD909C /* 'MPSImageIntegral' => 'MetalPerformanceShaders.MPSImageIntegral, Xamarin.Mac' */ },
		{ NULL, 0xD929C /* 'NSLayoutGuide' => 'AppKit.NSLayoutGuide, Xamarin.Mac' */ },
		{ NULL, 0xD939C /* 'MPSImageIntegralOfSquares' => 'MetalPerformanceShaders.MPSImageIntegralOfSquares, Xamarin.Mac' */ },
		{ NULL, 0xD9D9C /* 'NSLevelIndicatorCell' => 'AppKit.NSLevelIndicatorCell, Xamarin.Mac' */ },
		{ NULL, 0xDA29C /* 'MPSImageLaplacian' => 'MetalPerformanceShaders.MPSImageLaplacian, Xamarin.Mac' */ },
		{ NULL, 0xDB19C /* 'MPSImageMedian' => 'MetalPerformanceShaders.MPSImageMedian, Xamarin.Mac' */ },
		{ NULL, 0xDB69C /* 'GKInvite' => 'GameKit.GKInvite, Xamarin.Mac' */ },
		{ NULL, 0xDB89C /* 'MPSImageMultiply' => 'MetalPerformanceShaders.MPSImageMultiply, Xamarin.Mac' */ },
		{ NULL, 0xDD39C /* 'AVCaptureView' => 'AVKit.AVCaptureView, Xamarin.Mac' */ },
		{ NULL, 0xDDC9C /* 'MPSImageSobel' => 'MetalPerformanceShaders.MPSImageSobel, Xamarin.Mac' */ },
		{ NULL, 0xDE99C /* 'NSLayoutManager' => 'AppKit.NSLayoutManager, Xamarin.Mac' */ },
		{ NULL, 0xDEC9C /* 'MPSImageStatisticsMean' => 'MetalPerformanceShaders.MPSImageStatisticsMean, Xamarin.Mac' */ },
		{ NULL, 0xDF59C /* 'MPSImageStatisticsMeanAndVariance' => 'MetalPerformanceShaders.MPSImageStatisticsMeanAndVariance, Xamarin.Mac' */ },
		{ NULL, 0xE009C /* 'AVPlayerView' => 'AVKit.AVPlayerView, Xamarin.Mac' */ },
		{ NULL, 0xE039C /* 'MPSImageStatisticsMinAndMax' => 'MetalPerformanceShaders.MPSImageStatisticsMinAndMax, Xamarin.Mac' */ },
		{ NULL, 0xE0A9C /* 'MPSImageSubtract' => 'MetalPerformanceShaders.MPSImageSubtract, Xamarin.Mac' */ },
		{ NULL, 0xE0F9C /* 'PDFOutline' => 'PdfKit.PdfOutline, Xamarin.Mac' */ },
		{ NULL, 0xE109C /* 'NSLayoutXAxisAnchor' => 'AppKit.NSLayoutXAxisAnchor, Xamarin.Mac' */ },
		{ NULL, 0xE129C /* 'MPSImageTent' => 'MetalPerformanceShaders.MPSImageTent, Xamarin.Mac' */ },
		{ NULL, 0xFBF9C /* 'CKOperation' => 'CloudKit.CKOperation, Xamarin.Mac' */ },
		{ NULL, 0xE139C /* 'CKAcceptSharesOperation' => 'CloudKit.CKAcceptSharesOperation, Xamarin.Mac' */ },
		{ NULL, 0xE229C /* 'NSLayoutYAxisAnchor' => 'AppKit.NSLayoutYAxisAnchor, Xamarin.Mac' */ },
		{ NULL, 0xE249C /* 'MPSImageThresholdBinary' => 'MetalPerformanceShaders.MPSImageThresholdBinary, Xamarin.Mac' */ },
		{ NULL, 0xE279C /* 'PDFPage' => 'PdfKit.PdfPage, Xamarin.Mac' */ },
		{ NULL, 0xE2B9C /* 'MPSImageThresholdBinaryInverse' => 'MetalPerformanceShaders.MPSImageThresholdBinaryInverse, Xamarin.Mac' */ },
		{ NULL, 0xE399C /* 'MPSImageThresholdToZero' => 'MetalPerformanceShaders.MPSImageThresholdToZero, Xamarin.Mac' */ },
		{ NULL, 0xE3A9C /* 'CKAsset' => 'CloudKit.CKAsset, Xamarin.Mac' */ },
		{ NULL, 0xE409C /* 'NSLevelIndicator' => 'AppKit.NSLevelIndicator, Xamarin.Mac' */ },
		{ NULL, 0xE419C /* 'CW8021XProfile' => 'CoreWlan.CW8021XProfile, Xamarin.Mac' */ },
		{ NULL, 0xE429C /* 'MPSImageThresholdToZeroInverse' => 'MetalPerformanceShaders.MPSImageThresholdToZeroInverse, Xamarin.Mac' */ },
		{ NULL, 0xE439C /* 'CWChannel' => 'CoreWlan.CWChannel, Xamarin.Mac' */ },
		{ NULL, 0xE449C /* 'MPSImageThresholdTruncate' => 'MetalPerformanceShaders.MPSImageThresholdTruncate, Xamarin.Mac' */ },
		{ NULL, 0xE4B9C /* 'PDFSelection' => 'PdfKit.PdfSelection, Xamarin.Mac' */ },
		{ NULL, 0xE579C /* 'MPSImageTranspose' => 'MetalPerformanceShaders.MPSImageTranspose, Xamarin.Mac' */ },
		{ NULL, 0xE589C /* 'NSOpenGLContext' => 'AppKit.NSOpenGLContext, Xamarin.Mac' */ },
		{ NULL, 0x13229C /* 'CAOpenGLLayer' => 'CoreAnimation.CAOpenGLLayer, Xamarin.Mac' */ },
		{ NULL, 0xE719C /* 'NSOpenGLLayer' => 'AppKit.NSOpenGLLayer, Xamarin.Mac' */ },
		{ NULL, 0xE789C /* 'NSOpenGLPixelBuffer' => 'AppKit.NSOpenGLPixelBuffer, Xamarin.Mac' */ },
		{ NULL, 0xE799C /* 'NSOpenGLPixelFormat' => 'AppKit.NSOpenGLPixelFormat, Xamarin.Mac' */ },
		{ NULL, 0xE7B9C /* 'MPSLSTMDescriptor' => 'MetalPerformanceShaders.MPSLSTMDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xE809C /* 'NSOpenGLView' => 'AppKit.NSOpenGLView, Xamarin.Mac' */ },
		{ NULL, 0xF7B9C /* 'CKNotification' => 'CloudKit.CKNotification, Xamarin.Mac' */ },
		{ NULL, 0xE819C /* 'CKDatabaseNotification' => 'CloudKit.CKDatabaseNotification, Xamarin.Mac' */ },
		{ NULL, 0xE829C /* 'MPSMatrix' => 'MetalPerformanceShaders.MPSMatrix, Xamarin.Mac' */ },
		{ NULL, 0xE839C /* 'CKDatabaseOperation' => 'CloudKit.CKDatabaseOperation, Xamarin.Mac' */ },
		{ NULL, 0x11219C /* 'NSSavePanel' => 'AppKit.NSSavePanel, Xamarin.Mac' */ },
		{ NULL, 0xE8B9C /* 'NSOpenPanel' => 'AppKit.NSOpenPanel, Xamarin.Mac' */ },
		{ NULL, 0xE8D9C /* 'MPSMatrixBinaryKernel' => 'MetalPerformanceShaders.MPSMatrixBinaryKernel, Xamarin.Mac' */ },
		{ NULL, 0xE8E9C /* 'CWMutableConfiguration' => 'CoreWlan.CWMutableConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x107B9C /* 'CKSubscription' => 'CloudKit.CKSubscription, Xamarin.Mac' */ },
		{ NULL, 0xE8F9C /* 'CKDatabaseSubscription' => 'CloudKit.CKDatabaseSubscription, Xamarin.Mac' */ },
		{ NULL, 0xE909C /* 'MPSMatrixCopy' => 'MetalPerformanceShaders.MPSMatrixCopy, Xamarin.Mac' */ },
		{ NULL, 0xEB09C /* 'CWNetworkProfile' => 'CoreWlan.CWNetworkProfile, Xamarin.Mac' */ },
		{ NULL, 0xE919C /* 'CWMutableNetworkProfile' => 'CoreWlan.CWMutableNetworkProfile, Xamarin.Mac' */ },
		{ NULL, 0xE9B9C /* 'CKDiscoverAllContactsOperation' => 'CloudKit.CKDiscoverAllContactsOperation, Xamarin.Mac' */ },
		{ NULL, 0xE9C9C /* 'MPSMatrixCopyDescriptor' => 'MetalPerformanceShaders.MPSMatrixCopyDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xF2F9C /* 'MPSMatrixUnaryKernel' => 'MetalPerformanceShaders.MPSMatrixUnaryKernel, Xamarin.Mac' */ },
		{ NULL, 0xEA29C /* 'MPSMatrixDecompositionCholesky' => 'MetalPerformanceShaders.MPSMatrixDecompositionCholesky, Xamarin.Mac' */ },
		{ NULL, 0xEA39C /* 'CKDiscoverAllUserIdentitiesOperation' => 'CloudKit.CKDiscoverAllUserIdentitiesOperation, Xamarin.Mac' */ },
		{ NULL, 0xEA59C /* 'CWNetwork' => 'CoreWlan.CWNetwork, Xamarin.Mac' */ },
		{ NULL, 0xEA69C /* 'GKMatchRequest' => 'GameKit.GKMatchRequest, Xamarin.Mac' */ },
		{ NULL, 0xEA89C /* 'MPSMatrixDecompositionLU' => 'MetalPerformanceShaders.MPSMatrixDecompositionLU, Xamarin.Mac' */ },
		{ NULL, 0xEAE9C /* 'CKDiscoveredUserInfo' => 'CloudKit.CKDiscoveredUserInfo, Xamarin.Mac' */ },
		{ NULL, 0xEB29C /* 'MPSMatrixDescriptor' => 'MetalPerformanceShaders.MPSMatrixDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xEB39C /* 'CKDiscoverUserIdentitiesOperation' => 'CloudKit.CKDiscoverUserIdentitiesOperation, Xamarin.Mac' */ },
		{ NULL, 0xEB89C /* 'CWWiFiClient' => 'CoreWlan.CWWiFiClient, Xamarin.Mac' */ },
		{ NULL, 0xEBB9C /* 'CKDiscoverUserInfosOperation' => 'CloudKit.CKDiscoverUserInfosOperation, Xamarin.Mac' */ },
		{ NULL, 0xEBD9C /* 'NSAppleEventDescriptor' => 'Foundation.NSAppleEventDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xEBE9C /* 'MPSMatrixFindTopK' => 'MetalPerformanceShaders.MPSMatrixFindTopK, Xamarin.Mac' */ },
		{ NULL, 0xEC09C /* 'CWWirelessProfile' => 'CoreWlan.CWWirelessProfile, Xamarin.Mac' */ },
		{ NULL, 0xECB9C /* 'MPSMatrixFullyConnected' => 'MetalPerformanceShaders.MPSMatrixFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0xECD9C /* 'NSArray' => 'Foundation.NSArray, Xamarin.Mac' */ },
		{ NULL, 0xEFB9C /* 'MPSMatrixSoftMax' => 'MetalPerformanceShaders.MPSMatrixSoftMax, Xamarin.Mac' */ },
		{ NULL, 0xED29C /* 'MPSMatrixLogSoftMax' => 'MetalPerformanceShaders.MPSMatrixLogSoftMax, Xamarin.Mac' */ },
		{ NULL, 0xED49C /* 'CKFetchDatabaseChangesOperation' => 'CloudKit.CKFetchDatabaseChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xED89C /* 'NSAttributedString' => 'Foundation.NSAttributedString, Xamarin.Mac' */ },
		{ NULL, 0xEE29C /* 'CKFetchNotificationChangesOperation' => 'CloudKit.CKFetchNotificationChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xEE39C /* 'EKCalendar' => 'EventKit.EKCalendar, Xamarin.Mac' */ },
		{ NULL, 0xEE69C /* 'MPSMatrixMultiplication' => 'MetalPerformanceShaders.MPSMatrixMultiplication, Xamarin.Mac' */ },
		{ NULL, 0xEE99C /* 'CKFetchRecordChangesOperation' => 'CloudKit.CKFetchRecordChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xEEA9C /* 'NSBundle' => 'Foundation.NSBundle, Xamarin.Mac' */ },
		{ NULL, 0xEED9C /* 'MPSMatrixNeuron' => 'MetalPerformanceShaders.MPSMatrixNeuron, Xamarin.Mac' */ },
		{ NULL, 0xEEF9C /* 'CKFetchRecordsOperation' => 'CloudKit.CKFetchRecordsOperation, Xamarin.Mac' */ },
		{ NULL, 0xEFD9C /* 'GKScoreChallenge' => 'GameKit.GKScoreChallenge, Xamarin.Mac' */ },
		{ NULL, 0xEFF9C /* 'CKFetchRecordZoneChangesOperation' => 'CloudKit.CKFetchRecordZoneChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xF019C /* 'NSCoder' => 'Foundation.NSCoder, Xamarin.Mac' */ },
		{ NULL, 0xF039C /* 'MPSMatrixSolveCholesky' => 'MetalPerformanceShaders.MPSMatrixSolveCholesky, Xamarin.Mac' */ },
		{ NULL, 0xF079C /* 'NSConnection' => 'Foundation.NSConnection, Xamarin.Mac' */ },
		{ NULL, 0xF0B9C /* 'CKFetchRecordZoneChangesOptions' => 'CloudKit.CKFetchRecordZoneChangesOptions, Xamarin.Mac' */ },
		{ NULL, 0xF119C /* 'MPSMatrixSolveLU' => 'MetalPerformanceShaders.MPSMatrixSolveLU, Xamarin.Mac' */ },
		{ NULL, 0xF159C /* 'GKTurnBasedEventHandler' => 'GameKit.GKTurnBasedEventHandler, Xamarin.Mac' */ },
		{ NULL, 0xF179C /* 'CKFetchRecordZonesOperation' => 'CloudKit.CKFetchRecordZonesOperation, Xamarin.Mac' */ },
		{ NULL, 0xF189C /* 'MPSMatrixSolveTriangular' => 'MetalPerformanceShaders.MPSMatrixSolveTriangular, Xamarin.Mac' */ },
		{ NULL, 0xF199C /* 'NSDate' => 'Foundation.NSDate, Xamarin.Mac' */ },
		{ NULL, 0xF249C /* 'CKFetchShareMetadataOperation' => 'CloudKit.CKFetchShareMetadataOperation, Xamarin.Mac' */ },
		{ NULL, 0xF269C /* 'MPSMatrixSum' => 'MetalPerformanceShaders.MPSMatrixSum, Xamarin.Mac' */ },
		{ NULL, 0xF289C /* 'NSPageLayout' => 'AppKit.NSPageLayout, Xamarin.Mac' */ },
		{ NULL, 0xF2A9C /* 'CKFetchShareParticipantsOperation' => 'CloudKit.CKFetchShareParticipantsOperation, Xamarin.Mac' */ },
		{ NULL, 0x12509C /* 'NSEnumerator' => 'Foundation.NSEnumerator, Xamarin.Mac' */ },
		{ NULL, 0xF2E9C /* 'NSDirectoryEnumerator' => 'Foundation.NSDirectoryEnumerator, Xamarin.Mac' */ },
		{ NULL, 0xF309C /* 'CKFetchSubscriptionsOperation' => 'CloudKit.CKFetchSubscriptionsOperation, Xamarin.Mac' */ },
		{ NULL, 0xF379C /* 'MPSMatrixVectorMultiplication' => 'MetalPerformanceShaders.MPSMatrixVectorMultiplication, Xamarin.Mac' */ },
		{ NULL, 0xF389C /* 'CKFetchWebAuthTokenOperation' => 'CloudKit.CKFetchWebAuthTokenOperation, Xamarin.Mac' */ },
		{ NULL, 0xF499C /* 'MPSNNBinaryArithmeticNode' => 'MetalPerformanceShaders.MPSNNBinaryArithmeticNode, Xamarin.Mac' */ },
		{ NULL, 0xF3C9C /* 'MPSNNAdditionNode' => 'MetalPerformanceShaders.MPSNNAdditionNode, Xamarin.Mac' */ },
		{ NULL, 0xF3E9C /* 'CKLocationSortDescriptor' => 'CloudKit.CKLocationSortDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xF3F9C /* 'NSExpression' => 'Foundation.NSExpression, Xamarin.Mac' */ },
		{ NULL, 0xF409C /* 'GKTurnBasedExchangeReply' => 'GameKit.GKTurnBasedExchangeReply, Xamarin.Mac' */ },
		{ NULL, 0xF979C /* 'MPSNNScaleNode' => 'MetalPerformanceShaders.MPSNNScaleNode, Xamarin.Mac' */ },
		{ NULL, 0xF429C /* 'MPSNNBilinearScaleNode' => 'MetalPerformanceShaders.MPSNNBilinearScaleNode, Xamarin.Mac' */ },
		{ NULL, 0xF439C /* 'NSParagraphStyle' => 'AppKit.NSParagraphStyle, Xamarin.Mac' */ },
		{ NULL, 0xF469C /* 'CKMarkNotificationsReadOperation' => 'CloudKit.CKMarkNotificationsReadOperation, Xamarin.Mac' */ },
		{ NULL, 0xF4C9C /* 'MPSNNConcatenationNode' => 'MetalPerformanceShaders.MPSNNConcatenationNode, Xamarin.Mac' */ },
		{ NULL, 0xF4D9C /* 'CKModifyBadgeOperation' => 'CloudKit.CKModifyBadgeOperation, Xamarin.Mac' */ },
		{ NULL, 0xF4E9C /* 'EKParticipant' => 'EventKit.EKParticipant, Xamarin.Mac' */ },
		{ NULL, 0xF529C /* 'MPSNNDefaultPadding' => 'MetalPerformanceShaders.MPSNNDefaultPadding, Xamarin.Mac' */ },
		{ NULL, 0xF589C /* 'MPSNNDivisionNode' => 'MetalPerformanceShaders.MPSNNDivisionNode, Xamarin.Mac' */ },
		{ NULL, 0xF5A9C /* 'CKModifyRecordsOperation' => 'CloudKit.CKModifyRecordsOperation, Xamarin.Mac' */ },
		{ NULL, 0xF609C /* 'EKRecurrenceEnd' => 'EventKit.EKRecurrenceEnd, Xamarin.Mac' */ },
		{ NULL, 0xF629C /* 'CKModifyRecordZonesOperation' => 'CloudKit.CKModifyRecordZonesOperation, Xamarin.Mac' */ },
		{ NULL, 0xF649C /* 'NSHTTPCookie' => 'Foundation.NSHttpCookie, Xamarin.Mac' */ },
		{ NULL, 0xF679C /* 'NSPasteboard' => 'AppKit.NSPasteboard, Xamarin.Mac' */ },
		{ NULL, 0xF6A9C /* 'CKModifySubscriptionsOperation' => 'CloudKit.CKModifySubscriptionsOperation, Xamarin.Mac' */ },
		{ NULL, 0xF6C9C /* 'GKTurnBasedMatchmakerViewController' => 'GameKit.GKTurnBasedMatchmakerViewController, Xamarin.Mac' */ },
		{ NULL, 0xF6E9C /* 'NSIndexPath' => 'Foundation.NSIndexPath, Xamarin.Mac' */ },
		{ NULL, 0xF6F9C /* 'MPSNNImageNode' => 'MetalPerformanceShaders.MPSNNImageNode, Xamarin.Mac' */ },
		{ NULL, 0xF709C /* 'NSPasteboardItem' => 'AppKit.NSPasteboardItem, Xamarin.Mac' */ },
		{ NULL, 0xF739C /* 'MPSNNLanczosScaleNode' => 'MetalPerformanceShaders.MPSNNLanczosScaleNode, Xamarin.Mac' */ },
		{ NULL, 0xF749C /* 'EKReminder' => 'EventKit.EKReminder, Xamarin.Mac' */ },
		{ NULL, 0xF7E9C /* 'NSInputStream' => 'Foundation.NSInputStream, Xamarin.Mac' */ },
		{ NULL, 0xF819C /* 'MPSNNMultiplicationNode' => 'MetalPerformanceShaders.MPSNNMultiplicationNode, Xamarin.Mac' */ },
		{ NULL, 0xF829C /* 'CKNotificationID' => 'CloudKit.CKNotificationID, Xamarin.Mac' */ },
		{ NULL, 0xF869C /* 'NSJSONSerialization' => 'Foundation.NSJsonSerialization, Xamarin.Mac' */ },
		{ NULL, 0xF899C /* 'EKSource' => 'EventKit.EKSource, Xamarin.Mac' */ },
		{ NULL, 0xF8E9C /* 'NSMenuItemCell' => 'AppKit.NSMenuItemCell, Xamarin.Mac' */ },
		{ NULL, 0xF9A9C /* 'GKTurnBasedParticipant' => 'GameKit.GKTurnBasedParticipant, Xamarin.Mac' */ },
		{ NULL, 0xFA19C /* 'MPSNNSubtractionNode' => 'MetalPerformanceShaders.MPSNNSubtractionNode, Xamarin.Mac' */ },
		{ NULL, 0xFA29C /* 'CKNotificationInfo' => 'CloudKit.CKNotificationInfo, Xamarin.Mac' */ },
		{ NULL, 0xFA39C /* 'EKStructuredLocation' => 'EventKit.EKStructuredLocation, Xamarin.Mac' */ },
		{ NULL, 0xFAB9C /* 'NSMenuView' => 'AppKit.NSMenuView, Xamarin.Mac' */ },
		{ NULL, 0xFAC9C /* 'GKVoiceChat' => 'GameKit.GKVoiceChat, Xamarin.Mac' */ },
		{ NULL, 0x10099C /* 'GKComponent' => 'GameplayKit.GKComponent, Xamarin.Mac' */ },
		{ NULL, 0xFB99C /* 'GKAgent' => 'GameplayKit.GKAgent, Xamarin.Mac' */ },
		{ NULL, 0xFC09C /* 'GKAgent2D' => 'GameplayKit.GKAgent2D, Xamarin.Mac' */ },
		{ NULL, 0x8219C /* 'NSFontCollection' => 'AppKit.NSFontCollection, Xamarin.Mac' */ },
		{ NULL, 0xFC19C /* 'NSMutableFontCollection' => 'AppKit.NSMutableFontCollection, Xamarin.Mac' */ },
		{ NULL, 0xFC49C /* 'NSMetadataItem' => 'Foundation.NSMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0xFC59C /* 'MPSRNNImageInferenceLayer' => 'MetalPerformanceShaders.MPSRnnImageInferenceLayer, Xamarin.Mac' */ },
		{ NULL, 0xFC99C /* 'NSMutableArray' => 'Foundation.NSMutableArray, Xamarin.Mac' */ },
		{ NULL, 0xFCA9C /* 'CKOperationConfiguration' => 'CloudKit.CKOperationConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xFCD9C /* 'GKAgent3D' => 'GameplayKit.GKAgent3D, Xamarin.Mac' */ },
		{ NULL, 0xFD19C /* 'MPSRNNMatrixInferenceLayer' => 'MetalPerformanceShaders.MPSRnnMatrixInferenceLayer, Xamarin.Mac' */ },
		{ NULL, 0xFD89C /* 'CKOperationGroup' => 'CloudKit.CKOperationGroup, Xamarin.Mac' */ },
		{ NULL, 0xFD99C /* 'NSMutableAttributedString' => 'Foundation.NSMutableAttributedString, Xamarin.Mac' */ },
		{ NULL, 0xFDA9C /* 'MPSRNNRecurrentImageState' => 'MetalPerformanceShaders.MPSRnnRecurrentImageState, Xamarin.Mac' */ },
		{ NULL, 0xFDB9C /* 'NSMutableParagraphStyle' => 'AppKit.NSMutableParagraphStyle, Xamarin.Mac' */ },
		{ NULL, 0x113F9C /* 'GKRandomSource' => 'GameplayKit.GKRandomSource, Xamarin.Mac' */ },
		{ NULL, 0xFE09C /* 'GKARC4RandomSource' => 'GameplayKit.GKARC4RandomSource, Xamarin.Mac' */ },
		{ NULL, 0xFE49C /* 'MPSRNNRecurrentMatrixState' => 'MetalPerformanceShaders.MPSRnnRecurrentMatrixState, Xamarin.Mac' */ },
		{ NULL, 0xFE59C /* 'NSNib' => 'AppKit.NSNib, Xamarin.Mac' */ },
		{ NULL, 0xFE69C /* 'NSPathControlItem' => 'AppKit.NSPathControlItem, Xamarin.Mac' */ },
		{ NULL, 0xFE99C /* 'CKQuery' => 'CloudKit.CKQuery, Xamarin.Mac' */ },
		{ NULL, 0xFEA9C /* 'MPSRNNSingleGateDescriptor' => 'MetalPerformanceShaders.MPSRnnSingleGateDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xFF09C /* 'NSPDFImageRep' => 'AppKit.NSPdfImageRep, Xamarin.Mac' */ },
		{ NULL, 0x10CF9C /* 'GKNoiseSource' => 'GameplayKit.GKNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0x10049C /* 'GKCoherentNoiseSource' => 'GameplayKit.GKCoherentNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xFF19C /* 'GKBillowNoiseSource' => 'GameplayKit.GKBillowNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xFF29C /* 'CKQueryCursor' => 'CloudKit.CKQueryCursor, Xamarin.Mac' */ },
		{ NULL, 0xFF59C /* 'GKCheckerboardNoiseSource' => 'GameplayKit.GKCheckerboardNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xFF69C /* 'CKQueryNotification' => 'CloudKit.CKQueryNotification, Xamarin.Mac' */ },
		{ NULL, 0xFFA9C /* 'MPSTemporaryImage' => 'MetalPerformanceShaders.MPSTemporaryImage, Xamarin.Mac' */ },
		{ NULL, 0xFFD9C /* 'GKCircleObstacle' => 'GameplayKit.GKCircleObstacle, Xamarin.Mac' */ },
		{ NULL, 0x10019C /* 'MPSTemporaryMatrix' => 'MetalPerformanceShaders.MPSTemporaryMatrix, Xamarin.Mac' */ },
		{ NULL, 0x10149C /* 'MPSVector' => 'MetalPerformanceShaders.MPSVector, Xamarin.Mac' */ },
		{ NULL, 0x10059C /* 'MPSTemporaryVector' => 'MetalPerformanceShaders.MPSTemporaryVector, Xamarin.Mac' */ },
		{ NULL, 0x10069C /* 'CKQueryOperation' => 'CloudKit.CKQueryOperation, Xamarin.Mac' */ },
		{ NULL, 0x10089C /* 'NSAffineTransform' => 'Foundation.NSAffineTransform, Xamarin.Mac' */ },
		{ NULL, 0x100C9C /* 'CKQuerySubscription' => 'CloudKit.CKQuerySubscription, Xamarin.Mac' */ },
		{ NULL, 0x10B39C /* 'NSRuleEditor' => 'AppKit.NSRuleEditor, Xamarin.Mac' */ },
		{ NULL, 0x10139C /* 'NSPredicateEditor' => 'AppKit.NSPredicateEditor, Xamarin.Mac' */ },
		{ NULL, 0x10159C /* 'Foundation_InternalNSNotificationHandler' => 'Foundation.InternalNSNotificationHandler, Xamarin.Mac' */ },
		{ NULL, 0x10199C /* 'MPSVectorDescriptor' => 'MetalPerformanceShaders.MPSVectorDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x101B9C /* 'CKRecord' => 'CloudKit.CKRecord, Xamarin.Mac' */ },
		{ NULL, 0x101C9C /* 'GKConstantNoiseSource' => 'GameplayKit.GKConstantNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0x101E9C /* 'NSPredicateEditorRowTemplate' => 'AppKit.NSPredicateEditorRowTemplate, Xamarin.Mac' */ },
		{ NULL, 0x101F9C /* 'NSAppleEventManager' => 'Foundation.NSAppleEventManager, Xamarin.Mac' */ },
		{ NULL, 0x10209C /* 'GKCylindersNoiseSource' => 'GameplayKit.GKCylindersNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0x12789C /* 'NSExtensionContext' => 'Foundation.NSExtensionContext, Xamarin.Mac' */ },
		{ NULL, 0x10229C /* 'CKRecordID' => 'CloudKit.CKRecordID, Xamarin.Mac' */ },
		{ NULL, 0x10249C /* 'GKDecisionNode' => 'GameplayKit.GKDecisionNode, Xamarin.Mac' */ },
		{ NULL, 0x10259C /* 'NSAppleScript' => 'Foundation.NSAppleScript, Xamarin.Mac' */ },
		{ NULL, 0x102D9C /* 'NSPressureConfiguration' => 'AppKit.NSPressureConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x102F9C /* 'CKRecordZone' => 'CloudKit.CKRecordZone, Xamarin.Mac' */ },
		{ NULL, 0x10309C /* 'NSProxy' => 'Foundation.NSProxy, Xamarin.Mac' */ },
		{ NULL, 0x10319C /* 'GKDecisionTree' => 'GameplayKit.GKDecisionTree, Xamarin.Mac' */ },
		{ NULL, 0x10349C /* 'NSPrinter' => 'AppKit.NSPrinter, Xamarin.Mac' */ },
		{ NULL, 0x10379C /* 'CKRecordZoneNotification' => 'CloudKit.CKRecordZoneNotification, Xamarin.Mac' */ },
		{ NULL, 0x103A9C /* 'CKRecordZoneSubscription' => 'CloudKit.CKRecordZoneSubscription, Xamarin.Mac' */ },
		{ NULL, 0x10409C /* 'NSPrintInfo' => 'AppKit.NSPrintInfo, Xamarin.Mac' */ },
		{ NULL, 0x10469C /* 'CKReference' => 'CloudKit.CKReference, Xamarin.Mac' */ },
		{ NULL, 0x104C9C /* 'CKServerChangeToken' => 'CloudKit.CKServerChangeToken, Xamarin.Mac' */ },
		{ NULL, 0x11379C /* 'GKRandomDistribution' => 'GameplayKit.GKRandomDistribution, Xamarin.Mac' */ },
		{ NULL, 0x104E9C /* 'GKGaussianDistribution' => 'GameplayKit.GKGaussianDistribution, Xamarin.Mac' */ },
		{ NULL, 0x104F9C /* 'NSPrintOperation' => 'AppKit.NSPrintOperation, Xamarin.Mac' */ },
		{ NULL, 0x10529C /* 'NSBlockOperation' => 'Foundation.NSBlockOperation, Xamarin.Mac' */ },
		{ NULL, 0x10539C /* 'CKShare' => 'CloudKit.CKShare, Xamarin.Mac' */ },
		{ NULL, 0x10579C /* 'NSPrintPanel' => 'AppKit.NSPrintPanel, Xamarin.Mac' */ },
		{ NULL, 0x10589C /* 'GKGoal' => 'GameplayKit.GKGoal, Xamarin.Mac' */ },
		{ NULL, 0x10609C /* 'NSPrintPreviewGraphicsContext' => 'AppKit.NSPrintPreviewGraphicsContext, Xamarin.Mac' */ },
		{ NULL, 0x10669C /* 'CKShareMetadata' => 'CloudKit.CKShareMetadata, Xamarin.Mac' */ },
		{ NULL, 0x10679C /* 'GKGraphNode' => 'GameplayKit.GKGraphNode, Xamarin.Mac' */ },
		{ NULL, 0x106C9C /* 'CKShareParticipant' => 'CloudKit.CKShareParticipant, Xamarin.Mac' */ },
		{ NULL, 0x106D9C /* 'GKGraphNode2D' => 'GameplayKit.GKGraphNode2D, Xamarin.Mac' */ },
		{ NULL, 0x106E9C /* 'NSProgressIndicator' => 'AppKit.NSProgressIndicator, Xamarin.Mac' */ },
		{ NULL, 0x10729C /* 'GKGraphNode3D' => 'GameplayKit.GKGraphNode3D, Xamarin.Mac' */ },
		{ NULL, 0x10739C /* 'NSRemoteOpenPanel' => 'AppKit.NSRemoteOpenPanel, Xamarin.Mac' */ },
		{ NULL, 0x10759C /* 'NSRemoteSavePanel' => 'AppKit.NSRemoteSavePanel, Xamarin.Mac' */ },
		{ NULL, 0x10799C /* 'NSByteCountFormatter' => 'Foundation.NSByteCountFormatter, Xamarin.Mac' */ },
		{ NULL, 0x107A9C /* 'GKGridGraphNode' => 'GameplayKit.GKGridGraphNode, Xamarin.Mac' */ },
		{ NULL, 0x107E9C /* 'GKLinearCongruentialRandomSource' => 'GameplayKit.GKLinearCongruentialRandomSource, Xamarin.Mac' */ },
		{ NULL, 0x10859C /* 'GKMersenneTwisterRandomSource' => 'GameplayKit.GKMersenneTwisterRandomSource, Xamarin.Mac' */ },
		{ NULL, 0x108A9C /* 'CKUserIdentity' => 'CloudKit.CKUserIdentity, Xamarin.Mac' */ },
		{ NULL, 0x10949C /* 'GKMeshGraph' => 'GameplayKit.GKMeshGraph`1, Xamarin.Mac' */ },
		{ NULL, 0x10969C /* 'NSCachedURLResponse' => 'Foundation.NSCachedUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x10999C /* 'NSPopoverTouchBarItem' => 'AppKit.NSPopoverTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x109A9C /* 'Foundation_NSUrlProtocolClient' => 'Foundation.NSUrlProtocolClient, Xamarin.Mac' */ },
		{ NULL, 0x10A19C /* 'MDLAnimationBindComponent' => 'ModelIO.MDLAnimationBindComponent, Xamarin.Mac' */ },
		{ NULL, 0x10A39C /* 'GKMinmaxStrategist' => 'GameplayKit.GKMinMaxStrategist, Xamarin.Mac' */ },
		{ NULL, 0x121F9C /* 'MDLObject' => 'ModelIO.MDLObject, Xamarin.Mac' */ },
		{ NULL, 0x11109C /* 'MDLLight' => 'ModelIO.MDLLight, Xamarin.Mac' */ },
		{ NULL, 0x12449C /* 'MDLPhysicallyPlausibleLight' => 'ModelIO.MDLPhysicallyPlausibleLight, Xamarin.Mac' */ },
		{ NULL, 0x10A69C /* 'MDLAreaLight' => 'ModelIO.MDLAreaLight, Xamarin.Mac' */ },
		{ NULL, 0x10A99C /* 'GKMonteCarloStrategist' => 'GameplayKit.GKMonteCarloStrategist, Xamarin.Mac' */ },
		{ NULL, 0x10B89C /* 'GKNoise' => 'GameplayKit.GKNoise, Xamarin.Mac' */ },
		{ NULL, 0x10E29C /* 'NSScrubberLayout' => 'AppKit.NSScrubberLayout, Xamarin.Mac' */ },
		{ NULL, 0x10B99C /* 'NSScrubberFlowLayout' => 'AppKit.NSScrubberFlowLayout, Xamarin.Mac' */ },
		{ NULL, 0x10C79C /* 'GKNoiseMap' => 'GameplayKit.GKNoiseMap, Xamarin.Mac' */ },
		{ NULL, 0x10C89C /* 'CNContactFormatter' => 'Contacts.CNContactFormatter, Xamarin.Mac' */ },
		{ NULL, 0x10DC9C /* 'SCNGeometry' => 'SceneKit.SCNGeometry, Xamarin.Mac' */ },
		{ NULL, 0x10C99C /* 'SCNText' => 'SceneKit.SCNText, Xamarin.Mac' */ },
		{ NULL, 0x10CE9C /* 'MDLBundleAssetResolver' => 'ModelIO.MDLBundleAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x11909C /* 'NSScrubberArrangedView' => 'AppKit.NSScrubberArrangedView, Xamarin.Mac' */ },
		{ NULL, 0x10D89C /* 'NSScrubberItemView' => 'AppKit.NSScrubberItemView, Xamarin.Mac' */ },
		{ NULL, 0x10D19C /* 'NSScrubberImageItemView' => 'AppKit.NSScrubberImageItemView, Xamarin.Mac' */ },
		{ NULL, 0x10D39C /* 'NSRulerMarker' => 'AppKit.NSRulerMarker, Xamarin.Mac' */ },
		{ NULL, 0x10D59C /* 'SCNAction' => 'SceneKit.SCNAction, Xamarin.Mac' */ },
		{ NULL, 0x10D69C /* 'SCNScene' => 'SceneKit.SCNScene, Xamarin.Mac' */ },
		{ NULL, 0x11589C /* 'GKRule' => 'GameplayKit.GKRule, Xamarin.Mac' */ },
		{ NULL, 0x10D99C /* 'GKNSPredicateRule' => 'GameplayKit.GKNSPredicateRule, Xamarin.Mac' */ },
		{ NULL, 0x10DA9C /* 'NSCalendarDate' => 'Foundation.NSCalendarDate, Xamarin.Mac' */ },
		{ NULL, 0x10DF9C /* 'SCNGeometrySource' => 'SceneKit.SCNGeometrySource, Xamarin.Mac' */ },
		{ NULL, 0x10E19C /* 'CNContactProperty' => 'Contacts.CNContactProperty, Xamarin.Mac' */ },
		{ NULL, 0x10E49C /* 'MDLCamera' => 'ModelIO.MDLCamera, Xamarin.Mac' */ },
		{ NULL, 0x10E69C /* 'NSCharacterSet' => 'Foundation.NSCharacterSet, Xamarin.Mac' */ },
		{ NULL, 0x10E79C /* 'CNContactRelation' => 'Contacts.CNContactRelation, Xamarin.Mac' */ },
		{ NULL, 0x10E99C /* 'NSScrubberLayoutAttributes' => 'AppKit.NSScrubberLayoutAttributes, Xamarin.Mac' */ },
		{ NULL, 0x10EB9C /* 'MDLCheckerboardTexture' => 'ModelIO.MDLCheckerboardTexture, Xamarin.Mac' */ },
		{ NULL, 0x10ED9C /* 'SCNParticleSystem' => 'SceneKit.SCNParticleSystem, Xamarin.Mac' */ },
		{ NULL, 0x10EF9C /* 'NSRulerView' => 'AppKit.NSRulerView, Xamarin.Mac' */ },
		{ NULL, 0x10F09C /* 'NSScrubberProportionalLayout' => 'AppKit.NSScrubberProportionalLayout, Xamarin.Mac' */ },
		{ NULL, 0x10F19C /* 'SCNPhysicsShape' => 'SceneKit.SCNPhysicsShape, Xamarin.Mac' */ },
		{ NULL, 0x10F49C /* 'GKOctree' => 'GameplayKit.GKOctree`1, Xamarin.Mac' */ },
		{ NULL, 0x10F79C /* 'MDLColorSwatchTexture' => 'ModelIO.MDLColorSwatchTexture, Xamarin.Mac' */ },
		{ NULL, 0x10F89C /* 'NSScrubberSelectionStyle' => 'AppKit.NSScrubberSelectionStyle, Xamarin.Mac' */ },
		{ NULL, 0x10FA9C /* 'GKOctreeNode' => 'GameplayKit.GKOctreeNode, Xamarin.Mac' */ },
		{ NULL, 0x10FC9C /* 'NSScrubberSelectionView' => 'AppKit.NSScrubberSelectionView, Xamarin.Mac' */ },
		{ NULL, 0x11009C /* 'CNContactsUserDefaults' => 'Contacts.CNContactsUserDefaults, Xamarin.Mac' */ },
		{ NULL, 0x11039C /* 'NSRunningApplication' => 'AppKit.NSRunningApplication, Xamarin.Mac' */ },
		{ NULL, 0x11049C /* 'NSScrubberTextItemView' => 'AppKit.NSScrubberTextItemView, Xamarin.Mac' */ },
		{ NULL, 0x110D9C /* 'CNContactVCardSerialization' => 'Contacts.CNContactVCardSerialization, Xamarin.Mac' */ },
		{ NULL, 0x110E9C /* 'GKPerlinNoiseSource' => 'GameplayKit.GKPerlinNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0x110F9C /* 'SCNSceneSource' => 'SceneKit.SCNSceneSource, Xamarin.Mac' */ },
		{ NULL, 0x11119C /* 'NSComparisonPredicate' => 'Foundation.NSComparisonPredicate, Xamarin.Mac' */ },
		{ NULL, 0x11129C /* 'CNContainer' => 'Contacts.CNContainer, Xamarin.Mac' */ },
		{ NULL, 0x11139C /* 'SCNSkinner' => 'SceneKit.SCNSkinner, Xamarin.Mac' */ },
		{ NULL, 0x11169C /* 'SCNTechnique' => 'SceneKit.SCNTechnique, Xamarin.Mac' */ },
		{ NULL, 0x11189C /* 'MDLLightProbe' => 'ModelIO.MDLLightProbe, Xamarin.Mac' */ },
		{ NULL, 0x11199C /* 'GKQuadtree' => 'GameplayKit.GKQuadTree, Xamarin.Mac' */ },
		{ NULL, 0x111B9C /* 'NSCompoundPredicate' => 'Foundation.NSCompoundPredicate, Xamarin.Mac' */ },
		{ NULL, 0x111C9C /* 'SKAction' => 'SpriteKit.SKAction, Xamarin.Mac' */ },
		{ NULL, 0x111E9C /* 'GKQuadtreeNode' => 'GameplayKit.GKQuadTreeNode, Xamarin.Mac' */ },
		{ NULL, 0x11209C /* 'SKKeyframeSequence' => 'SpriteKit.SKKeyframeSequence, Xamarin.Mac' */ },
		{ NULL, 0x112B9C /* 'NSCondition' => 'Foundation.NSCondition, Xamarin.Mac' */ },
		{ NULL, 0x11359C /* 'NSConditionLock' => 'Foundation.NSConditionLock, Xamarin.Mac' */ },
		{ NULL, 0x11389C /* 'NSSecureTextField' => 'AppKit.NSSecureTextField, Xamarin.Mac' */ },
		{ NULL, 0x112E9C /* 'SKNode' => 'SpriteKit.SKNode, Xamarin.Mac' */ },
		{ NULL, 0x113B9C /* 'SKShapeNode' => 'SpriteKit.SKShapeNode, Xamarin.Mac' */ },
		{ NULL, 0x113C9C /* 'MDLMaterial' => 'ModelIO.MDLMaterial, Xamarin.Mac' */ },
		{ NULL, 0x113D9C /* 'CNGroup' => 'Contacts.CNGroup, Xamarin.Mac' */ },
		{ NULL, 0x113E9C /* 'NSSecureTextFieldCell' => 'AppKit.NSSecureTextFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x11409C /* 'SKUniform' => 'SpriteKit.SKUniform, Xamarin.Mac' */ },
		{ NULL, 0x11429C /* 'GKRidgedNoiseSource' => 'GameplayKit.GKRidgedNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0x11469C /* 'SKVideoNode' => 'SpriteKit.SKVideoNode, Xamarin.Mac' */ },
		{ NULL, 0x114B9C /* 'GKRTree' => 'GameplayKit.GKRTree`1, Xamarin.Mac' */ },
		{ NULL, 0x19209C /* 'SKWarpGeometry' => 'SpriteKit.SKWarpGeometry, Xamarin.Mac' */ },
		{ NULL, 0x114C9C /* 'SKWarpGeometryGrid' => 'SpriteKit.SKWarpGeometryGrid, Xamarin.Mac' */ },
		{ NULL, 0x11519C /* 'MDLMaterialProperty' => 'ModelIO.MDLMaterialProperty, Xamarin.Mac' */ },
		{ NULL, 0x115B9C /* 'MDLMaterialPropertyConnection' => 'ModelIO.MDLMaterialPropertyConnection, Xamarin.Mac' */ },
		{ NULL, 0x115D9C /* 'GKRuleSystem' => 'GameplayKit.GKRuleSystem, Xamarin.Mac' */ },
		{ NULL, 0x116B9C /* 'NSDataDetector' => 'Foundation.NSDataDetector, Xamarin.Mac' */ },
		{ NULL, 0x116C9C /* '__monomac_internal_ActionDispatcher' => 'AppKit.ActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x11799C /* 'MDLMaterialPropertyNode' => 'ModelIO.MDLMaterialPropertyNode, Xamarin.Mac' */ },
		{ NULL, 0x116D9C /* 'MDLMaterialPropertyGraph' => 'ModelIO.MDLMaterialPropertyGraph, Xamarin.Mac' */ },
		{ NULL, 0x11729C /* 'CNLabeledValue' => 'Contacts.CNLabeledValue`1, Xamarin.Mac' */ },
		{ NULL, 0x11739C /* 'GKScene' => 'GameplayKit.GKScene, Xamarin.Mac' */ },
		{ NULL, 0x11809C /* 'NSStatusItem' => 'AppKit.NSStatusItem, Xamarin.Mac' */ },
		{ NULL, 0x11869C /* 'GKSCNNodeComponent' => 'GameplayKit.GKSCNNodeComponent, Xamarin.Mac' */ },
		{ NULL, 0x11899C /* 'NSScrubber' => 'AppKit.NSScrubber, Xamarin.Mac' */ },
		{ NULL, 0x118A9C /* 'GKShuffledDistribution' => 'GameplayKit.GKShuffledDistribution, Xamarin.Mac' */ },
		{ NULL, 0x118E9C /* 'NSDateComponents' => 'Foundation.NSDateComponents, Xamarin.Mac' */ },
		{ NULL, 0x11919C /* 'GKSKNodeComponent' => 'GameplayKit.GKSKNodeComponent, Xamarin.Mac' */ },
		{ NULL, 0x11929C /* 'NSShadow' => 'AppKit.NSShadow, Xamarin.Mac' */ },
		{ NULL, 0x11939C /* 'GKSphereObstacle' => 'GameplayKit.GKSphereObstacle, Xamarin.Mac' */ },
		{ NULL, 0x11979C /* '__MonoMac_NSAlertDidEndDispatcher' => 'AppKit.NSAlertDidEndDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x3A9C /* 'CNContact' => 'Contacts.CNContact, Xamarin.Mac' */ },
		{ NULL, 0x11999C /* 'CNMutableContact' => 'Contacts.CNMutableContact, Xamarin.Mac' */ },
		{ NULL, 0x119A9C /* 'GKSpheresNoiseSource' => 'GameplayKit.GKSpheresNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0x119B9C /* 'CNMutableGroup' => 'Contacts.CNMutableGroup, Xamarin.Mac' */ },
		{ NULL, 0x119C9C /* 'NSDateComponentsFormatter' => 'Foundation.NSDateComponentsFormatter, Xamarin.Mac' */ },
		{ NULL, 0x119D9C /* 'NSSliderTouchBarItem' => 'AppKit.NSSliderTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x119E9C /* 'QCComposition' => 'QuartzComposer.QCComposition, Xamarin.Mac' */ },
		{ NULL, 0x11AD9C /* 'CNPostalAddress' => 'Contacts.CNPostalAddress, Xamarin.Mac' */ },
		{ NULL, 0x119F9C /* 'CNMutablePostalAddress' => 'Contacts.CNMutablePostalAddress, Xamarin.Mac' */ },
		{ NULL, 0x11A49C /* 'CNPhoneNumber' => 'Contacts.CNPhoneNumber, Xamarin.Mac' */ },
		{ NULL, 0x11A59C /* 'QCCompositionLayer' => 'QuartzComposer.QCCompositionLayer, Xamarin.Mac' */ },
		{ NULL, 0x11A89C /* 'QCCompositionRepository' => 'QuartzComposer.QCCompositionRepository, Xamarin.Mac' */ },
		{ NULL, 0x11B19C /* 'GKVoronoiNoiseSource' => 'GameplayKit.GKVoronoiNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0x11BE9C /* 'CNPostalAddressFormatter' => 'Contacts.CNPostalAddressFormatter, Xamarin.Mac' */ },
		{ NULL, 0x11C49C /* 'NSSpeechRecognizer' => 'AppKit.NSSpeechRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x11C79C /* 'NSDateFormatter' => 'Foundation.NSDateFormatter, Xamarin.Mac' */ },
		{ NULL, 0x11D29C /* 'QLPreviewPanel' => 'QuickLookUI.QLPreviewPanel, Xamarin.Mac' */ },
		{ NULL, 0x11D59C /* 'GLKBaseEffect' => 'GLKit.GLKBaseEffect, Xamarin.Mac' */ },
		{ NULL, 0x11D79C /* 'NSDateInterval' => 'Foundation.NSDateInterval, Xamarin.Mac' */ },
		{ NULL, 0x11D89C /* 'MDLMeshBufferData' => 'ModelIO.MDLMeshBufferData, Xamarin.Mac' */ },
		{ NULL, 0x11D99C /* 'NSSharingServicePickerTouchBarItem' => 'AppKit.NSSharingServicePickerTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x11DA9C /* 'GLKEffectProperty' => 'GLKit.GLKEffectProperty, Xamarin.Mac' */ },
		{ NULL, 0x11DB9C /* 'CNSaveRequest' => 'Contacts.CNSaveRequest, Xamarin.Mac' */ },
		{ NULL, 0x11DC9C /* 'NSSpeechSynthesizer' => 'AppKit.NSSpeechSynthesizer, Xamarin.Mac' */ },
		{ NULL, 0x11E39C /* 'MDLMeshBufferDataAllocator' => 'ModelIO.MDLMeshBufferDataAllocator, Xamarin.Mac' */ },
		{ NULL, 0x11E49C /* 'GLKEffectPropertyFog' => 'GLKit.GLKEffectPropertyFog, Xamarin.Mac' */ },
		{ NULL, 0x11E59C /* 'NSDateIntervalFormatter' => 'Foundation.NSDateIntervalFormatter, Xamarin.Mac' */ },
		{ NULL, 0x11EC9C /* 'MDLMeshBufferMap' => 'ModelIO.MDLMeshBufferMap, Xamarin.Mac' */ },
		{ NULL, 0x11EE9C /* 'GLKEffectPropertyLight' => 'GLKit.GLKEffectPropertyLight, Xamarin.Mac' */ },
		{ NULL, 0x11F89C /* 'GLKEffectPropertyMaterial' => 'GLKit.GLKEffectPropertyMaterial, Xamarin.Mac' */ },
		{ NULL, 0x11F99C /* 'MDLMeshBufferZoneDefault' => 'ModelIO.MDLMeshBufferZoneDefault, Xamarin.Mac' */ },
		{ NULL, 0x11FB9C /* 'NSSlider' => 'AppKit.NSSlider, Xamarin.Mac' */ },
		{ NULL, 0x11FD9C /* 'NSDecimalNumber' => 'Foundation.NSDecimalNumber, Xamarin.Mac' */ },
		{ NULL, 0x12069C /* 'SFContentBlockerState' => 'SafariServices.SFContentBlockerState, Xamarin.Mac' */ },
		{ NULL, 0x12079C /* 'GLKEffectPropertyTexture' => 'GLKit.GLKEffectPropertyTexture, Xamarin.Mac' */ },
		{ NULL, 0x12109C /* 'GLKEffectPropertyTransform' => 'GLKit.GLKEffectPropertyTransform, Xamarin.Mac' */ },
		{ NULL, 0x12149C /* 'MDLNormalMapTexture' => 'ModelIO.MDLNormalMapTexture, Xamarin.Mac' */ },
		{ NULL, 0x12189C /* 'GLKMeshBuffer' => 'GLKit.GLKMeshBuffer, Xamarin.Mac' */ },
		{ NULL, 0x12219C /* 'GLKMeshBufferAllocator' => 'GLKit.GLKMeshBufferAllocator, Xamarin.Mac' */ },
		{ NULL, 0x12229C /* 'MDLObjectContainer' => 'ModelIO.MDLObjectContainer, Xamarin.Mac' */ },
		{ NULL, 0x12329C /* 'NSDistantObjectRequest' => 'Foundation.NSDistantObjectRequest, Xamarin.Mac' */ },
		{ NULL, 0x12359C /* 'SFSafariExtensionViewController' => 'SafariServices.SFSafariExtensionViewController, Xamarin.Mac' */ },
		{ NULL, 0x12369C /* 'CAAnimationGroup' => 'CoreAnimation.CAAnimationGroup, Xamarin.Mac' */ },
		{ NULL, 0x12379C /* 'MDLPackedJointAnimation' => 'ModelIO.MDLPackedJointAnimation, Xamarin.Mac' */ },
		{ NULL, 0x12389C /* 'GLKReflectionMapEffect' => 'GLKit.GLKReflectionMapEffect, Xamarin.Mac' */ },
		{ NULL, 0x12399C /* 'NSDistributedLock' => 'Foundation.NSDistributedLock, Xamarin.Mac' */ },
		{ NULL, 0x123B9C /* 'MDLPathAssetResolver' => 'ModelIO.MDLPathAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x123C9C /* 'SFSafariPageProperties' => 'SafariServices.SFSafariPageProperties, Xamarin.Mac' */ },
		{ NULL, 0x123D9C /* 'GLKSkyboxEffect' => 'GLKit.GLKSkyboxEffect, Xamarin.Mac' */ },
		{ NULL, 0x123E9C /* 'MDLPhotometricLight' => 'ModelIO.MDLPhotometricLight, Xamarin.Mac' */ },
		{ NULL, 0x123F9C /* 'NSSplitViewController' => 'AppKit.NSSplitViewController, Xamarin.Mac' */ },
		{ NULL, 0x1329C /* 'NSNotificationCenter' => 'Foundation.NSNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x12419C /* 'NSDistributedNotificationCenter' => 'Foundation.NSDistributedNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x12429C /* 'GLKSubmesh' => 'GLKit.GLKSubmesh, Xamarin.Mac' */ },
		{ NULL, 0x12439C /* 'CAConstraint' => 'CoreAnimation.CAConstraint, Xamarin.Mac' */ },
		{ NULL, 0x12469C /* 'CAConstraintLayoutManager' => 'CoreAnimation.CAConstraintLayoutManager, Xamarin.Mac' */ },
		{ NULL, 0x12479C /* 'NSEnergyFormatter' => 'Foundation.NSEnergyFormatter, Xamarin.Mac' */ },
		{ NULL, 0x12489C /* 'GLKTextureInfo' => 'GLKit.GLKTextureInfo, Xamarin.Mac' */ },
		{ NULL, 0x12499C /* 'SFSafariToolbarItem' => 'SafariServices.SFSafariToolbarItem, Xamarin.Mac' */ },
		{ NULL, 0x12589C /* 'MDLScatteringFunction' => 'ModelIO.MDLScatteringFunction, Xamarin.Mac' */ },
		{ NULL, 0x12519C /* 'MDLPhysicallyPlausibleScatteringFunction' => 'ModelIO.MDLPhysicallyPlausibleScatteringFunction, Xamarin.Mac' */ },
		{ NULL, 0x12539C /* 'MDLRelativeAssetResolver' => 'ModelIO.MDLRelativeAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x12559C /* 'CAEmitterBehavior' => 'CoreAnimation.CAEmitterBehavior, Xamarin.Mac' */ },
		{ NULL, 0x12569C /* 'NSSplitViewItem' => 'AppKit.NSSplitViewItem, Xamarin.Mac' */ },
		{ NULL, 0x13CF9C /* 'SCNConstraint' => 'SceneKit.SCNConstraint, Xamarin.Mac' */ },
		{ NULL, 0x12579C /* 'SCNAccelerationConstraint' => 'SceneKit.SCNAccelerationConstraint, Xamarin.Mac' */ },
		{ NULL, 0x12599C /* 'NSError' => 'Foundation.NSError, Xamarin.Mac' */ },
		{ NULL, 0x125E9C /* 'MDLSkeleton' => 'ModelIO.MDLSkeleton, Xamarin.Mac' */ },
		{ NULL, 0x125F9C /* 'NSException' => 'Foundation.NSException, Xamarin.Mac' */ },
		{ NULL, 0x12649C /* 'NSStatusBar' => 'AppKit.NSStatusBar, Xamarin.Mac' */ },
		{ NULL, 0x12659C /* 'MDLSkyCubeTexture' => 'ModelIO.MDLSkyCubeTexture, Xamarin.Mac' */ },
		{ NULL, 0x12669C /* 'CAEmitterCell' => 'CoreAnimation.CAEmitterCell, Xamarin.Mac' */ },
		{ NULL, 0x126C9C /* 'NSStackView' => 'AppKit.NSStackView, Xamarin.Mac' */ },
		{ NULL, 0x12709C /* 'MDLStereoscopicCamera' => 'ModelIO.MDLStereoscopicCamera, Xamarin.Mac' */ },
		{ NULL, 0x12799C /* 'CAEmitterLayer' => 'CoreAnimation.CAEmitterLayer, Xamarin.Mac' */ },
		{ NULL, 0x127C9C /* 'NSTextContainer' => 'AppKit.NSTextContainer, Xamarin.Mac' */ },
		{ NULL, 0x12809C /* 'NSExtensionItem' => 'Foundation.NSExtensionItem, Xamarin.Mac' */ },
		{ NULL, 0x12819C /* 'MDLSubmesh' => 'ModelIO.MDLSubmesh, Xamarin.Mac' */ },
		{ NULL, 0x12869C /* 'NSStatusBarButton' => 'AppKit.NSStatusBarButton, Xamarin.Mac' */ },
		{ NULL, 0x12879C /* 'NSToolbarItem' => 'AppKit.NSToolbarItem, Xamarin.Mac' */ },
		{ NULL, 0x12889C /* 'NSFileAccessIntent' => 'Foundation.NSFileAccessIntent, Xamarin.Mac' */ },
		{ NULL, 0x12899C /* 'NSTouch' => 'AppKit.NSTouch, Xamarin.Mac' */ },
		{ NULL, 0x128A9C /* 'MDLSubmeshTopology' => 'ModelIO.MDLSubmeshTopology, Xamarin.Mac' */ },
		{ NULL, 0x128E9C /* 'NSTreeController' => 'AppKit.NSTreeController, Xamarin.Mac' */ },
		{ NULL, 0x12929C /* 'NSFileCoordinator' => 'Foundation.NSFileCoordinator, Xamarin.Mac' */ },
		{ NULL, 0x14899C /* 'NSTextBlock' => 'AppKit.NSTextBlock, Xamarin.Mac' */ },
		{ NULL, 0x12939C /* 'NSTextTableBlock' => 'AppKit.NSTextTableBlock, Xamarin.Mac' */ },
		{ NULL, 0x12949C /* 'SCNAnimation' => 'SceneKit.SCNAnimation, Xamarin.Mac' */ },
		{ NULL, 0x12969C /* 'SCNAnimationEvent' => 'SceneKit.SCNAnimationEvent, Xamarin.Mac' */ },
		{ NULL, 0x12979C /* 'NSStepper' => 'AppKit.NSStepper, Xamarin.Mac' */ },
		{ NULL, 0x129B9C /* 'NSStepperCell' => 'AppKit.NSStepperCell, Xamarin.Mac' */ },
		{ NULL, 0x129E9C /* 'MDLTextureFilter' => 'ModelIO.MDLTextureFilter, Xamarin.Mac' */ },
		{ NULL, 0x129F9C /* 'NSStoryboard' => 'AppKit.NSStoryboard, Xamarin.Mac' */ },
		{ NULL, 0x12A29C /* 'MDLTextureSampler' => 'ModelIO.MDLTextureSampler, Xamarin.Mac' */ },
		{ NULL, 0x12A39C /* 'NSSliderAccessoryBehavior' => 'AppKit.NSSliderAccessoryBehavior, Xamarin.Mac' */ },
		{ NULL, 0x12A49C /* 'NSStoryboardSegue' => 'AppKit.NSStoryboardSegue, Xamarin.Mac' */ },
		{ NULL, 0x12A59C /* 'SCNAnimationPlayer' => 'SceneKit.SCNAnimationPlayer, Xamarin.Mac' */ },
		{ NULL, 0x12B29C /* 'SCNAudioPlayer' => 'SceneKit.SCNAudioPlayer, Xamarin.Mac' */ },
		{ NULL, 0x12B39C /* 'NSSliderCell' => 'AppKit.NSSliderCell, Xamarin.Mac' */ },
		{ NULL, 0x12B59C /* 'SCNAudioSource' => 'SceneKit.SCNAudioSource, Xamarin.Mac' */ },
		{ NULL, 0x12B79C /* 'SCNAvoidOccluderConstraint' => 'SceneKit.SCNAvoidOccluderConstraint, Xamarin.Mac' */ },
		{ NULL, 0x12DE9C /* 'NSStringDrawingContext' => 'AppKit.NSStringDrawingContext, Xamarin.Mac' */ },
		{ NULL, 0x12DF9C /* 'SCNBillboardConstraint' => 'SceneKit.SCNBillboardConstraint, Xamarin.Mac' */ },
		{ NULL, 0x12E09C /* 'MDLTransformMatrixOp' => 'ModelIO.MDLTransformMatrixOp, Xamarin.Mac' */ },
		{ NULL, 0x12F79C /* 'SCNBox' => 'SceneKit.SCNBox, Xamarin.Mac' */ },
		{ NULL, 0x12F89C /* 'MDLTransformRotateOp' => 'ModelIO.MDLTransformRotateOp, Xamarin.Mac' */ },
		{ NULL, 0x12FD9C /* 'NSTableCellView' => 'AppKit.NSTableCellView, Xamarin.Mac' */ },
		{ NULL, 0x12FF9C /* 'MDLTransformRotateXOp' => 'ModelIO.MDLTransformRotateXOp, Xamarin.Mac' */ },
		{ NULL, 0x130E9C /* 'MDLTransformRotateYOp' => 'ModelIO.MDLTransformRotateYOp, Xamarin.Mac' */ },
		{ NULL, 0x13159C /* 'NSTableColumn' => 'AppKit.NSTableColumn, Xamarin.Mac' */ },
		{ NULL, 0x13169C /* 'MDLTransformRotateZOp' => 'ModelIO.MDLTransformRotateZOp, Xamarin.Mac' */ },
		{ NULL, 0x131A9C /* 'CAMetalLayer' => 'CoreAnimation.CAMetalLayer, Xamarin.Mac' */ },
		{ NULL, 0x131B9C /* 'NSFileProviderService' => 'Foundation.NSFileProviderService, Xamarin.Mac' */ },
		{ NULL, 0x131C9C /* 'NSTableHeaderCell' => 'AppKit.NSTableHeaderCell, Xamarin.Mac' */ },
		{ NULL, 0x131D9C /* 'MDLTransformScaleOp' => 'ModelIO.MDLTransformScaleOp, Xamarin.Mac' */ },
		{ NULL, 0x133D9C /* 'NSTableHeaderView' => 'AppKit.NSTableHeaderView, Xamarin.Mac' */ },
		{ NULL, 0x134A9C /* 'MDLTransformStack' => 'ModelIO.MDLTransformStack, Xamarin.Mac' */ },
		{ NULL, 0x134B9C /* 'CAReplicatorLayer' => 'CoreAnimation.CAReplicatorLayer, Xamarin.Mac' */ },
		{ NULL, 0x13519C /* 'MDLTransformTranslateOp' => 'ModelIO.MDLTransformTranslateOp, Xamarin.Mac' */ },
		{ NULL, 0x13529C /* 'NSTableRowView' => 'AppKit.NSTableRowView, Xamarin.Mac' */ },
		{ NULL, 0x13579C /* 'NSFileWrapper' => 'Foundation.NSFileWrapper, Xamarin.Mac' */ },
		{ NULL, 0x13599C /* 'MDLURLTexture' => 'ModelIO.MDLUrlTexture, Xamarin.Mac' */ },
		{ NULL, 0x135A9C /* 'IKFilterBrowserView' => 'ImageKit.IKFilterBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x136D9C /* 'MDLVertexAttribute' => 'ModelIO.MDLVertexAttribute, Xamarin.Mac' */ },
		{ NULL, 0x13709C /* 'IKFilterUIView' => 'ImageKit.IKFilterUIView, Xamarin.Mac' */ },
		{ NULL, 0x13719C /* 'CAShapeLayer' => 'CoreAnimation.CAShapeLayer, Xamarin.Mac' */ },
		{ NULL, 0x13729C /* 'MDLVertexAttributeData' => 'ModelIO.MDLVertexAttributeData, Xamarin.Mac' */ },
		{ NULL, 0x13739C /* 'SCNCamera' => 'SceneKit.SCNCamera, Xamarin.Mac' */ },
		{ NULL, 0x13769C /* 'CASpringAnimation' => 'CoreAnimation.CASpringAnimation, Xamarin.Mac' */ },
		{ NULL, 0x13779C /* 'IKImageBrowserCell' => 'ImageKit.IKImageBrowserCell, Xamarin.Mac' */ },
		{ NULL, 0x137F9C /* 'MDLVertexBufferLayout' => 'ModelIO.MDLVertexBufferLayout, Xamarin.Mac' */ },
		{ NULL, 0x13919C /* 'SCNCameraController' => 'SceneKit.SCNCameraController, Xamarin.Mac' */ },
		{ NULL, 0x13929C /* 'NSHTTPURLResponse' => 'Foundation.NSHttpUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x13939C /* 'NSTableViewRowAction' => 'AppKit.NSTableViewRowAction, Xamarin.Mac' */ },
		{ NULL, 0x13989C /* 'CATiledLayer' => 'CoreAnimation.CATiledLayer, Xamarin.Mac' */ },
		{ NULL, 0x13A39C /* 'MDLVoxelArray' => 'ModelIO.MDLVoxelArray, Xamarin.Mac' */ },
		{ NULL, 0x13A59C /* 'SCNCapsule' => 'SceneKit.SCNCapsule, Xamarin.Mac' */ },
		{ NULL, 0x13A69C /* 'CATransaction' => 'CoreAnimation.CATransaction, Xamarin.Mac' */ },
		{ NULL, 0x13A99C /* 'CATransformLayer' => 'CoreAnimation.CATransformLayer, Xamarin.Mac' */ },
		{ NULL, 0x13B19C /* 'CATransition' => 'CoreAnimation.CATransition, Xamarin.Mac' */ },
		{ NULL, 0x13B29C /* 'SCNCone' => 'SceneKit.SCNCone, Xamarin.Mac' */ },
		{ NULL, 0x13B39C /* 'CAValueFunction' => 'CoreAnimation.CAValueFunction, Xamarin.Mac' */ },
		{ NULL, 0x13BA9C /* 'NSInvocation' => 'Foundation.NSInvocation, Xamarin.Mac' */ },
		{ NULL, 0x13BB9C /* 'MCBrowserViewController' => 'MultipeerConnectivity.MCBrowserViewController, Xamarin.Mac' */ },
		{ NULL, 0x13C29C /* 'IKImageEditPanel' => 'ImageKit.IKImageEditPanel, Xamarin.Mac' */ },
		{ NULL, 0x13C79C /* 'NSISO8601DateFormatter' => 'Foundation.NSIso8601DateFormatter, Xamarin.Mac' */ },
		{ NULL, 0x13D59C /* 'NSTabViewController' => 'AppKit.NSTabViewController, Xamarin.Mac' */ },
		{ NULL, 0x13DB9C /* 'NSTextFinder' => 'AppKit.NSTextFinder, Xamarin.Mac' */ },
		{ NULL, 0x13E19C /* 'AUParameterNode' => 'AudioUnit.AUParameterNode, Xamarin.Mac' */ },
		{ NULL, 0x13DD9C /* 'AUParameter' => 'AudioUnit.AUParameter, Xamarin.Mac' */ },
		{ NULL, 0x13E69C /* 'SCNCylinder' => 'SceneKit.SCNCylinder, Xamarin.Mac' */ },
		{ NULL, 0x13EC9C /* 'MCNearbyServiceAdvertiser' => 'MultipeerConnectivity.MCNearbyServiceAdvertiser, Xamarin.Mac' */ },
		{ NULL, 0x13F09C /* 'SCNDistanceConstraint' => 'SceneKit.SCNDistanceConstraint, Xamarin.Mac' */ },
		{ NULL, 0x13F79C /* 'NSTabViewItem' => 'AppKit.NSTabViewItem, Xamarin.Mac' */ },
		{ NULL, 0x13FA9C /* 'IKImageView' => 'ImageKit.IKImageView, Xamarin.Mac' */ },
		{ NULL, 0x13FF9C /* 'CBATTRequest' => 'CoreBluetooth.CBATTRequest, Xamarin.Mac' */ },
		{ NULL, 0x14019C /* 'MCNearbyServiceBrowser' => 'MultipeerConnectivity.MCNearbyServiceBrowser, Xamarin.Mac' */ },
		{ NULL, 0x14029C /* 'CBAttribute' => 'CoreBluetooth.CBAttribute, Xamarin.Mac' */ },
		{ NULL, 0x14099C /* 'IKPictureTaker' => 'ImageKit.IKPictureTaker, Xamarin.Mac' */ },
		{ NULL, 0x14C39C /* 'CBPeer' => 'CoreBluetooth.CBPeer, Xamarin.Mac' */ },
		{ NULL, 0x14119C /* 'CBCentral' => 'CoreBluetooth.CBCentral, Xamarin.Mac' */ },
		{ NULL, 0x14129C /* 'SCNFloor' => 'SceneKit.SCNFloor, Xamarin.Mac' */ },
		{ NULL, 0x143B9C /* 'NSTextList' => 'AppKit.NSTextList, Xamarin.Mac' */ },
		{ NULL, 0x14469C /* 'NSTextAttachment' => 'AppKit.NSTextAttachment, Xamarin.Mac' */ },
		{ NULL, 0x145C9C /* 'IKSlideshow' => 'ImageKit.IKSlideshow, Xamarin.Mac' */ },
		{ NULL, 0x14609C /* 'NSTextAttachmentCell' => 'AppKit.NSTextAttachmentCell, Xamarin.Mac' */ },
		{ NULL, 0x14639C /* 'CBCharacteristic' => 'CoreBluetooth.CBCharacteristic, Xamarin.Mac' */ },
		{ NULL, 0x146B9C /* 'SCNGeometryElement' => 'SceneKit.SCNGeometryElement, Xamarin.Mac' */ },
		{ NULL, 0x147F9C /* 'CBDescriptor' => 'CoreBluetooth.CBDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x14849C /* 'INCallDestinationTypeResolutionResult' => 'Intents.INCallDestinationTypeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x148E9C /* 'NSTextTab' => 'AppKit.NSTextTab, Xamarin.Mac' */ },
		{ NULL, 0x14919C /* 'CBL2CAPChannel' => 'CoreBluetooth.CBL2CapChannel, Xamarin.Mac' */ },
		{ NULL, 0x14959C /* 'CBManager' => 'CoreBluetooth.CBManager, Xamarin.Mac' */ },
		{ NULL, 0x14969C /* 'NSLengthFormatter' => 'Foundation.NSLengthFormatter, Xamarin.Mac' */ },
		{ NULL, 0x14999C /* 'NSTextTable' => 'AppKit.NSTextTable, Xamarin.Mac' */ },
		{ NULL, 0x14A19C /* 'SCNGeometryTessellator' => 'SceneKit.SCNGeometryTessellator, Xamarin.Mac' */ },
		{ NULL, 0x14A39C /* 'INCallRecordTypeOptionsResolutionResult' => 'Intents.INCallRecordTypeOptionsResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x14AF9C /* 'CBMutableCharacteristic' => 'CoreBluetooth.CBMutableCharacteristic, Xamarin.Mac' */ },
		{ NULL, 0x14B79C /* 'CBMutableDescriptor' => 'CoreBluetooth.CBMutableDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x153D9C /* 'CBService' => 'CoreBluetooth.CBService, Xamarin.Mac' */ },
		{ NULL, 0x14BD9C /* 'CBMutableService' => 'CoreBluetooth.CBMutableService, Xamarin.Mac' */ },
		{ NULL, 0x14BE9C /* 'SCNHitTestResult' => 'SceneKit.SCNHitTestResult, Xamarin.Mac' */ },
		{ NULL, 0x14C49C /* 'NSLinguisticTagger' => 'Foundation.NSLinguisticTagger, Xamarin.Mac' */ },
		{ NULL, 0x14C79C /* 'INDateComponentsRange' => 'Intents.INDateComponentsRange, Xamarin.Mac' */ },
		{ NULL, 0x14C89C /* 'SCNIKConstraint' => 'SceneKit.SCNIKConstraint, Xamarin.Mac' */ },
		{ NULL, 0x14CB9C /* 'INDateComponentsRangeResolutionResult' => 'Intents.INDateComponentsRangeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x14CD9C /* 'NSTrackingArea' => 'AppKit.NSTrackingArea, Xamarin.Mac' */ },
		{ NULL, 0x14DC9C /* 'INImage' => 'Intents.INImage, Xamarin.Mac' */ },
		{ NULL, 0x14E99C /* 'NSLock' => 'Foundation.NSLock, Xamarin.Mac' */ },
		{ NULL, 0x14F29C /* 'NSMachPort' => 'Foundation.NSMachPort, Xamarin.Mac' */ },
		{ NULL, 0x14F49C /* 'NSTreeNode' => 'AppKit.NSTreeNode, Xamarin.Mac' */ },
		{ NULL, 0x15059C /* 'INIntentResponse' => 'Intents.INIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x15069C /* 'NSMassFormatter' => 'Foundation.NSMassFormatter, Xamarin.Mac' */ },
		{ NULL, 0x15089C /* 'SCNLevelOfDetail' => 'SceneKit.SCNLevelOfDetail, Xamarin.Mac' */ },
		{ NULL, 0x150A9C /* 'NSMeasurement' => 'Foundation.NSMeasurement`1, Xamarin.Mac' */ },
		{ NULL, 0x15169C /* 'NSMeasurementFormatter' => 'Foundation.NSMeasurementFormatter, Xamarin.Mac' */ },
		{ NULL, 0x151D9C /* 'NSUserDefaultsController' => 'AppKit.NSUserDefaultsController, Xamarin.Mac' */ },
		{ NULL, 0x151E9C /* 'INMessage' => 'Intents.INMessage, Xamarin.Mac' */ },
		{ NULL, 0x1AC99C /* 'SKRequest' => 'StoreKit.SKRequest, Xamarin.Mac' */ },
		{ NULL, 0x151F9C /* 'SKReceiptRefreshRequest' => 'StoreKit.SKReceiptRefreshRequest, Xamarin.Mac' */ },
		{ NULL, 0x15249C /* 'SKPayment' => 'StoreKit.SKPayment, Xamarin.Mac' */ },
		{ NULL, 0x152F9C /* 'NSUserInterfaceCompressionOptions' => 'AppKit.NSUserInterfaceCompressionOptions, Xamarin.Mac' */ },
		{ NULL, 0x15339C /* 'SCNLight' => 'SceneKit.SCNLight, Xamarin.Mac' */ },
		{ NULL, 0x15539C /* 'INPerson' => 'Intents.INPerson, Xamarin.Mac' */ },
		{ NULL, 0x15559C /* 'SCNLookAtConstraint' => 'SceneKit.SCNLookAtConstraint, Xamarin.Mac' */ },
		{ NULL, 0x15589C /* 'INPersonHandle' => 'Intents.INPersonHandle, Xamarin.Mac' */ },
		{ NULL, 0x15609C /* 'NSAsynchronousFetchRequest' => 'CoreData.NSAsynchronousFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0x17029C /* 'NSPersistentStoreAsynchronousResult' => 'CoreData.NSPersistentStoreAsynchronousResult, Xamarin.Mac' */ },
		{ NULL, 0x15669C /* 'NSAsynchronousFetchResult' => 'CoreData.NSAsynchronousFetchResult, Xamarin.Mac' */ },
		{ NULL, 0x156E9C /* 'NSAtomicStore' => 'CoreData.NSAtomicStore, Xamarin.Mac' */ },
		{ NULL, 0x156F9C /* 'NSTitlebarAccessoryViewController' => 'AppKit.NSTitlebarAccessoryViewController, Xamarin.Mac' */ },
		{ NULL, 0x15719C /* 'INPersonResolutionResult' => 'Intents.INPersonResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x15749C /* 'NSAtomicStoreCacheNode' => 'CoreData.NSAtomicStoreCacheNode, Xamarin.Mac' */ },
		{ NULL, 0x15789C /* 'INPlacemarkResolutionResult' => 'Intents.INPlacemarkResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x157B9C /* 'NSTokenField' => 'AppKit.NSTokenField, Xamarin.Mac' */ },
		{ NULL, 0x157C9C /* 'SCNMaterial' => 'SceneKit.SCNMaterial, Xamarin.Mac' */ },
		{ NULL, 0x15809C /* 'INRecurrenceRule' => 'Intents.INRecurrenceRule, Xamarin.Mac' */ },
		{ NULL, 0x15819C /* 'NSBatchDeleteRequest' => 'CoreData.NSBatchDeleteRequest, Xamarin.Mac' */ },
		{ NULL, 0x158D9C /* 'NSBatchDeleteResult' => 'CoreData.NSBatchDeleteResult, Xamarin.Mac' */ },
		{ NULL, 0x15919C /* 'VNDetectBarcodesRequest' => 'Vision.VNDetectBarcodesRequest, Xamarin.Mac' */ },
		{ NULL, 0x15939C /* 'NSBatchUpdateRequest' => 'CoreData.NSBatchUpdateRequest, Xamarin.Mac' */ },
		{ NULL, 0x1AE49C /* 'VNFaceLandmarkRegion' => 'Vision.VNFaceLandmarkRegion, Xamarin.Mac' */ },
		{ NULL, 0x15949C /* 'VNFaceLandmarkRegion2D' => 'Vision.VNFaceLandmarkRegion2D, Xamarin.Mac' */ },
		{ NULL, 0x159B9C /* 'NSBatchUpdateResult' => 'CoreData.NSBatchUpdateResult, Xamarin.Mac' */ },
		{ NULL, 0x159D9C /* 'SCNMaterialProperty' => 'SceneKit.SCNMaterialProperty, Xamarin.Mac' */ },
		{ NULL, 0x15A59C /* 'INSearchCallHistoryIntentResponse' => 'Intents.INSearchCallHistoryIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x15A69C /* 'NSConstraintConflict' => 'CoreData.NSConstraintConflict, Xamarin.Mac' */ },
		{ NULL, 0x15AA9C /* 'NSMetadataQueryAttributeValueTuple' => 'Foundation.NSMetadataQueryAttributeValueTuple, Xamarin.Mac' */ },
		{ NULL, 0x15BA9C /* 'NSMetadataQueryResultGroup' => 'Foundation.NSMetadataQueryResultGroup, Xamarin.Mac' */ },
		{ NULL, 0x15C09C /* 'NSMethodSignature' => 'Foundation.NSMethodSignature, Xamarin.Mac' */ },
		{ NULL, 0x15C29C /* 'INSearchForMessagesIntent' => 'Intents.INSearchForMessagesIntent, Xamarin.Mac' */ },
		{ NULL, 0x15C89C /* 'SCNMorpher' => 'SceneKit.SCNMorpher, Xamarin.Mac' */ },
		{ NULL, 0x15CB9C /* 'NSToolbarItemGroup' => 'AppKit.NSToolbarItemGroup, Xamarin.Mac' */ },
		{ NULL, 0x15CC9C /* 'NSEntityMapping' => 'CoreData.NSEntityMapping, Xamarin.Mac' */ },
		{ NULL, 0x15CE9C /* 'INSearchForMessagesIntentResponse' => 'Intents.INSearchForMessagesIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x15F99C /* 'NSMutableCharacterSet' => 'Foundation.NSMutableCharacterSet, Xamarin.Mac' */ },
		{ NULL, 0x15FD9C /* 'NSEntityMigrationPolicy' => 'CoreData.NSEntityMigrationPolicy, Xamarin.Mac' */ },
		{ NULL, 0x16029C /* 'INSendMessageIntent' => 'Intents.INSendMessageIntent, Xamarin.Mac' */ },
		{ NULL, 0x16059C /* 'NSExpressionDescription' => 'CoreData.NSExpressionDescription, Xamarin.Mac' */ },
		{ NULL, 0x16079C /* 'NSFetchedPropertyDescription' => 'CoreData.NSFetchedPropertyDescription, Xamarin.Mac' */ },
		{ NULL, 0x16119C /* 'NSFetchIndexDescription' => 'CoreData.NSFetchIndexDescription, Xamarin.Mac' */ },
		{ NULL, 0x16139C /* 'INSendMessageIntentResponse' => 'Intents.INSendMessageIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x16169C /* 'NSFetchIndexElementDescription' => 'CoreData.NSFetchIndexElementDescription, Xamarin.Mac' */ },
		{ NULL, 0x16179C /* 'INSpeakableStringResolutionResult' => 'Intents.INSpeakableStringResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x161A9C /* 'INSendMessageRecipientResolutionResult' => 'Intents.INSendMessageRecipientResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x16219C /* 'INStartAudioCallIntent' => 'Intents.INStartAudioCallIntent, Xamarin.Mac' */ },
		{ NULL, 0x16249C /* 'AUAudioUnitBus' => 'AudioUnit.AUAudioUnitBus, Xamarin.Mac' */ },
		{ NULL, 0x162C9C /* 'AUAudioUnitBusArray' => 'AudioUnit.AUAudioUnitBusArray, Xamarin.Mac' */ },
		{ NULL, 0x162D9C /* 'NSFetchRequest' => 'CoreData.NSFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0x162F9C /* 'INStartAudioCallIntentResponse' => 'Intents.INStartAudioCallIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x16399C /* 'AUAudioUnitPreset' => 'AudioUnit.AUAudioUnitPreset, Xamarin.Mac' */ },
		{ NULL, 0x163A9C /* 'NSFetchRequestExpression' => 'CoreData.NSFetchRequestExpression, Xamarin.Mac' */ },
		{ NULL, 0x163B9C /* 'JSManagedValue' => 'JavaScriptCore.JSManagedValue, Xamarin.Mac' */ },
		{ NULL, 0x163D9C /* 'INStartVideoCallIntent' => 'Intents.INStartVideoCallIntent, Xamarin.Mac' */ },
		{ NULL, 0x164F9C /* 'AUParameterGroup' => 'AudioUnit.AUParameterGroup, Xamarin.Mac' */ },
		{ NULL, 0x16579C /* 'INStartVideoCallIntentResponse' => 'Intents.INStartVideoCallIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x16599C /* 'NSIncrementalStore' => 'CoreData.NSIncrementalStore, Xamarin.Mac' */ },
		{ NULL, 0x165E9C /* 'NSIncrementalStoreNode' => 'CoreData.NSIncrementalStoreNode, Xamarin.Mac' */ },
		{ NULL, 0x16609C /* 'INStringResolutionResult' => 'Intents.INStringResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x166F9C /* 'JSVirtualMachine' => 'JavaScriptCore.JSVirtualMachine, Xamarin.Mac' */ },
		{ NULL, 0x16779C /* 'NSManagedObject' => 'CoreData.NSManagedObject, Xamarin.Mac' */ },
		{ NULL, 0x16789C /* 'AUParameterTree' => 'AudioUnit.AUParameterTree, Xamarin.Mac' */ },
		{ NULL, 0x16839C /* 'SCNParticlePropertyController' => 'SceneKit.SCNParticlePropertyController, Xamarin.Mac' */ },
		{ NULL, 0x16849C /* 'NCWidgetController' => 'NotificationCenter.NCWidgetController, Xamarin.Mac' */ },
		{ NULL, 0x16EC9C /* 'MKOverlayRenderer' => 'MapKit.MKOverlayRenderer, Xamarin.Mac' */ },
		{ NULL, 0x17929C /* 'MKOverlayPathRenderer' => 'MapKit.MKOverlayPathRenderer, Xamarin.Mac' */ },
		{ NULL, 0x16889C /* 'MKCircleRenderer' => 'MapKit.MKCircleRenderer, Xamarin.Mac' */ },
		{ NULL, 0x168F9C /* 'MKClusterAnnotation' => 'MapKit.MKClusterAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x16CF9C /* 'SCNPhysicsBehavior' => 'SceneKit.SCNPhysicsBehavior, Xamarin.Mac' */ },
		{ NULL, 0x16919C /* 'SCNPhysicsSliderJoint' => 'SceneKit.SCNPhysicsSliderJoint, Xamarin.Mac' */ },
		{ NULL, 0x169D9C /* 'NSManagedObjectID' => 'CoreData.NSManagedObjectID, Xamarin.Mac' */ },
		{ NULL, 0x16A39C /* 'MKDirectionsRequest' => 'MapKit.MKDirectionsRequest, Xamarin.Mac' */ },
		{ NULL, 0x16A49C /* 'AVAssetCache' => 'AVFoundation.AVAssetCache, Xamarin.Mac' */ },
		{ NULL, 0x16A59C /* 'NSManagedObjectModel' => 'CoreData.NSManagedObjectModel, Xamarin.Mac' */ },
		{ NULL, 0x16A69C /* 'MKDirectionsResponse' => 'MapKit.MKDirectionsResponse, Xamarin.Mac' */ },
		{ NULL, 0x16A79C /* 'MKAnnotationView' => 'MapKit.MKAnnotationView, Xamarin.Mac' */ },
		{ NULL, 0x16AB9C /* 'NSMappingModel' => 'CoreData.NSMappingModel, Xamarin.Mac' */ },
		{ NULL, 0x16AF9C /* 'MKCircle' => 'MapKit.MKCircle, Xamarin.Mac' */ },
		{ NULL, 0x16B09C /* 'MKDistanceFormatter' => 'MapKit.MKDistanceFormatter, Xamarin.Mac' */ },
		{ NULL, 0x16B19C /* 'SCNPhysicsVehicle' => 'SceneKit.SCNPhysicsVehicle, Xamarin.Mac' */ },
		{ NULL, 0x16B39C /* 'MKLocalSearchCompletion' => 'MapKit.MKLocalSearchCompletion, Xamarin.Mac' */ },
		{ NULL, 0x16BF9C /* 'NSMigrationManager' => 'CoreData.NSMigrationManager, Xamarin.Mac' */ },
		{ NULL, 0x16C49C /* 'MKLocalSearchRequest' => 'MapKit.MKLocalSearchRequest, Xamarin.Mac' */ },
		{ NULL, 0x16C99C /* 'MKLocalSearchResponse' => 'MapKit.MKLocalSearchResponse, Xamarin.Mac' */ },
		{ NULL, 0x16CA9C /* 'MKETAResponse' => 'MapKit.MKETAResponse, Xamarin.Mac' */ },
		{ NULL, 0x16CC9C /* 'SCNPhysicsBallSocketJoint' => 'SceneKit.SCNPhysicsBallSocketJoint, Xamarin.Mac' */ },
		{ NULL, 0x16D09C /* 'MKMapCamera' => 'MapKit.MKMapCamera, Xamarin.Mac' */ },
		{ NULL, 0x16D19C /* 'SCNPhysicsVehicleWheel' => 'SceneKit.SCNPhysicsVehicleWheel, Xamarin.Mac' */ },
		{ NULL, 0x16D29C /* 'NSPersistentHistoryChange' => 'CoreData.NSPersistentHistoryChange, Xamarin.Mac' */ },
		{ NULL, 0x16D69C /* 'NSPersistentHistoryChangeRequest' => 'CoreData.NSPersistentHistoryChangeRequest, Xamarin.Mac' */ },
		{ NULL, 0x16D99C /* 'AVAssetReader' => 'AVFoundation.AVAssetReader, Xamarin.Mac' */ },
		{ NULL, 0x16DA9C /* 'MKLocalSearchCompleter' => 'MapKit.MKLocalSearchCompleter, Xamarin.Mac' */ },
		{ NULL, 0x16DB9C /* 'NSPersistentHistoryResult' => 'CoreData.NSPersistentHistoryResult, Xamarin.Mac' */ },
		{ NULL, 0x16E19C /* 'MKMapSnapshot' => 'MapKit.MKMapSnapshot, Xamarin.Mac' */ },
		{ NULL, 0x16E79C /* 'AVAssetReaderAudioMixOutput' => 'AVFoundation.AVAssetReaderAudioMixOutput, Xamarin.Mac' */ },
		{ NULL, 0x16E89C /* 'SCNPhysicsBody' => 'SceneKit.SCNPhysicsBody, Xamarin.Mac' */ },
		{ NULL, 0x16EA9C /* 'NSPersistentHistoryToken' => 'CoreData.NSPersistentHistoryToken, Xamarin.Mac' */ },
		{ NULL, 0x16ED9C /* 'MKMapSnapshotOptions' => 'MapKit.MKMapSnapshotOptions, Xamarin.Mac' */ },
		{ NULL, 0x16F29C /* 'NSPersistentHistoryTransaction' => 'CoreData.NSPersistentHistoryTransaction, Xamarin.Mac' */ },
		{ NULL, 0x16F49C /* 'SCNPlane' => 'SceneKit.SCNPlane, Xamarin.Mac' */ },
		{ NULL, 0x16F79C /* 'AVAssetReaderOutputMetadataAdaptor' => 'AVFoundation.AVAssetReaderOutputMetadataAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x16F89C /* 'SCNPhysicsConeTwistJoint' => 'SceneKit.SCNPhysicsConeTwistJoint, Xamarin.Mac' */ },
		{ NULL, 0x16F99C /* 'MKPinAnnotationView' => 'MapKit.MKPinAnnotationView, Xamarin.Mac' */ },
		{ NULL, 0x16FB9C /* 'AVAssetReaderSampleReferenceOutput' => 'AVFoundation.AVAssetReaderSampleReferenceOutput, Xamarin.Mac' */ },
		{ NULL, 0x16FD9C /* 'SCNPhysicsContact' => 'SceneKit.SCNPhysicsContact, Xamarin.Mac' */ },
		{ NULL, 0x16FF9C /* 'MKPlacemark' => 'MapKit.MKPlacemark, Xamarin.Mac' */ },
		{ NULL, 0x17019C /* 'SCNProgram' => 'SceneKit.SCNProgram, Xamarin.Mac' */ },
		{ NULL, 0x17059C /* 'MKPointAnnotation' => 'MapKit.MKPointAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x170B9C /* 'AVAssetReaderTrackOutput' => 'AVFoundation.AVAssetReaderTrackOutput, Xamarin.Mac' */ },
		{ NULL, 0x17149C /* 'MKPolygonRenderer' => 'MapKit.MKPolygonRenderer, Xamarin.Mac' */ },
		{ NULL, 0x17179C /* 'SCNPhysicsField' => 'SceneKit.SCNPhysicsField, Xamarin.Mac' */ },
		{ NULL, 0x17239C /* 'MKPolylineRenderer' => 'MapKit.MKPolylineRenderer, Xamarin.Mac' */ },
		{ NULL, 0x172F9C /* 'SCNPyramid' => 'SceneKit.SCNPyramid, Xamarin.Mac' */ },
		{ NULL, 0x17309C /* 'AVAssetResourceLoader' => 'AVFoundation.AVAssetResourceLoader, Xamarin.Mac' */ },
		{ NULL, 0x17319C /* 'MKRoute' => 'MapKit.MKRoute, Xamarin.Mac' */ },
		{ NULL, 0x17349C /* 'SCNPhysicsHingeJoint' => 'SceneKit.SCNPhysicsHingeJoint, Xamarin.Mac' */ },
		{ NULL, 0x3F39C /* 'NSAnimation' => 'AppKit.NSAnimation, Xamarin.Mac' */ },
		{ NULL, 0x17359C /* 'NSViewAnimation' => 'AppKit.NSViewAnimation, Xamarin.Mac' */ },
		{ NULL, 0x17379C /* 'MKRouteStep' => 'MapKit.MKRouteStep, Xamarin.Mac' */ },
		{ NULL, 0x10E89C /* 'SCNNode' => 'SceneKit.SCNNode, Xamarin.Mac' */ },
		{ NULL, 0x17389C /* 'SCNReferenceNode' => 'SceneKit.SCNReferenceNode, Xamarin.Mac' */ },
		{ NULL, 0x17489C /* 'AVAssetResourceLoadingContentInformationRequest' => 'AVFoundation.AVAssetResourceLoadingContentInformationRequest, Xamarin.Mac' */ },
		{ NULL, 0x17589C /* 'MLMediaGroup' => 'MediaLibrary.MLMediaGroup, Xamarin.Mac' */ },
		{ NULL, 0x175D9C /* 'AVAssetResourceLoadingRequest' => 'AVFoundation.AVAssetResourceLoadingRequest, Xamarin.Mac' */ },
		{ NULL, 0x175F9C /* 'MLMediaLibrary' => 'MediaLibrary.MLMediaLibrary, Xamarin.Mac' */ },
		{ NULL, 0x17689C /* 'AVAssetResourceRenewalRequest' => 'AVFoundation.AVAssetResourceRenewalRequest, Xamarin.Mac' */ },
		{ NULL, 0x176C9C /* 'MKTileOverlay' => 'MapKit.MKTileOverlay, Xamarin.Mac' */ },
		{ NULL, 0x17829C /* 'MLMediaObject' => 'MediaLibrary.MLMediaObject, Xamarin.Mac' */ },
		{ NULL, 0x17859C /* 'SCNReplicatorConstraint' => 'SceneKit.SCNReplicatorConstraint, Xamarin.Mac' */ },
		{ NULL, 0x17889C /* 'NSVisualEffectView' => 'AppKit.NSVisualEffectView, Xamarin.Mac' */ },
		{ NULL, 0x178A9C /* 'MLMediaSource' => 'MediaLibrary.MLMediaSource, Xamarin.Mac' */ },
		{ NULL, 0x178D9C /* 'MPChangeLanguageOptionCommandEvent' => 'MediaPlayer.MPChangeLanguageOptionCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x178F9C /* 'MPChangePlaybackPositionCommand' => 'MediaPlayer.MPChangePlaybackPositionCommand, Xamarin.Mac' */ },
		{ NULL, 0x17919C /* 'MKTileOverlayRenderer' => 'MapKit.MKTileOverlayRenderer, Xamarin.Mac' */ },
		{ NULL, 0x17939C /* 'MPChangePlaybackPositionCommandEvent' => 'MediaPlayer.MPChangePlaybackPositionCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x17999C /* 'AVAssetTrackGroup' => 'AVFoundation.AVAssetTrackGroup, Xamarin.Mac' */ },
		{ NULL, 0x179A9C /* 'SCNShape' => 'SceneKit.SCNShape, Xamarin.Mac' */ },
		{ NULL, 0x17A39C /* 'MKUserLocation' => 'MapKit.MKUserLocation, Xamarin.Mac' */ },
		{ NULL, 0x17AE9C /* 'SCNSliderConstraint' => 'SceneKit.SCNSliderConstraint, Xamarin.Mac' */ },
		{ NULL, 0x17B19C /* 'SBElementArray' => 'ScriptingBridge.SBElementArray, Xamarin.Mac' */ },
		{ NULL, 0x17B79C /* 'SCNSphere' => 'SceneKit.SCNSphere, Xamarin.Mac' */ },
		{ NULL, 0x17B89C /* 'SBObject' => 'ScriptingBridge.SBObject, Xamarin.Mac' */ },
		{ NULL, 0x17C99C /* 'SK3DNode' => 'SpriteKit.SK3DNode, Xamarin.Mac' */ },
		{ NULL, 0x183D9C /* 'AVAssetWriterInput' => 'AVFoundation.AVAssetWriterInput, Xamarin.Mac' */ },
		{ NULL, 0x184B9C /* 'AVAssetWriterInputGroup' => 'AVFoundation.AVAssetWriterInputGroup, Xamarin.Mac' */ },
		{ NULL, 0x18509C /* '__MonoMac_NSActionDispatcher' => 'Foundation.NSActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x18519C /* '__MonoMac_ActionDispatcher' => 'Foundation.ActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x18529C /* '__Xamarin_NSTimerActionDispatcher' => 'Foundation.NSTimerActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x18539C /* '__MonoMac_NSAsyncActionDispatcher' => 'Foundation.NSAsyncActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x18599C /* 'NSAutoreleasePool' => 'Foundation.NSAutoreleasePool, Xamarin.Mac' */ },
		{ NULL, 0x185D9C /* 'AVAssetWriterInputMetadataAdaptor' => 'AVFoundation.AVAssetWriterInputMetadataAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x18609C /* 'SCNTimingFunction' => 'SceneKit.SCNTimingFunction, Xamarin.Mac' */ },
		{ NULL, 0x18619C /* 'AVAssetWriterInputPassDescription' => 'AVFoundation.AVAssetWriterInputPassDescription, Xamarin.Mac' */ },
		{ NULL, 0x18699C /* 'SCNTorus' => 'SceneKit.SCNTorus, Xamarin.Mac' */ },
		{ NULL, 0x186B9C /* 'AVAssetWriterInputPixelBufferAdaptor' => 'AVFoundation.AVAssetWriterInputPixelBufferAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x18759C /* 'SCNTransaction' => 'SceneKit.SCNTransaction, Xamarin.Mac' */ },
		{ NULL, 0x192D9C /* 'SKPhysicsJoint' => 'SpriteKit.SKPhysicsJoint, Xamarin.Mac' */ },
		{ NULL, 0x18769C /* 'SKPhysicsJointPin' => 'SpriteKit.SKPhysicsJointPin, Xamarin.Mac' */ },
		{ NULL, 0x18779C /* 'AVAsynchronousCIImageFilteringRequest' => 'AVFoundation.AVAsynchronousCIImageFilteringRequest, Xamarin.Mac' */ },
		{ NULL, 0x18799C /* 'SCNTransformConstraint' => 'SceneKit.SCNTransformConstraint, Xamarin.Mac' */ },
		{ NULL, 0x187A9C /* 'SKPhysicsJointSliding' => 'SpriteKit.SKPhysicsJointSliding, Xamarin.Mac' */ },
		{ NULL, 0x187E9C /* 'SKPhysicsJointSpring' => 'SpriteKit.SKPhysicsJointSpring, Xamarin.Mac' */ },
		{ NULL, 0x18859C /* 'AVAsynchronousVideoCompositionRequest' => 'AVFoundation.AVAsynchronousVideoCompositionRequest, Xamarin.Mac' */ },
		{ NULL, 0x18879C /* 'SCNTube' => 'SceneKit.SCNTube, Xamarin.Mac' */ },
		{ NULL, 0x188C9C /* 'SKLabelNode' => 'SpriteKit.SKLabelNode, Xamarin.Mac' */ },
		{ NULL, 0x18959C /* 'SKRange' => 'SpriteKit.SKRange, Xamarin.Mac' */ },
		{ NULL, 0x18999C /* 'SKReachConstraints' => 'SpriteKit.SKReachConstraints, Xamarin.Mac' */ },
		{ NULL, 0x189B9C /* 'SKLightNode' => 'SpriteKit.SKLightNode, Xamarin.Mac' */ },
		{ NULL, 0x189D9C /* 'SKReferenceNode' => 'SpriteKit.SKReferenceNode, Xamarin.Mac' */ },
		{ NULL, 0x189A9C /* 'SKTexture' => 'SpriteKit.SKTexture, Xamarin.Mac' */ },
		{ NULL, 0x189E9C /* 'SKMutableTexture' => 'SpriteKit.SKMutableTexture, Xamarin.Mac' */ },
		{ NULL, 0x18A39C /* 'SKRegion' => 'SpriteKit.SKRegion, Xamarin.Mac' */ },
		{ NULL, 0x18A79C /* 'AVAudioCompressedBuffer' => 'AVFoundation.AVAudioCompressedBuffer, Xamarin.Mac' */ },
		{ NULL, 0x18AD9C /* 'SKRenderer' => 'SpriteKit.SKRenderer, Xamarin.Mac' */ },
		{ NULL, 0x18B19C /* 'SKAttribute' => 'SpriteKit.SKAttribute, Xamarin.Mac' */ },
		{ NULL, 0x18BD9C /* 'SKTileDefinition' => 'SpriteKit.SKTileDefinition, Xamarin.Mac' */ },
		{ NULL, 0x18BF9C /* 'SKTileGroup' => 'SpriteKit.SKTileGroup, Xamarin.Mac' */ },
		{ NULL, 0x1A6F9C /* 'SKEffectNode' => 'SpriteKit.SKEffectNode, Xamarin.Mac' */ },
		{ NULL, 0x18C19C /* 'SKScene' => 'SpriteKit.SKScene, Xamarin.Mac' */ },
		{ NULL, 0x18C39C /* 'AVAudioConverter' => 'AVFoundation.AVAudioConverter, Xamarin.Mac' */ },
		{ NULL, 0x18C99C /* 'SKTileGroupRule' => 'SpriteKit.SKTileGroupRule, Xamarin.Mac' */ },
		{ NULL, 0x18D09C /* 'SKView' => 'SpriteKit.SKView, Xamarin.Mac' */ },
		{ NULL, 0x18D29C /* 'SKAttributeValue' => 'SpriteKit.SKAttributeValue, Xamarin.Mac' */ },
		{ NULL, 0x18D49C /* 'SKShader' => 'SpriteKit.SKShader, Xamarin.Mac' */ },
		{ NULL, 0x191A9C /* 'SKPhysicsBody' => 'SpriteKit.SKPhysicsBody, Xamarin.Mac' */ },
		{ NULL, 0x191B9C /* 'SKTileMapNode' => 'SpriteKit.SKTileMapNode, Xamarin.Mac' */ },
		{ NULL, 0x191F9C /* 'SKPhysicsContact' => 'SpriteKit.SKPhysicsContact, Xamarin.Mac' */ },
		{ NULL, 0x19269C /* 'SKTileSet' => 'SpriteKit.SKTileSet, Xamarin.Mac' */ },
		{ NULL, 0x19279C /* 'SKAudioNode' => 'SpriteKit.SKAudioNode, Xamarin.Mac' */ },
		{ NULL, 0x1A2F9C /* 'SKPhysicsJointFixed' => 'SpriteKit.SKPhysicsJointFixed, Xamarin.Mac' */ },
		{ NULL, 0x1A339C /* 'SKTransformNode' => 'SpriteKit.SKTransformNode, Xamarin.Mac' */ },
		{ NULL, 0x1A3C9C /* 'SKPhysicsJointLimit' => 'SpriteKit.SKPhysicsJointLimit, Xamarin.Mac' */ },
		{ NULL, 0x1A3D9C /* 'SKCameraNode' => 'SpriteKit.SKCameraNode, Xamarin.Mac' */ },
		{ NULL, 0x1A3E9C /* 'SKDownload' => 'StoreKit.SKDownload, Xamarin.Mac' */ },
		{ NULL, 0x1A4C9C /* 'SKTransition' => 'SpriteKit.SKTransition, Xamarin.Mac' */ },
		{ NULL, 0x1A4D9C /* 'SKConstraint' => 'SpriteKit.SKConstraint, Xamarin.Mac' */ },
		{ NULL, 0x1A4F9C /* 'AVAudioEnvironmentDistanceAttenuationParameters' => 'AVFoundation.AVAudioEnvironmentDistanceAttenuationParameters, Xamarin.Mac' */ },
		{ NULL, 0x1A509C /* 'SKCropNode' => 'SpriteKit.SKCropNode, Xamarin.Mac' */ },
		{ NULL, 0x1A519C /* 'SKMutablePayment' => 'StoreKit.SKMutablePayment, Xamarin.Mac' */ },
		{ NULL, 0x1A549C /* 'SKSpriteNode' => 'SpriteKit.SKSpriteNode, Xamarin.Mac' */ },
		{ NULL, 0x1A569C /* 'SKPaymentQueue' => 'StoreKit.SKPaymentQueue, Xamarin.Mac' */ },
		{ NULL, 0x1A6C9C /* 'AVAudioEnvironmentNode' => 'AVFoundation.AVAudioEnvironmentNode, Xamarin.Mac' */ },
		{ NULL, 0x1A6E9C /* 'SKProduct' => 'StoreKit.SKProduct, Xamarin.Mac' */ },
		{ NULL, 0x1A709C /* 'SKPaymentTransaction' => 'StoreKit.SKPaymentTransaction, Xamarin.Mac' */ },
		{ NULL, 0x1A719C /* 'AVAudioEnvironmentReverbParameters' => 'AVFoundation.AVAudioEnvironmentReverbParameters, Xamarin.Mac' */ },
		{ NULL, 0x1A729C /* 'SKProductDiscount' => 'StoreKit.SKProductDiscount, Xamarin.Mac' */ },
		{ NULL, 0x1A8C9C /* 'AVAudioFile' => 'AVFoundation.AVAudioFile, Xamarin.Mac' */ },
		{ NULL, 0x1A979C /* 'NSWindowController' => 'AppKit.NSWindowController, Xamarin.Mac' */ },
		{ NULL, 0x1AA79C /* 'SKProductsResponse' => 'StoreKit.SKProductsResponse, Xamarin.Mac' */ },
		{ NULL, 0x1AA89C /* 'VNDetectHorizonRequest' => 'Vision.VNDetectHorizonRequest, Xamarin.Mac' */ },
		{ NULL, 0x1AB49C /* 'SKProductSubscriptionPeriod' => 'StoreKit.SKProductSubscriptionPeriod, Xamarin.Mac' */ },
		{ NULL, 0x1AB59C /* 'VNBarcodeObservation' => 'Vision.VNBarcodeObservation, Xamarin.Mac' */ },
		{ NULL, 0x1ABD9C /* 'AVAudioIONode' => 'AVFoundation.AVAudioIONode, Xamarin.Mac' */ },
		{ NULL, 0x1ABA9C /* 'AVAudioInputNode' => 'AVFoundation.AVAudioInputNode, Xamarin.Mac' */ },
		{ NULL, 0x1ABB9C /* 'VNDetectRectanglesRequest' => 'Vision.VNDetectRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x1AC89C /* 'VNDetectTextRectanglesRequest' => 'Vision.VNDetectTextRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x1ACD9C /* 'VNClassificationObservation' => 'Vision.VNClassificationObservation, Xamarin.Mac' */ },
		{ NULL, 0x1AD19C /* 'VNCoreMLFeatureValueObservation' => 'Vision.VNCoreMLFeatureValueObservation, Xamarin.Mac' */ },
		{ NULL, 0x1AE59C /* 'SKEmitterNode' => 'SpriteKit.SKEmitterNode, Xamarin.Mac' */ },
		{ NULL, 0x1AE79C /* 'VNCoreMLModel' => 'Vision.VNCoreMLModel, Xamarin.Mac' */ },
		{ NULL, 0x1AE89C /* 'AVAudioMixerNode' => 'AVFoundation.AVAudioMixerNode, Xamarin.Mac' */ },
		{ NULL, 0x1AEE9C /* 'VNCoreMLRequest' => 'Vision.VNCoreMLRequest, Xamarin.Mac' */ },
		{ NULL, 0x1AEF9C /* 'VNFaceLandmarks' => 'Vision.VNFaceLandmarks, Xamarin.Mac' */ },
		{ NULL, 0x1AFB9C /* 'VNFaceLandmarks2D' => 'Vision.VNFaceLandmarks2D, Xamarin.Mac' */ },
		{ NULL, 0x1AFD9C /* 'SKFieldNode' => 'SpriteKit.SKFieldNode, Xamarin.Mac' */ },
		{ NULL, 0x1C4E9C /* 'VNFaceObservation' => 'Vision.VNFaceObservation, Xamarin.Mac' */ },
		{ NULL, 0x1C669C /* 'NSWindowTab' => 'AppKit.NSWindowTab, Xamarin.Mac' */ },
		{ NULL, 0x1C679C /* 'VNDetectFaceLandmarksRequest' => 'Vision.VNDetectFaceLandmarksRequest, Xamarin.Mac' */ },
		{ NULL, 0x1C689C /* 'AVAudioMixingDestination' => 'AVFoundation.AVAudioMixingDestination, Xamarin.Mac' */ },
		{ NULL, 0x1C6D9C /* 'VNDetectFaceRectanglesRequest' => 'Vision.VNDetectFaceRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x1C739C /* 'NSWindowTabGroup' => 'AppKit.NSWindowTabGroup, Xamarin.Mac' */ },
		{ NULL, 0x1CB59C /* 'AVAudioOutputNode' => 'AVFoundation.AVAudioOutputNode, Xamarin.Mac' */ },
		{ NULL, 0x1CB99C /* 'VNHomographicImageRegistrationRequest' => 'Vision.VNHomographicImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x1CC79C /* 'VNHorizonObservation' => 'Vision.VNHorizonObservation, Xamarin.Mac' */ },
		{ NULL, 0x1CC89C /* 'AVAudioPCMBuffer' => 'AVFoundation.AVAudioPcmBuffer, Xamarin.Mac' */ },
		{ NULL, 0xF259C /* 'NSDictionary' => 'Foundation.NSDictionary, Xamarin.Mac' */ },
		{ NULL, 0x1F9C /* 'NSMutableDictionary' => 'Foundation.NSMutableDictionary, Xamarin.Mac' */ },
		{ NULL, 0x249C /* 'NCWidgetListViewController' => 'NotificationCenter.NCWidgetListViewController, Xamarin.Mac' */ },
		{ NULL, 0x3C9C /* 'ACAccountStore' => 'Accounts.ACAccountStore, Xamarin.Mac' */ },
		{ NULL, 0x409C /* 'NSPersistentStoreCoordinator' => 'CoreData.NSPersistentStoreCoordinator, Xamarin.Mac' */ },
		{ NULL, 0x499C /* 'CNContactStore' => 'Contacts.CNContactStore, Xamarin.Mac' */ },
		{ NULL, 0x5B9C /* 'NCWidgetSearchViewController' => 'NotificationCenter.NCWidgetSearchViewController, Xamarin.Mac' */ },
		{ NULL, 0xEF9C /* 'NSNetService' => 'Foundation.NSNetService, Xamarin.Mac' */ },
		{ NULL, 0x1009C /* 'NSNetServiceBrowser' => 'Foundation.NSNetServiceBrowser, Xamarin.Mac' */ },
		{ NULL, 0x1129C /* 'AVAudioUnitComponent' => 'AVFoundation.AVAudioUnitComponent, Xamarin.Mac' */ },
		{ NULL, 0x2049C /* 'CLLocationManager' => 'CoreLocation.CLLocationManager, Xamarin.Mac' */ },
		{ NULL, 0x2509C /* 'AVCaptureDevice' => 'AVFoundation.AVCaptureDevice, Xamarin.Mac' */ },
		{ NULL, 0x3159C /* 'NSProcessInfo' => 'Foundation.NSProcessInfo, Xamarin.Mac' */ },
		{ NULL, 0x3549C /* 'NSProgress' => 'Foundation.NSProgress, Xamarin.Mac' */ },
		{ NULL, 0x3579C /* 'AVCaptureSession' => 'AVFoundation.AVCaptureSession, Xamarin.Mac' */ },
		{ NULL, 0x35E9C /* 'AVCaptureStillImageOutput' => 'AVFoundation.AVCaptureStillImageOutput, Xamarin.Mac' */ },
		{ NULL, 0x3909C /* 'AVCaptureVideoPreviewLayer' => 'AVFoundation.AVCaptureVideoPreviewLayer, Xamarin.Mac' */ },
		{ NULL, 0x3E99C /* 'EKEventStore' => 'EventKit.EKEventStore, Xamarin.Mac' */ },
		{ NULL, 0x45F9C /* 'GLKTextureLoader' => 'GLKit.GLKTextureLoader, Xamarin.Mac' */ },
		{ NULL, 0x4699C /* 'NSTask' => 'Foundation.NSTask, Xamarin.Mac' */ },
		{ NULL, 0x4789C /* 'NSApplication' => 'AppKit.NSApplication, Xamarin.Mac' */ },
		{ NULL, 0x4A09C /* 'NSThread' => 'Foundation.NSThread, Xamarin.Mac' */ },
		{ NULL, 0x4AE9C /* 'AVFragmentedMovie' => 'AVFoundation.AVFragmentedMovie, Xamarin.Mac' */ },
		{ NULL, 0x4BC9C /* 'AVFragmentedMovieTrack' => 'AVFoundation.AVFragmentedMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x4BF9C /* 'NSUbiquitousKeyValueStore' => 'Foundation.NSUbiquitousKeyValueStore, Xamarin.Mac' */ },
		{ NULL, 0x4D29C /* 'NSUndoManager' => 'Foundation.NSUndoManager, Xamarin.Mac' */ },
		{ NULL, 0x5239C /* 'MKDirections' => 'MapKit.MKDirections, Xamarin.Mac' */ },
		{ NULL, 0x52F9C /* 'MKLocalSearch' => 'MapKit.MKLocalSearch, Xamarin.Mac' */ },
		{ NULL, 0x5409C /* 'NSBrowser' => 'AppKit.NSBrowser, Xamarin.Mac' */ },
		{ NULL, 0xCA99C /* 'NSGestureRecognizer' => 'AppKit.NSGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x5439C /* 'NSClickGestureRecognizer' => 'AppKit.NSClickGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x5909C /* 'AVMIDIPlayer' => 'AVFoundation.AVMidiPlayer, Xamarin.Mac' */ },
		{ NULL, 0x5FC9C /* 'WebHistoryItem' => 'WebKit.WebHistoryItem, Xamarin.Mac' */ },
		{ NULL, 0x61A9C /* 'MDLMesh' => 'ModelIO.MDLMesh, Xamarin.Mac' */ },
		{ NULL, 0x61F9C /* 'NSURL' => 'Foundation.NSUrl, Xamarin.Mac' */ },
		{ NULL, 0x62B9C /* 'MCSession' => 'MultipeerConnectivity.MCSession, Xamarin.Mac' */ },
		{ NULL, 0x64B9C /* 'NSURLCache' => 'Foundation.NSUrlCache, Xamarin.Mac' */ },
		{ NULL, 0x6529C /* 'MTKTextureLoader' => 'MetalKit.MTKTextureLoader, Xamarin.Mac' */ },
		{ NULL, 0x6659C /* 'NSComboBox' => 'AppKit.NSComboBox, Xamarin.Mac' */ },
		{ NULL, 0x6699C /* 'NSURLConnection' => 'Foundation.NSUrlConnection, Xamarin.Mac' */ },
		{ NULL, 0x67A9C /* 'NSColor' => 'AppKit.NSColor, Xamarin.Mac' */ },
		{ NULL, 0x6A39C /* 'NSColorPanel' => 'AppKit.NSColorPanel, Xamarin.Mac' */ },
		{ NULL, 0x6AB9C /* 'NSURLCredentialStorage' => 'Foundation.NSUrlCredentialStorage, Xamarin.Mac' */ },
		{ NULL, 0x6BA9C /* 'NSDatePicker' => 'AppKit.NSDatePicker, Xamarin.Mac' */ },
		{ NULL, 0x6CD9C /* 'NSDatePickerCell' => 'AppKit.NSDatePickerCell, Xamarin.Mac' */ },
		{ NULL, 0x6E09C /* 'AVPlayerItem' => 'AVFoundation.AVPlayerItem, Xamarin.Mac' */ },
		{ NULL, 0x6ED9C /* 'WebView' => 'WebKit.WebView, Xamarin.Mac' */ },
		{ NULL, 0x7279C /* 'NSURLSession' => 'Foundation.NSUrlSession, Xamarin.Mac' */ },
		{ NULL, 0x7369C /* 'WKContentRuleListStore' => 'WebKit.WKContentRuleListStore, Xamarin.Mac' */ },
		{ NULL, 0x7449C /* 'WKHTTPCookieStore' => 'WebKit.WKHttpCookieStore, Xamarin.Mac' */ },
		{ NULL, 0x7719C /* 'NSDocument' => 'AppKit.NSDocument, Xamarin.Mac' */ },
		{ NULL, 0x7839C /* 'NSURLSessionStreamTask' => 'Foundation.NSUrlSessionStreamTask, Xamarin.Mac' */ },
		{ NULL, 0x7A29C /* 'AVPlayerItemVideoOutput' => 'AVFoundation.AVPlayerItemVideoOutput, Xamarin.Mac' */ },
		{ NULL, 0x7A89C /* 'NSEvent' => 'AppKit.NSEvent, Xamarin.Mac' */ },
		{ NULL, 0x7EC9C /* 'NSUserActivity' => 'Foundation.NSUserActivity, Xamarin.Mac' */ },
		{ NULL, 0x7FD9C /* 'AVRouteDetector' => 'AVFoundation.AVRouteDetector, Xamarin.Mac' */ },
		{ NULL, 0x8059C /* 'AVSampleBufferAudioRenderer' => 'AVFoundation.AVSampleBufferAudioRenderer, Xamarin.Mac' */ },
		{ NULL, 0x8089C /* 'NSFont' => 'AppKit.NSFont, Xamarin.Mac' */ },
		{ NULL, 0x8119C /* 'AVSampleBufferDisplayLayer' => 'AVFoundation.AVSampleBufferDisplayLayer, Xamarin.Mac' */ },
		{ NULL, 0x8159C /* 'NSUserDefaults' => 'Foundation.NSUserDefaults, Xamarin.Mac' */ },
		{ NULL, 0x8179C /* 'AVSampleBufferGenerator' => 'AVFoundation.AVSampleBufferGenerator, Xamarin.Mac' */ },
		{ NULL, 0x8189C /* 'WKWebsiteDataStore' => 'WebKit.WKWebsiteDataStore, Xamarin.Mac' */ },
		{ NULL, 0x81D9C /* 'AVSampleBufferRenderSynchronizer' => 'AVFoundation.AVSampleBufferRenderSynchronizer, Xamarin.Mac' */ },
		{ NULL, 0x82C9C /* 'WKWebView' => 'WebKit.WKWebView, Xamarin.Mac' */ },
		{ NULL, 0xC5F9C /* 'NSUserNotificationCenter' => 'Foundation.NSUserNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0xC7A9C /* 'CLGeocoder' => 'CoreLocation.CLGeocoder, Xamarin.Mac' */ },
		{ NULL, 0xC959C /* 'GCController' => 'GameController.GCController, Xamarin.Mac' */ },
		{ NULL, 0xCB89C /* 'NSDrawer' => 'AppKit.NSDrawer, Xamarin.Mac' */ },
		{ NULL, 0xCF39C /* 'GKAchievement' => 'GameKit.GKAchievement, Xamarin.Mac' */ },
		{ NULL, 0xD049C /* 'GKAchievementDescription' => 'GameKit.GKAchievementDescription, Xamarin.Mac' */ },
		{ NULL, 0xD7D9C /* 'GKGameCenterViewController' => 'GameKit.GKGameCenterViewController, Xamarin.Mac' */ },
		{ NULL, 0xD0C9C /* 'GKAchievementViewController' => 'GameKit.GKAchievementViewController, Xamarin.Mac' */ },
		{ NULL, 0xD529C /* 'NSHelpManager' => 'AppKit.NSHelpManager, Xamarin.Mac' */ },
		{ NULL, 0xD5B9C /* 'CBCentralManager' => 'CoreBluetooth.CBCentralManager, Xamarin.Mac' */ },
		{ NULL, 0xD5C9C /* 'CBPeripheralManager' => 'CoreBluetooth.CBPeripheralManager, Xamarin.Mac' */ },
		{ NULL, 0xD609C /* 'GKFriendRequestComposeViewController' => 'GameKit.GKFriendRequestComposeViewController, Xamarin.Mac' */ },
		{ NULL, 0xD6B9C /* 'CBPeripheral' => 'CoreBluetooth.CBPeripheral, Xamarin.Mac' */ },
		{ NULL, 0xD8B9C /* 'NSImage' => 'AppKit.NSImage, Xamarin.Mac' */ },
		{ NULL, 0xD9A9C /* 'GKGameSession' => 'GameKit.GKGameSession, Xamarin.Mac' */ },
		{ NULL, 0xDAE9C /* 'PDFDocument' => 'PdfKit.PdfDocument, Xamarin.Mac' */ },
		{ NULL, 0xDB39C /* 'NSMagnificationGestureRecognizer' => 'AppKit.NSMagnificationGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0xDE29C /* 'GKLeaderboard' => 'GameKit.GKLeaderboard, Xamarin.Mac' */ },
		{ NULL, 0xDF09C /* 'GKLeaderboardSet' => 'GameKit.GKLeaderboardSet, Xamarin.Mac' */ },
		{ NULL, 0xE019C /* 'GKLeaderboardViewController' => 'GameKit.GKLeaderboardViewController, Xamarin.Mac' */ },
		{ NULL, 0xEC59C /* 'GKPlayer' => 'GameKit.GKPlayer, Xamarin.Mac' */ },
		{ NULL, 0xE289C /* 'GKLocalPlayer' => 'GameKit.GKLocalPlayer, Xamarin.Mac' */ },
		{ NULL, 0xE4E9C /* 'GKMatch' => 'GameKit.GKMatch, Xamarin.Mac' */ },
		{ NULL, 0xE6A9C /* 'PDFThumbnailView' => 'PdfKit.PdfThumbnailView, Xamarin.Mac' */ },
		{ NULL, 0xE729C /* 'CKContainer' => 'CloudKit.CKContainer, Xamarin.Mac' */ },
		{ NULL, 0xE7A9C /* 'CKDatabase' => 'CloudKit.CKDatabase, Xamarin.Mac' */ },
		{ NULL, 0xE7C9C /* 'GKMatchmaker' => 'GameKit.GKMatchmaker, Xamarin.Mac' */ },
		{ NULL, 0xE849C /* 'GKMatchmakerViewController' => 'GameKit.GKMatchmakerViewController, Xamarin.Mac' */ },
		{ NULL, 0xE9D9C /* 'PDFView' => 'PdfKit.PdfView, Xamarin.Mac' */ },
		{ NULL, 0x11819C /* 'NSTableView' => 'AppKit.NSTableView, Xamarin.Mac' */ },
		{ NULL, 0xEB59C /* 'NSOutlineView' => 'AppKit.NSOutlineView, Xamarin.Mac' */ },
		{ NULL, 0xEB79C /* 'GKNotificationBanner' => 'GameKit.GKNotificationBanner, Xamarin.Mac' */ },
		{ NULL, 0xED69C /* 'GKSavedGame' => 'GameKit.GKSavedGame, Xamarin.Mac' */ },
		{ NULL, 0xEF79C /* 'GKScore' => 'GameKit.GKScore, Xamarin.Mac' */ },
		{ NULL, 0xEFA9C /* 'NSCalendar' => 'Foundation.NSCalendar, Xamarin.Mac' */ },
		{ NULL, 0xF0D9C /* 'NSPageController' => 'AppKit.NSPageController, Xamarin.Mac' */ },
		{ NULL, 0xF369C /* 'NSPanGestureRecognizer' => 'AppKit.NSPanGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0xF3B9C /* 'GKTurnBasedExchange' => 'GameKit.GKTurnBasedExchange, Xamarin.Mac' */ },
		{ NULL, 0xF579C /* 'NSFileManager' => 'Foundation.NSFileManager, Xamarin.Mac' */ },
		{ NULL, 0xF619C /* 'NSHost' => 'Foundation.NSHost, Xamarin.Mac' */ },
		{ NULL, 0xF669C /* 'GKTurnBasedMatch' => 'GameKit.GKTurnBasedMatch, Xamarin.Mac' */ },
		{ NULL, 0xF689C /* 'MPSNNGraph' => 'MetalPerformanceShaders.MPSNNGraph, Xamarin.Mac' */ },
		{ NULL, 0xF699C /* 'NSHTTPCookieStorage' => 'Foundation.NSHttpCookieStorage, Xamarin.Mac' */ },
		{ NULL, 0xF8D9C /* 'NSKeyedArchiver' => 'Foundation.NSKeyedArchiver, Xamarin.Mac' */ },
		{ NULL, 0xF969C /* 'NSKeyedUnarchiver' => 'Foundation.NSKeyedUnarchiver, Xamarin.Mac' */ },
		{ NULL, 0xFA09C /* 'NSLocale' => 'Foundation.NSLocale, Xamarin.Mac' */ },
		{ NULL, 0xFA49C /* 'NSPathCell' => 'AppKit.NSPathCell, Xamarin.Mac' */ },
		{ NULL, 0xFE29C /* 'FIFinderSync' => 'FinderSync.FIFinderSync, Xamarin.Mac' */ },
		{ NULL, 0xFEC9C /* 'FIFinderSyncController' => 'FinderSync.FIFinderSyncController, Xamarin.Mac' */ },
		{ NULL, 0x100E9C /* 'NSPopUpButtonCell' => 'AppKit.NSPopUpButtonCell, Xamarin.Mac' */ },
		{ NULL, 0x10299C /* 'NSPressGestureRecognizer' => 'AppKit.NSPressGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x107F9C /* 'NSPopover' => 'AppKit.NSPopover, Xamarin.Mac' */ },
		{ NULL, 0x10819C /* 'NSCache' => 'Foundation.NSCache, Xamarin.Mac' */ },
		{ NULL, 0x10A29C /* 'NSRotationGestureRecognizer' => 'AppKit.NSRotationGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x10AD9C /* 'NSItemProvider' => 'Foundation.NSItemProvider, Xamarin.Mac' */ },
		{ NULL, 0x11399C /* 'NSScreen' => 'AppKit.NSScreen, Xamarin.Mac' */ },
		{ NULL, 0x11449C /* 'NSScroller' => 'AppKit.NSScroller, Xamarin.Mac' */ },
		{ NULL, 0x116F9C /* 'NSScrollView' => 'AppKit.NSScrollView, Xamarin.Mac' */ },
		{ NULL, 0x11A09C /* 'NSSharingService' => 'AppKit.NSSharingService, Xamarin.Mac' */ },
		{ NULL, 0x11AE9C /* 'NSSound' => 'AppKit.NSSound, Xamarin.Mac' */ },
		{ NULL, 0x11BF9C /* 'NSSharingServicePicker' => 'AppKit.NSSharingServicePicker, Xamarin.Mac' */ },
		{ NULL, 0x11FA9C /* 'SFContentBlockerManager' => 'SafariServices.SFContentBlockerManager, Xamarin.Mac' */ },
		{ NULL, 0x12119C /* 'SFSafariApplication' => 'SafariServices.SFSafariApplication, Xamarin.Mac' */ },
		{ NULL, 0x12199C /* 'SFSafariExtensionHandler' => 'SafariServices.SFSafariExtensionHandler, Xamarin.Mac' */ },
		{ NULL, 0x121C9C /* 'NSSpellChecker' => 'AppKit.NSSpellChecker, Xamarin.Mac' */ },
		{ NULL, 0x12339C /* 'NSSplitView' => 'AppKit.NSSplitView, Xamarin.Mac' */ },
		{ NULL, 0x123A9C /* 'SFSafariPage' => 'SafariServices.SFSafariPage, Xamarin.Mac' */ },
		{ NULL, 0x12459C /* 'SFSafariTab' => 'SafariServices.SFSafariTab, Xamarin.Mac' */ },
		{ NULL, 0x12529C /* 'SFSafariWindow' => 'SafariServices.SFSafariWindow, Xamarin.Mac' */ },
		{ NULL, 0x12859C /* 'NSTextStorage' => 'AppKit.NSTextStorage, Xamarin.Mac' */ },
		{ NULL, 0x12919C /* 'NSWorkspace' => 'AppKit.NSWorkspace, Xamarin.Mac' */ },
		{ NULL, 0x12989C /* 'NSSliderAccessory' => 'AppKit.NSSliderAccessory, Xamarin.Mac' */ },
		{ NULL, 0x129C9C /* 'NSFileHandle' => 'Foundation.NSFileHandle, Xamarin.Mac' */ },
		{ NULL, 0x13179C /* 'IKCameraDeviceView' => 'ImageKit.IKCameraDeviceView, Xamarin.Mac' */ },
		{ NULL, 0x13429C /* 'NSFileVersion' => 'Foundation.NSFileVersion, Xamarin.Mac' */ },
		{ NULL, 0x13439C /* 'IKDeviceBrowserView' => 'ImageKit.IKDeviceBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x13559C /* 'IKFilterBrowserPanel' => 'ImageKit.IKFilterBrowserPanel, Xamarin.Mac' */ },
		{ NULL, 0x13B49C /* 'NSTabView' => 'AppKit.NSTabView, Xamarin.Mac' */ },
		{ NULL, 0x13BC9C /* 'IKImageBrowserView' => 'ImageKit.IKImageBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x14139C /* 'IKSaveOptions' => 'ImageKit.IKSaveOptions, Xamarin.Mac' */ },
		{ NULL, 0x14239C /* 'NSText' => 'AppKit.NSText, Xamarin.Mac' */ },
		{ NULL, 0x142D9C /* 'NSTextInputContext' => 'AppKit.NSTextInputContext, Xamarin.Mac' */ },
		{ NULL, 0x142F9C /* 'NSTextAlternatives' => 'AppKit.NSTextAlternatives, Xamarin.Mac' */ },
		{ NULL, 0x14319C /* 'IKScannerDeviceView' => 'ImageKit.IKScannerDeviceView, Xamarin.Mac' */ },
		{ NULL, 0x148A9C /* 'SBApplication' => 'ScriptingBridge.SBApplication, Xamarin.Mac' */ },
		{ NULL, 0x14A49C /* 'NSTouchBar' => 'AppKit.NSTouchBar, Xamarin.Mac' */ },
		{ NULL, 0x15009C /* 'SCNLayer' => 'SceneKit.SCNLayer, Xamarin.Mac' */ },
		{ NULL, 0x150B9C /* 'INInteraction' => 'Intents.INInteraction, Xamarin.Mac' */ },
		{ NULL, 0x151B9C /* 'SLRequest' => 'Social.SLRequest, Xamarin.Mac' */ },
		{ NULL, 0x15379C /* 'NSTextView' => 'AppKit.NSTextView, Xamarin.Mac' */ },
		{ NULL, 0x159E9C /* 'NSMetadataQuery' => 'Foundation.NSMetadataQuery, Xamarin.Mac' */ },
		{ NULL, 0x15AD9C /* 'NSToolbar' => 'AppKit.NSToolbar, Xamarin.Mac' */ },
		{ NULL, 0x167E9C /* 'LAContext' => 'LocalAuthentication.LAContext, Xamarin.Mac' */ },
		{ NULL, 0x168D9C /* 'NSManagedObjectContext' => 'CoreData.NSManagedObjectContext, Xamarin.Mac' */ },
		{ NULL, 0x16AE9C /* 'AVAssetExportSession' => 'AVFoundation.AVAssetExportSession, Xamarin.Mac' */ },
		{ NULL, 0x16CB9C /* 'NSPersistentContainer' => 'CoreData.NSPersistentContainer, Xamarin.Mac' */ },
		{ NULL, 0x16E49C /* 'SCNPhysicsWorld' => 'SceneKit.SCNPhysicsWorld, Xamarin.Mac' */ },
		{ NULL, 0x16F59C /* 'MKMapSnapshotter' => 'MapKit.MKMapSnapshotter, Xamarin.Mac' */ },
		{ NULL, 0x17399C /* 'MKMapView' => 'MapKit.MKMapView, Xamarin.Mac' */ },
		{ NULL, 0x17849C /* 'SCNRenderer' => 'SceneKit.SCNRenderer, Xamarin.Mac' */ },
		{ NULL, 0x17B99C /* 'AVAssetWriter' => 'AVFoundation.AVAssetWriter, Xamarin.Mac' */ },
		{ NULL, 0x188A9C /* 'SKPhysicsWorld' => 'SpriteKit.SKPhysicsWorld, Xamarin.Mac' */ },
		{ NULL, 0x189F9C /* 'SKTextureAtlas' => 'SpriteKit.SKTextureAtlas, Xamarin.Mac' */ },
		{ NULL, 0x18B09C /* 'SCNView' => 'SceneKit.SCNView, Xamarin.Mac' */ },
		{ NULL, 0x19289C /* 'AVAudioEngine' => 'AVFoundation.AVAudioEngine, Xamarin.Mac' */ },
		{ NULL, 0x1A949C /* 'SKProductsRequest' => 'StoreKit.SKProductsRequest, Xamarin.Mac' */ },
		{ NULL, 0x1D399C /* 'AVAudioPlayerNode' => 'AVFoundation.AVAudioPlayerNode, Xamarin.Mac' */ },
		{ NULL, 0x1D629C /* 'AUAudioUnit' => 'AudioUnit.AUAudioUnit, Xamarin.Mac' */ },
		{ NULL, 0x19A2 /* 'Xwt_Mac_WindowBackend' => 'Xwt.Mac.WindowBackend, Xwt.XamMac' */ },
		{ NULL, 0x400C /* 'MonoDevelop_MacIntegration_ThemedMacWindowBackend' => 'MonoDevelop.MacIntegration.ThemedMacWindowBackend, MacPlatform' */ },
		{ NULL, 0x6FA2 /* 'Xwt_Mac_DialogBackend' => 'Xwt.Mac.DialogBackend, Xwt.XamMac' */ },
		{ NULL, 0x410C /* 'MonoDevelop_MacIntegration_ThemedMacDialogBackend' => 'MonoDevelop.MacIntegration.ThemedMacDialogBackend, MacPlatform' */ },
		{ NULL, 0x54A2 /* 'Xwt_Mac_AlertDialogBackend' => 'Xwt.Mac.AlertDialogBackend, Xwt.XamMac' */ },
		{ NULL, 0x420C /* 'MonoDevelop_MacIntegration_ThemedMacAlertDialogBackend' => 'MonoDevelop.MacIntegration.ThemedMacAlertDialogBackend, MacPlatform' */ },
		{ NULL, 0x460C /* 'MonoDevelop_MacIntegration_MDLabel' => 'MonoDevelop.MacIntegration.MDLabel, MacPlatform' */ },
		{ NULL, 0x530C /* 'MonoDevelop_MacIntegration_AlertButtonWrapper' => 'MonoDevelop.MacIntegration.AlertButtonWrapper, MacPlatform' */ },
		{ NULL, 0x720C /* 'MonoDevelop_MacIntegration_MainToolbar_NSFocusButton' => 'MonoDevelop.MacIntegration.MainToolbar.NSFocusButton, MacPlatform' */ },
		{ NULL, 0x610C /* 'RunButton' => 'MonoDevelop.MacIntegration.MainToolbar.RunButton, MacPlatform' */ },
		{ NULL, 0x620C /* 'MonoDevelop_MacIntegration_MainToolbar_ColoredButtonCell' => 'MonoDevelop.MacIntegration.MainToolbar.ColoredButtonCell, MacPlatform' */ },
		{ NULL, 0x680C /* 'MonoDevelop_MacIntegration_MainToolbar_StatusIcon' => 'MonoDevelop.MacIntegration.MainToolbar.StatusIcon, MacPlatform' */ },
		{ NULL, 0x6B0C /* 'MonoDevelop_MacIntegration_MainToolbar_CancelButton' => 'MonoDevelop.MacIntegration.MainToolbar.CancelButton, MacPlatform' */ },
		{ NULL, 0x6D0C /* 'MonoDevelop_MacIntegration_MainToolbar_VerticallyCenteredTextFieldCell' => 'MonoDevelop.MacIntegration.MainToolbar.VerticallyCenteredTextFieldCell, MacPlatform' */ },
		{ NULL, 0x6E0C /* 'MonoDevelop_MacIntegration_MainToolbar_AwesomeBar' => 'MonoDevelop.MacIntegration.MainToolbar.AwesomeBar, MacPlatform' */ },
		{ NULL, 0x6F0C /* 'MonoDevelop_MacIntegration_MainToolbar_ButtonBarContainer' => 'MonoDevelop.MacIntegration.MainToolbar.ButtonBarContainer, MacPlatform' */ },
		{ NULL, 0xC90C /* 'MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingSource' => 'MonoDevelop.MacIntegration.SelectEncodingPanel+EncodingSource, MacPlatform' */ },
		{ NULL, 0xCA0C /* 'MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingAllDelegate' => 'MonoDevelop.MacIntegration.SelectEncodingPanel+EncodingAllDelegate, MacPlatform' */ },
		{ NULL, 0xCB0C /* 'MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingSelectedDelegate' => 'MonoDevelop.MacIntegration.SelectEncodingPanel+EncodingSelectedDelegate, MacPlatform' */ },
		{ NULL, 0x4A0C /* 'MonoDevelop_MacIntegration_SelectEncodingPanel' => 'MonoDevelop.MacIntegration.SelectEncodingPanel, MacPlatform' */ },
		{ NULL, 0x4B0C /* 'MonoDevelop_MacIntegration_SelectEncodingPopUpButton' => 'MonoDevelop.MacIntegration.SelectEncodingPopUpButton, MacPlatform' */ },
		{ NULL, 0xE00C /* 'MonoDevelop_MacIntegration_MainToolbar_SearchBar_DarkThemeSearchFieldCell' => 'MonoDevelop.MacIntegration.MainToolbar.SearchBar+DarkThemeSearchFieldCell, MacPlatform' */ },
		{ NULL, 0x630C /* 'MonoDevelop_MacIntegration_MainToolbar_SearchBar' => 'MonoDevelop.MacIntegration.MainToolbar.SearchBar, MacPlatform' */ },
		{ NULL, 0xE30C /* 'MonoDevelop_MacIntegration_MainToolbar_ButtonBar_DarkThemeSegmentedCell' => 'MonoDevelop.MacIntegration.MainToolbar.ButtonBar+DarkThemeSegmentedCell, MacPlatform' */ },
		{ NULL, 0x640C /* 'MonoDevelop_MacIntegration_MainToolbar_ButtonBar' => 'MonoDevelop.MacIntegration.MainToolbar.ButtonBar, MacPlatform' */ },
		{ NULL, 0x670C /* 'MonoDevelop_MacIntegration_MainToolbar_SelectorView' => 'MonoDevelop.MacIntegration.MainToolbar.SelectorView, MacPlatform' */ },
		{ NULL, 0x690C /* 'MonoDevelop_MacIntegration_MainToolbar_BuildResultsView' => 'MonoDevelop.MacIntegration.MainToolbar.BuildResultsView, MacPlatform' */ },
		{ NULL, 0x6A0C /* 'MonoDevelop_MacIntegration_MainToolbar_ProgressView' => 'MonoDevelop.MacIntegration.MainToolbar.ProgressView, MacPlatform' */ },
		{ NULL, 0x6C0C /* 'MonoDevelop_MacIntegration_MainToolbar_StatusBar' => 'MonoDevelop.MacIntegration.MainToolbar.StatusBar, MacPlatform' */ },
		{ NULL, 0xEE0C /* 'MonoDevelop_MacIntegration_MainToolbar_SelectorView_PathSelectorView_NSPathComponentCellFocusable' => 'MonoDevelop.MacIntegration.MainToolbar.SelectorView+PathSelectorView+NSPathComponentCellFocusable, MacPlatform' */ },
		{ NULL, 0xE50C /* 'MonoDevelop_MacIntegration_MainToolbar_SelectorView_PathSelectorView' => 'MonoDevelop.MacIntegration.MainToolbar.SelectorView+PathSelectorView, MacPlatform' */ },
		{ NULL, 0x8E60 /* 'MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementProxy' => 'MonoDevelop.Components.AtkCocoaHelper.RealAccessibilityElementProxy, MonoDevelop.Ide' */ },
		{ NULL, 0x8F60 /* 'MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementButtonProxy' => 'MonoDevelop.Components.AtkCocoaHelper.RealAccessibilityElementButtonProxy, MonoDevelop.Ide' */ },
		{ NULL, 0x9060 /* 'MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementNavigableStaticTextProxy' => 'MonoDevelop.Components.AtkCocoaHelper.RealAccessibilityElementNavigableStaticTextProxy, MonoDevelop.Ide' */ },
		{ NULL, 0x9260 /* 'MonoDevelop_Components_Mac_MDLinkMenuItem' => 'MonoDevelop.Components.Mac.MDLinkMenuItem, MonoDevelop.Ide' */ },
		{ NULL, 0x9660 /* 'MonoDevelop_Components_Mac_MDMenuHeaderItem' => 'MonoDevelop.Components.Mac.MDMenuHeaderItem, MonoDevelop.Ide' */ },
		{ NULL, 0x9760 /* 'MonoDevelop_Components_Mac_MDServicesMenuItem' => 'MonoDevelop.Components.Mac.MDServicesMenuItem, MonoDevelop.Ide' */ },
		{ NULL, 0x9360 /* 'MonoDevelop_Components_Mac_MDMenu' => 'MonoDevelop.Components.Mac.MDMenu, MonoDevelop.Ide' */ },
		{ NULL, 0x69560 /* 'MonoDevelop_Components_Mac_MDMenuItem_MDExpandedArrayItem' => 'MonoDevelop.Components.Mac.MDMenuItem+MDExpandedArrayItem, MonoDevelop.Ide' */ },
		{ NULL, 0x9560 /* 'MonoDevelop_Components_Mac_MDMenuItem' => 'MonoDevelop.Components.Mac.MDMenuItem, MonoDevelop.Ide' */ },
		{ NULL, 0x9860 /* 'MonoDevelop_Components_Mac_MDSubMenuItem' => 'MonoDevelop.Components.Mac.MDSubMenuItem, MonoDevelop.Ide' */ },
		{ NULL, 0x9E60 /* 'MonoDevelop_Components_Mac_GtkEmbed' => 'MonoDevelop.Components.Mac.GtkEmbed, MonoDevelop.Ide' */ },
		{ NULL, 0xAB560 /* 'MonoDevelop_Components_ContextMenuExtensionsMac_NSLocationAwareMenu_ContextMenuDelegate' => 'MonoDevelop.Components.ContextMenuExtensionsMac+NSLocationAwareMenu+ContextMenuDelegate, MonoDevelop.Ide' */ },
		{ NULL, 0x67760 /* 'MonoDevelop_Components_ContextMenuExtensionsMac_NSLocationAwareMenu' => 'MonoDevelop.Components.ContextMenuExtensionsMac+NSLocationAwareMenu, MonoDevelop.Ide' */ },
		{ NULL, 0x157E9C /* 'NETunnelNetworkSettings' => 'NetworkExtension.NETunnelNetworkSettings, Xamarin.Mac' */ },
		{ NULL, 0x6349C /* 'NEPacketTunnelNetworkSettings' => 'NetworkExtension.NEPacketTunnelNetworkSettings, Xamarin.Mac' */ },
		{ NULL, 0xEB99C /* 'PHAdjustmentData' => 'Photos.PHAdjustmentData, Xamarin.Mac' */ },
		{ NULL, 0xFCF9C /* 'PHObject' => 'Photos.PHObject, Xamarin.Mac' */ },
		{ NULL, 0xEC49C /* 'PHAsset' => 'Photos.PHAsset, Xamarin.Mac' */ },
		{ NULL, 0xF1E9C /* 'PHCollection' => 'Photos.PHCollection, Xamarin.Mac' */ },
		{ NULL, 0xEDD9C /* 'PHAssetCollection' => 'Photos.PHAssetCollection, Xamarin.Mac' */ },
		{ NULL, 0xF0C9C /* 'PHChange' => 'Photos.PHChange, Xamarin.Mac' */ },
		{ NULL, 0xF169C /* 'PHCloudIdentifier' => 'Photos.PHCloudIdentifier, Xamarin.Mac' */ },
		{ NULL, 0xF2D9C /* 'PHCollectionList' => 'Photos.PHCollectionList, Xamarin.Mac' */ },
		{ NULL, 0xF419C /* 'PHContentEditingInput' => 'Photos.PHContentEditingInput, Xamarin.Mac' */ },
		{ NULL, 0xF489C /* 'PHContentEditingOutput' => 'Photos.PHContentEditingOutput, Xamarin.Mac' */ },
		{ NULL, 0xF509C /* 'PHFetchOptions' => 'Photos.PHFetchOptions, Xamarin.Mac' */ },
		{ NULL, 0xF5E9C /* 'PHFetchResult' => 'Photos.PHFetchResult, Xamarin.Mac' */ },
		{ NULL, 0xF659C /* 'PHFetchResultChangeDetails' => 'Photos.PHFetchResultChangeDetails, Xamarin.Mac' */ },
		{ NULL, 0xF729C /* 'PHImageManager' => 'Photos.PHImageManager, Xamarin.Mac' */ },
		{ NULL, 0xF879C /* 'PHImageRequestOptions' => 'Photos.PHImageRequestOptions, Xamarin.Mac' */ },
		{ NULL, 0xF9F9C /* 'PHLivePhoto' => 'Photos.PHLivePhoto, Xamarin.Mac' */ },
		{ NULL, 0xFD69C /* 'EASession' => 'ExternalAccessory.EASession, Xamarin.Mac' */ },
		{ NULL, 0xFD79C /* 'PHObjectChangeDetails' => 'Photos.PHObjectChangeDetails, Xamarin.Mac' */ },
		{ NULL, 0xFF49C /* 'PHProject' => 'Photos.PHProject, Xamarin.Mac' */ },
		{ NULL, 0xFFE9C /* 'PHProjectChangeRequest' => 'Photos.PHProjectChangeRequest, Xamarin.Mac' */ },
		{ NULL, 0x101A9C /* 'PHProjectElement' => 'PhotosUI.PHProjectElement, Xamarin.Mac' */ },
		{ NULL, 0x10189C /* 'PHProjectAssetElement' => 'PhotosUI.PHProjectAssetElement, Xamarin.Mac' */ },
		{ NULL, 0x10219C /* 'PHProjectExtensionContext' => 'PhotosUI.PHProjectExtensionContext, Xamarin.Mac' */ },
		{ NULL, 0x102E9C /* 'PHProjectInfo' => 'PhotosUI.PHProjectInfo, Xamarin.Mac' */ },
		{ NULL, 0x10339C /* 'PHProjectJournalEntryElement' => 'PhotosUI.PHProjectJournalEntryElement, Xamarin.Mac' */ },
		{ NULL, 0x10359C /* 'PHProjectRegionOfInterest' => 'PhotosUI.PHProjectRegionOfInterest, Xamarin.Mac' */ },
		{ NULL, 0x10389C /* 'PHProjectSection' => 'PhotosUI.PHProjectSection, Xamarin.Mac' */ },
		{ NULL, 0x103B9C /* 'PHProjectSectionContent' => 'PhotosUI.PHProjectSectionContent, Xamarin.Mac' */ },
		{ NULL, 0x10419C /* 'PHProjectTextElement' => 'PhotosUI.PHProjectTextElement, Xamarin.Mac' */ },
		{ NULL, 0x104D9C /* 'PHProjectTypeDescription' => 'PhotosUI.PHProjectTypeDescription, Xamarin.Mac' */ },
		{ NULL, 0x11FC9C /* 'CNContactPicker' => 'ContactsUI.CNContactPicker, Xamarin.Mac' */ },
		{ NULL, 0x12139C /* 'CNContactViewController' => 'ContactsUI.CNContactViewController, Xamarin.Mac' */ },
		{ NULL, 0x13C19C /* 'AUAudioUnitViewConfiguration' => 'CoreAudioKit.AUAudioUnitViewConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x13D09C /* 'AUViewController' => 'CoreAudioKit.AUViewController, Xamarin.Mac' */ },
		{ NULL, 0x14979C /* 'NEAppRule' => 'NetworkExtension.NEAppRule, Xamarin.Mac' */ },
		{ NULL, 0x16109C /* 'NEVPNProtocol' => 'NetworkExtension.NEVpnProtocol, Xamarin.Mac' */ },
		{ NULL, 0x14A29C /* 'NEDNSProxyProviderProtocol' => 'NetworkExtension.NEDnsProxyProviderProtocol, Xamarin.Mac' */ },
		{ NULL, 0x14B59C /* 'NEDNSSettings' => 'NetworkExtension.NEDnsSettings, Xamarin.Mac' */ },
		{ NULL, 0x14BC9C /* 'NEEvaluateConnectionRule' => 'NetworkExtension.NEEvaluateConnectionRule, Xamarin.Mac' */ },
		{ NULL, 0x14EF9C /* 'NEFilterProviderConfiguration' => 'NetworkExtension.NEFilterProviderConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x14F19C /* 'NEFlowMetaData' => 'NetworkExtension.NEFlowMetaData, Xamarin.Mac' */ },
		{ NULL, 0x14FB9C /* 'NEIPv4Route' => 'NetworkExtension.NEIPv4Route, Xamarin.Mac' */ },
		{ NULL, 0x15079C /* 'NEIPv4Settings' => 'NetworkExtension.NEIPv4Settings, Xamarin.Mac' */ },
		{ NULL, 0x15099C /* 'NEIPv6Route' => 'NetworkExtension.NEIPv6Route, Xamarin.Mac' */ },
		{ NULL, 0x15149C /* 'NEIPv6Settings' => 'NetworkExtension.NEIPv6Settings, Xamarin.Mac' */ },
		{ NULL, 0x151A9C /* 'NEOnDemandRule' => 'NetworkExtension.NEOnDemandRule, Xamarin.Mac' */ },
		{ NULL, 0x15209C /* 'NEOnDemandRuleConnect' => 'NetworkExtension.NEOnDemandRuleConnect, Xamarin.Mac' */ },
		{ NULL, 0x152A9C /* 'NEOnDemandRuleDisconnect' => 'NetworkExtension.NEOnDemandRuleDisconnect, Xamarin.Mac' */ },
		{ NULL, 0x152E9C /* 'NEOnDemandRuleEvaluateConnection' => 'NetworkExtension.NEOnDemandRuleEvaluateConnection, Xamarin.Mac' */ },
		{ NULL, 0x15329C /* 'NEOnDemandRuleIgnore' => 'NetworkExtension.NEOnDemandRuleIgnore, Xamarin.Mac' */ },
		{ NULL, 0x154E9C /* 'NEPacket' => 'NetworkExtension.NEPacket, Xamarin.Mac' */ },
		{ NULL, 0x15709C /* 'NEProxyServer' => 'NetworkExtension.NEProxyServer, Xamarin.Mac' */ },
		{ NULL, 0x15779C /* 'NEProxySettings' => 'NetworkExtension.NEProxySettings, Xamarin.Mac' */ },
		{ NULL, 0x15929C /* 'NETunnelProviderProtocol' => 'NetworkExtension.NETunnelProviderProtocol, Xamarin.Mac' */ },
		{ NULL, 0x15AB9C /* 'NEVPNConnection' => 'NetworkExtension.NEVpnConnection, Xamarin.Mac' */ },
		{ NULL, 0x159C9C /* 'NETunnelProviderSession' => 'NetworkExtension.NETunnelProviderSession, Xamarin.Mac' */ },
		{ NULL, 0x15C99C /* 'NEVPNIKEv2SecurityAssociationParameters' => 'NetworkExtension.NEVpnIke2SecurityAssociationParameters, Xamarin.Mac' */ },
		{ NULL, 0x16289C /* 'NEVPNProtocolIPSec' => 'NetworkExtension.NEVpnProtocolIpSec, Xamarin.Mac' */ },
		{ NULL, 0x16229C /* 'NEVPNProtocolIKEv2' => 'NetworkExtension.NEVpnProtocolIke2, Xamarin.Mac' */ },
		{ NULL, 0x163C9C /* 'NWEndpoint' => 'NetworkExtension.NWEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x16369C /* 'NWBonjourServiceEndpoint' => 'NetworkExtension.NWBonjourServiceEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x16429C /* 'NWHostEndpoint' => 'NetworkExtension.NWHostEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x16509C /* 'NWPath' => 'NetworkExtension.NWPath, Xamarin.Mac' */ },
		{ NULL, 0x167A9C /* 'NWTLSParameters' => 'NetworkExtension.NWTlsParameters, Xamarin.Mac' */ },
		{ NULL, 0x79C /* 'Foundation_NSUrlSessionHandler_WrappedNSInputStream' => 'Foundation.NSUrlSessionHandler+WrappedNSInputStream, Xamarin.Mac' */ },
		{ NULL, 0x259C /* 'NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate' => 'NotificationCenter.NCWidgetListViewController+_NCWidgetListViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5C9C /* 'NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate' => 'NotificationCenter.NCWidgetSearchViewController+_NCWidgetSearchViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12249C /* 'CoreAnimation_CAAnimation__CAAnimationDelegate' => 'CoreAnimation.CAAnimation+_CAAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF09C /* 'Foundation_NSNetService__NSNetServiceDelegate' => 'Foundation.NSNetService+_NSNetServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1019C /* 'Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowser+_NSNetServiceBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x18819C /* '__NSObject_Disposer' => 'Foundation.NSObject+NSObject_Disposer, Xamarin.Mac' */ },
		{ NULL, 0x18829C /* '__XamarinObjectObserver' => 'Foundation.NSObject+Observer, Xamarin.Mac' */ },
		{ NULL, 0xC9C9C /* 'CoreLocation_CLLocationManager__CLLocationManagerDelegate' => 'CoreLocation.CLLocationManager+_CLLocationManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xCBB9C /* 'AVFoundation_AVCaptureFileOutput_recordingProxy' => 'AVFoundation.AVCaptureFileOutput+recordingProxy, Xamarin.Mac' */ },
		{ NULL, 0x3989C /* 'AppKit_NSAlert__NSAlertDelegate' => 'AppKit.NSAlert+_NSAlertDelegate, Xamarin.Mac' */ },
		{ NULL, 0x3F49C /* 'AppKit_NSAnimation__NSAnimationDelegate' => 'AppKit.NSAnimation+_NSAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x41B9C /* 'Foundation_NSStream__NSStreamDelegate' => 'Foundation.NSStream+_NSStreamDelegate, Xamarin.Mac' */ },
		{ NULL, 0x4799C /* 'AppKit_NSApplication__NSApplicationDelegate' => 'AppKit.NSApplication+_NSApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x105F9C /* 'Foundation_NSThread_ActionThread' => 'Foundation.NSThread+ActionThread, Xamarin.Mac' */ },
		{ NULL, 0x15A39C /* 'WebKit_DomNode_DomNodeEventProxy' => 'WebKit.DomNode+DomNodeEventProxy, Xamarin.Mac' */ },
		{ NULL, 0x15A49C /* 'WebKit_DomNode_DomNodeEventProxy2' => 'WebKit.DomNode+DomNodeEventProxy2, Xamarin.Mac' */ },
		{ NULL, 0x11FE9C /* '__NSGestureRecognizerToken' => 'AppKit.NSGestureRecognizer+Token, Xamarin.Mac' */ },
		{ NULL, 0x12019C /* '__NSClickGestureRecognizer' => 'AppKit.NSClickGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x15649C /* 'NEProvider' => 'NetworkExtension.NEProvider, Xamarin.Mac' */ },
		{ NULL, 0x15849C /* 'NETunnelProvider' => 'NetworkExtension.NETunnelProvider, Xamarin.Mac' */ },
		{ NULL, 0x6359C /* 'NEPacketTunnelProvider' => 'NetworkExtension.NEPacketTunnelProvider, Xamarin.Mac' */ },
		{ NULL, 0x6409C /* 'NEVPNManager' => 'NetworkExtension.NEVpnManager, Xamarin.Mac' */ },
		{ NULL, 0x13A09C /* 'AppKit_NSTextField__NSTextFieldDelegate' => 'AppKit.NSTextField+_NSTextFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x6669C /* 'AppKit_NSComboBox__NSComboBoxDelegate' => 'AppKit.NSComboBox+_NSComboBoxDelegate, Xamarin.Mac' */ },
		{ NULL, 0x6BB9C /* 'AppKit_NSDatePicker__NSDatePickerCellDelegate' => 'AppKit.NSDatePicker+_NSDatePickerCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x6CE9C /* 'AppKit_NSDatePickerCell__NSDatePickerCellDelegate' => 'AppKit.NSDatePickerCell+_NSDatePickerCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x6EE9C /* 'WebKit_WebView__WebFrameLoadDelegate' => 'WebKit.WebView+_WebFrameLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x6EF9C /* 'WebKit_WebView__WebDownloadDelegate' => 'WebKit.WebView+_WebDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x6F09C /* 'WebKit_WebView__WebResourceLoadDelegate' => 'WebKit.WebView+_WebResourceLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x6F19C /* 'WebKit_WebView__WebUIDelegate' => 'WebKit.WebView+_WebUIDelegate, Xamarin.Mac' */ },
		{ NULL, 0x6F29C /* 'WebKit_WebView__WebPolicyDelegate' => 'WebKit.WebView+_WebPolicyDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11EB9C /* '__NSDocumentDuplicateCallback' => 'AppKit.NSDocument+Callback, Xamarin.Mac' */ },
		{ NULL, 0xC609C /* 'Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate' => 'Foundation.NSUserNotificationCenter+_NSUserNotificationCenterDelegate, Xamarin.Mac' */ },
		{ NULL, 0xCAA9C /* 'AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate' => 'AppKit.NSGestureRecognizer+_NSGestureRecognizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11FF9C /* '__NSGestureRecognizerParameterlessToken' => 'AppKit.NSGestureRecognizer+ParameterlessDispatch, Xamarin.Mac' */ },
		{ NULL, 0x12009C /* '__NSGestureRecognizerParametrizedToken' => 'AppKit.NSGestureRecognizer+ParametrizedDispatch, Xamarin.Mac' */ },
		{ NULL, 0xCB99C /* 'AppKit_NSDrawer__NSDrawerDelegate' => 'AppKit.NSDrawer+_NSDrawerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xD7E9C /* 'GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterViewController+_GKGameCenterControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xD0D9C /* 'GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewController+_GKAchievementViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14359C /* 'CoreBluetooth_CBCentralManager__CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManager+_CBCentralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x150C9C /* 'CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManager+_CBPeripheralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xD619C /* 'GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewController+_GKFriendRequestComposeViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14E19C /* 'CoreBluetooth_CBPeripheral__CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheral+_CBPeripheralDelegate, Xamarin.Mac' */ },
		{ NULL, 0xD8C9C /* 'AppKit_NSImage__NSImageDelegate' => 'AppKit.NSImage+_NSImageDelegate, Xamarin.Mac' */ },
		{ NULL, 0xDAF9C /* 'PdfKit_PdfDocument__PdfDocumentDelegate' => 'PdfKit.PdfDocument+_PdfDocumentDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12029C /* '__NSMagnificationGestureRecognizer' => 'AppKit.NSMagnificationGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0xDEF9C /* 'AppKit_NSMatrix__NSMatrixDelegate' => 'AppKit.NSMatrix+_NSMatrixDelegate, Xamarin.Mac' */ },
		{ NULL, 0xE029C /* 'GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewController+_GKLeaderboardViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xE4F9C /* 'GameKit_GKMatch__GKMatchDelegate' => 'GameKit.GKMatch+_GKMatchDelegate, Xamarin.Mac' */ },
		{ NULL, 0xE859C /* 'GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewController+_GKMatchmakerViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xE9E9C /* 'PdfKit_PdfView__PdfViewDelegate' => 'PdfKit.PdfView+_PdfViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF0E9C /* 'AppKit_NSPageController__NSPageControllerDelegate' => 'AppKit.NSPageController+_NSPageControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12039C /* '__NSPanGestureRecognizer' => 'AppKit.NSPanGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x14409C /* 'Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiver+_NSKeyedArchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x146C9C /* 'Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiver+_NSKeyedUnarchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0xFA59C /* 'AppKit_NSPathCell__NSPathCellDelegate' => 'AppKit.NSPathCell+_NSPathCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0xFAD9C /* 'PHLivePhotoEditingContext' => 'Photos.PHLivePhotoEditingContext, Xamarin.Mac' */ },
		{ NULL, 0xFB59C /* 'ExternalAccessory_EAAccessory__EAAccessoryDelegate' => 'ExternalAccessory.EAAccessory+_EAAccessoryDelegate, Xamarin.Mac' */ },
		{ NULL, 0xFB49C /* 'EAAccessory' => 'ExternalAccessory.EAAccessory, Xamarin.Mac' */ },
		{ NULL, 0xFC69C /* 'EAAccessoryManager' => 'ExternalAccessory.EAAccessoryManager, Xamarin.Mac' */ },
		{ NULL, 0xFE19C /* 'PHPhotoLibrary' => 'Photos.PHPhotoLibrary, Xamarin.Mac' */ },
		{ NULL, 0x12049C /* '__NSPressGestureRecognizer' => 'AppKit.NSPressGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x10829C /* 'Foundation_NSCache__NSCacheDelegate' => 'Foundation.NSCache+_NSCacheDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12059C /* '__NSRotationGestureRecognizer' => 'AppKit.NSRotationGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x10B49C /* 'AppKit_NSRuleEditor__NSRuleEditorDelegate' => 'AppKit.NSRuleEditor+_NSRuleEditorDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11159C /* 'AppKit_NSSearchField__NSSearchFieldDelegate' => 'AppKit.NSSearchField+_NSSearchFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11229C /* 'AppKit_NSSavePanel__NSOpenSavePanelDelegate' => 'AppKit.NSSavePanel+_NSOpenSavePanelDelegate, Xamarin.Mac' */ },
		{ NULL, 0x134C9C /* 'AppKit_NSTableView__NSTableViewDelegate' => 'AppKit.NSTableView+_NSTableViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11A19C /* 'AppKit_NSSharingService__NSSharingServiceDelegate' => 'AppKit.NSSharingService+_NSSharingServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11AF9C /* 'AppKit_NSSound__NSSoundDelegate' => 'AppKit.NSSound+_NSSoundDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11C09C /* 'AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate' => 'AppKit.NSSharingServicePicker+_NSSharingServicePickerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x146E9C /* 'AppKit_NSTextStorage__NSTextStorageDelegate' => 'AppKit.NSTextStorage+_NSTextStorageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1A739C /* 'AppKit_NSWindow__NSWindowDelegate' => 'AppKit.NSWindow+_NSWindowDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13189C /* 'ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate' => 'ImageKit.IKCameraDeviceView+_IKCameraDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13449C /* 'ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate' => 'ImageKit.IKDeviceBrowserView+_IKDeviceBrowserViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13B59C /* 'AppKit_NSTabView__NSTabViewDelegate' => 'AppKit.NSTabView+_NSTabViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13BD9C /* 'ImageKit_IKImageBrowserView__IKImageBrowserDelegate' => 'ImageKit.IKImageBrowserView+_IKImageBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14149C /* 'ImageKit_IKSaveOptions__IKSaveOptionsDelegate' => 'ImageKit.IKSaveOptions+_IKSaveOptionsDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14249C /* 'AppKit_NSText__NSTextDelegate' => 'AppKit.NSText+_NSTextDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14329C /* 'ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate' => 'ImageKit.IKScannerDeviceView+_IKScannerDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x145E9C /* 'NEAppProxyFlow' => 'NetworkExtension.NEAppProxyFlow, Xamarin.Mac' */ },
		{ NULL, 0x146D9C /* 'NEAppProxyProvider' => 'NetworkExtension.NEAppProxyProvider, Xamarin.Mac' */ },
		{ NULL, 0x158F9C /* 'NETunnelProviderManager' => 'NetworkExtension.NETunnelProviderManager, Xamarin.Mac' */ },
		{ NULL, 0x14789C /* 'NEAppProxyProviderManager' => 'NetworkExtension.NEAppProxyProviderManager, Xamarin.Mac' */ },
		{ NULL, 0x14859C /* 'NEAppProxyTCPFlow' => 'NetworkExtension.NEAppProxyTcpFlow, Xamarin.Mac' */ },
		{ NULL, 0x17A59C /* 'ScriptingBridge_SBApplication__SBApplicationDelegate' => 'ScriptingBridge.SBApplication+_SBApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x148C9C /* 'NEAppProxyUDPFlow' => 'NetworkExtension.NEAppProxyUdpFlow, Xamarin.Mac' */ },
		{ NULL, 0x14A59C /* 'AppKit_NSTouchBar__NSTouchBarDelegate' => 'AppKit.NSTouchBar+_NSTouchBarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14C99C /* 'NEFilterManager' => 'NetworkExtension.NEFilterManager, Xamarin.Mac' */ },
		{ NULL, 0x14DF9C /* 'NEFilterProvider' => 'NetworkExtension.NEFilterProvider, Xamarin.Mac' */ },
		{ NULL, 0x15389C /* 'AppKit_NSTextView__NSTextViewDelegate' => 'AppKit.NSTextView+_NSTextViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x15519C /* 'NEPacketTunnelFlow' => 'NetworkExtension.NEPacketTunnelFlow, Xamarin.Mac' */ },
		{ NULL, 0x159F9C /* 'Foundation_NSMetadataQuery__NSMetadataQueryDelegate' => 'Foundation.NSMetadataQuery+_NSMetadataQueryDelegate, Xamarin.Mac' */ },
		{ NULL, 0x15AE9C /* 'AppKit_NSToolbar__NSToolbarDelegate' => 'AppKit.NSToolbar+_NSToolbarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x16619C /* 'NWTCPConnection' => 'NetworkExtension.NWTcpConnection, Xamarin.Mac' */ },
		{ NULL, 0x167D9C /* 'NWUDPSession' => 'NetworkExtension.NWUdpSession, Xamarin.Mac' */ },
		{ NULL, 0x16E59C /* 'SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsWorld+_SCNPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x173A9C /* 'MapKit_MKMapView__MKMapViewDelegate' => 'MapKit.MKMapView+_MKMapViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x188B9C /* 'SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsWorld+_SKPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1ACA9C /* 'StoreKit_SKRequest__SKRequestDelegate' => 'StoreKit.SKRequest+_SKRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1A959C /* 'StoreKit_SKProductsRequest__SKProductsRequestDelegate' => 'StoreKit.SKProductsRequest+_SKProductsRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x39C /* 'Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate' => 'Foundation.NSUrlSessionHandler+NSUrlSessionHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F9E /* 'Xwt_Gtk_Mac_GtkMacSaveFileDialogBackend' => 'Xwt.Gtk.Mac.GtkMacSaveFileDialogBackend, Xwt.Gtk.Mac' */ },
		{ NULL, 0x229E /* 'Xwt_Gtk_Mac_WebViewBackend_XwtWebUIDelegate' => 'Xwt.Gtk.Mac.WebViewBackend+XwtWebUIDelegate, Xwt.Gtk.Mac' */ },
		{ NULL, 0x1E9E /* 'Xwt_Gtk_Mac_GtkMacOpenFileDialogBackend' => 'Xwt.Gtk.Mac.GtkMacOpenFileDialogBackend, Xwt.Gtk.Mac' */ },
		{ NULL, 0x209E /* 'Xwt_Gtk_Mac_GtkMacSelectFolderBackend' => 'Xwt.Gtk.Mac.GtkMacSelectFolderBackend, Xwt.Gtk.Mac' */ },
		{ NULL, 0x87A2 /* 'Xwt_Mac_WidgetView' => 'Xwt.Mac.WidgetView, Xwt.XamMac' */ },
		{ NULL, 0x6A2 /* 'Xwt_Mac_CustomAlignedContainer' => 'Xwt.Mac.CustomAlignedContainer, Xwt.XamMac' */ },
		{ NULL, 0x7A2 /* 'Xwt_Mac_TextFieldView' => 'Xwt.Mac.TextFieldView, Xwt.XamMac' */ },
		{ NULL, 0x8A2 /* 'Xwt_Mac_CustomTextFieldCell' => 'Xwt.Mac.CustomTextFieldCell, Xwt.XamMac' */ },
		{ NULL, 0xAA2 /* 'Xwt_Mac_AppDelegate' => 'Xwt.Mac.AppDelegate, Xwt.XamMac' */ },
		{ NULL, 0x10A2 /* 'Xwt_Mac_TabView' => 'Xwt.Mac.TabView, Xwt.XamMac' */ },
		{ NULL, 0x12A2 /* 'Xwt_Mac_TreeItem' => 'Xwt.Mac.TreeItem, Xwt.XamMac' */ },
		{ NULL, 0x13A2 /* 'Xwt_Mac_TreeSource' => 'Xwt.Mac.TreeSource, Xwt.XamMac' */ },
		{ NULL, 0x18A2 /* 'Xwt_Mac_WidgetPlacementWrapper' => 'Xwt.Mac.WidgetPlacementWrapper, Xwt.XamMac' */ },
		{ NULL, 0x1AA2 /* 'Xwt_Mac_WindowBackendController' => 'Xwt.Mac.WindowBackendController, Xwt.XamMac' */ },
		{ NULL, 0x1FA2 /* 'Xwt_Mac_TextTableCell' => 'Xwt.Mac.TextTableCell, Xwt.XamMac' */ },
		{ NULL, 0x23A2 /* 'Xwt_Mac_ImageTableCell' => 'Xwt.Mac.ImageTableCell, Xwt.XamMac' */ },
		{ NULL, 0x2FA2 /* 'Xwt_Mac_TableRow' => 'Xwt.Mac.TableRow, Xwt.XamMac' */ },
		{ NULL, 0x30A2 /* 'Xwt_Mac_ListSource' => 'Xwt.Mac.ListSource, Xwt.XamMac' */ },
		{ NULL, 0x32A2 /* 'Xwt_Mac_ScrollView' => 'Xwt.Mac.ScrollView, Xwt.XamMac' */ },
		{ NULL, 0x33A2 /* 'Xwt_Mac_MenuBackend' => 'Xwt.Mac.MenuBackend, Xwt.XamMac' */ },
		{ NULL, 0x38A2 /* 'Xwt_Mac_PopUpButton' => 'Xwt.Mac.PopUpButton, Xwt.XamMac' */ },
		{ NULL, 0x42A2 /* 'Xwt_Mac_ComboDataSource' => 'Xwt.Mac.ComboDataSource, Xwt.XamMac' */ },
		{ NULL, 0x47A2 /* 'Xwt_Mac_MacFrame' => 'Xwt.Mac.MacFrame, Xwt.XamMac' */ },
		{ NULL, 0x48A2 /* 'Xwt_Mac_CustomContentView' => 'Xwt.Mac.CustomContentView, Xwt.XamMac' */ },
		{ NULL, 0x4BA2 /* 'Xwt_Mac_CustomScrollView' => 'Xwt.Mac.CustomScrollView, Xwt.XamMac' */ },
		{ NULL, 0x4CA2 /* 'Xwt_Mac_DummyClipView' => 'Xwt.Mac.DummyClipView, Xwt.XamMac' */ },
		{ NULL, 0x4DA2 /* 'Xwt_Mac_CustomClipView' => 'Xwt.Mac.CustomClipView, Xwt.XamMac' */ },
		{ NULL, 0x4EA2 /* 'Xwt_Mac_NormalClipView' => 'Xwt.Mac.NormalClipView, Xwt.XamMac' */ },
		{ NULL, 0x50A2 /* 'Xwt_Mac_SeparatorWidget' => 'Xwt.Mac.SeparatorWidget, Xwt.XamMac' */ },
		{ NULL, 0x52A2 /* 'Xwt_Mac_CustomSplitView' => 'Xwt.Mac.CustomSplitView, Xwt.XamMac' */ },
		{ NULL, 0x57A2 /* 'Xwt_Mac_ProgressIndicatorView' => 'Xwt.Mac.ProgressIndicatorView, Xwt.XamMac' */ },
		{ NULL, 0x5BA2 /* 'Xwt_Mac_MacExpander' => 'Xwt.Mac.MacExpander, Xwt.XamMac' */ },
		{ NULL, 0x5CA2 /* 'Xwt_Mac_ExpanderWidget' => 'Xwt.Mac.ExpanderWidget, Xwt.XamMac' */ },
		{ NULL, 0x5DA2 /* 'Xwt_Mac_CollapsibleBox' => 'Xwt.Mac.CollapsibleBox, Xwt.XamMac' */ },
		{ NULL, 0x61A2 /* 'Xwt_Mac_LinkLabelView' => 'Xwt.Mac.LinkLabelView, Xwt.XamMac' */ },
		{ NULL, 0x62A2 /* 'Xwt_Mac_FileDialogBackend' => 'Xwt.Mac.FileDialogBackend, Xwt.XamMac' */ },
		{ NULL, 0x64A2 /* 'Xwt_Mac_OpenFileDialogBackend' => 'Xwt.Mac.OpenFileDialogBackend, Xwt.XamMac' */ },
		{ NULL, 0x66A2 /* 'XwtPasteboardOwner' => 'Xwt.Mac.PasteboardOwner, Xwt.XamMac' */ },
		{ NULL, 0x69A2 /* 'Xwt_Mac_CustomWidgetView' => 'Xwt.Mac.CustomWidgetView, Xwt.XamMac' */ },
		{ NULL, 0x77A2 /* 'Xwt_Mac_CustomScroller' => 'Xwt.Mac.CustomScroller, Xwt.XamMac' */ },
		{ NULL, 0x79A2 /* 'Xwt_Mac_MacDatePicker' => 'Xwt.Mac.MacDatePicker, Xwt.XamMac' */ },
		{ NULL, 0x7BA2 /* 'Xwt_Mac_MacSlider' => 'Xwt.Mac.MacSlider, Xwt.XamMac' */ },
		{ NULL, 0x7CA2 /* 'Xwt_Mac_MacSliderCell' => 'Xwt.Mac.MacSliderCell, Xwt.XamMac' */ },
		{ NULL, 0x7DA2 /* 'Xwt_Mac_CheckBoxTableCell' => 'Xwt.Mac.CheckBoxTableCell, Xwt.XamMac' */ },
		{ NULL, 0x83A2 /* 'Xwt_Mac_MacWebView' => 'Xwt.Mac.MacWebView, Xwt.XamMac' */ },
		{ NULL, 0x84A2 /* 'Xwt_Mac_XwtWebUIDelegate' => 'Xwt.Mac.XwtWebUIDelegate, Xwt.XamMac' */ },
		{ NULL, 0x8BA2 /* 'Xwt_Mac_SaveFileDialogBackend' => 'Xwt.Mac.SaveFileDialogBackend, Xwt.XamMac' */ },
		{ NULL, 0x8DA2 /* 'Xwt_Mac_MacColorWell' => 'Xwt.Mac.MacColorWell, Xwt.XamMac' */ },
		{ NULL, 0x90A2 /* 'Xwt_Mac_MacCalendar' => 'Xwt.Mac.MacCalendar, Xwt.XamMac' */ },
		{ NULL, 0x92A2 /* 'Xwt_Mac_FontPanelDelegate' => 'Xwt.Mac.FontPanelDelegate, Xwt.XamMac' */ },
		{ NULL, 0x94A2 /* 'Xwt_Mac_RadioButtonTableCell' => 'Xwt.Mac.RadioButtonTableCell, Xwt.XamMac' */ },
		{ NULL, 0x4A2 /* 'Xwt_Mac_MacButton' => 'Xwt.Mac.MacButton, Xwt.XamMac' */ },
		{ NULL, 0x9DA2 /* 'Xwt_Mac_TreeViewBackend_TreeDelegate' => 'Xwt.Mac.TreeViewBackend+TreeDelegate, Xwt.XamMac' */ },
		{ NULL, 0x1BA2 /* 'Xwt_Mac_CompositeCell' => 'Xwt.Mac.CompositeCell, Xwt.XamMac' */ },
		{ NULL, 0x22A2 /* 'Xwt_Mac_CustomImage' => 'Xwt.Mac.CustomImage, Xwt.XamMac' */ },
		{ NULL, 0x28A2 /* 'Xwt_Mac_CanvasView' => 'Xwt.Mac.CanvasView, Xwt.XamMac' */ },
		{ NULL, 0xB3A2 /* 'Xwt_Mac_CustomTextField_CustomCell' => 'Xwt.Mac.CustomTextField+CustomCell, Xwt.XamMac' */ },
		{ NULL, 0x3AA2 /* 'Xwt_Mac_CustomTextField' => 'Xwt.Mac.CustomTextField, Xwt.XamMac' */ },
		{ NULL, 0x41A2 /* 'Xwt_Mac_MacComboBox' => 'Xwt.Mac.MacComboBox, Xwt.XamMac' */ },
		{ NULL, 0xBAA2 /* 'Xwt_Mac_PanedBackend_SplitViewDelegate' => 'Xwt.Mac.PanedBackend+SplitViewDelegate, Xwt.XamMac' */ },
		{ NULL, 0xBEA2 /* 'Xwt_Mac_MacSpinButton_VibrancyStepper' => 'Xwt.Mac.MacSpinButton+VibrancyStepper, Xwt.XamMac' */ },
		{ NULL, 0x59A2 /* 'Xwt_Mac_MacSpinButton' => 'Xwt.Mac.MacSpinButton, Xwt.XamMac' */ },
		{ NULL, 0xC0A2 /* 'Xwt_Mac_PopoverBackend_NSAppearanceCustomizationPopover' => 'Xwt.Mac.PopoverBackend+NSAppearanceCustomizationPopover, Xwt.XamMac' */ },
		{ NULL, 0x63A2 /* 'Xwt_Mac_SelectFolderDialogBackend' => 'Xwt.Mac.SelectFolderDialogBackend, Xwt.XamMac' */ },
		{ NULL, 0x6CA2 /* 'Xwt_Mac_MacMenuButton' => 'Xwt.Mac.MacMenuButton, Xwt.XamMac' */ },
		{ NULL, 0x6DA2 /* 'Xwt_Mac_CanvasTableCell' => 'Xwt.Mac.CanvasTableCell, Xwt.XamMac' */ },
		{ NULL, 0x72A2 /* 'Xwt_Mac_MacTextView' => 'Xwt.Mac.MacTextView, Xwt.XamMac' */ },
		{ NULL, 0x81A2 /* 'Xwt_Mac_CustomSecureTextField' => 'Xwt.Mac.CustomSecureTextField, Xwt.XamMac' */ },
		{ NULL, 0xD6A2 /* 'Xwt_Mac_NSTableViewBackend_ListDelegate' => 'Xwt.Mac.NSTableViewBackend+ListDelegate, Xwt.XamMac' */ },
		{ NULL, 0x88A2 /* 'Xwt_Mac_NSTableViewBackend' => 'Xwt.Mac.NSTableViewBackend, Xwt.XamMac' */ },
		{ NULL, 0x8EA2 /* 'Xwt_Mac_OutlineViewBackend' => 'Xwt.Mac.OutlineViewBackend, Xwt.XamMac' */ },
		{ NULL, 0x98A2 /* 'Xwt_Mac_PopupWindowBackend' => 'Xwt.Mac.PopupWindowBackend, Xwt.XamMac' */ },
		{ NULL, 0x99A2 /* 'Xwt_Mac_MacButton_ColoredButtonCell' => 'Xwt.Mac.MacButton+ColoredButtonCell, Xwt.XamMac' */ },
		{ NULL, 0xB4A2 /* 'Xwt_Mac_CustomTextField_CustomEditor' => 'Xwt.Mac.CustomTextField+CustomEditor, Xwt.XamMac' */ },
		{ NULL, 0xECA2 /* 'Xwt_Mac_PopoverBackend_FactoryViewController_ContainerView' => 'Xwt.Mac.PopoverBackend+FactoryViewController+ContainerView, Xwt.XamMac' */ },
		{ NULL, 0xBFA2 /* 'Xwt_Mac_PopoverBackend_FactoryViewController' => 'Xwt.Mac.PopoverBackend+FactoryViewController, Xwt.XamMac' */ },
		{ NULL, 0xC3A2 /* 'Xwt_Mac_MacMenuButton_ColoredPopUpButtonCell' => 'Xwt.Mac.MacMenuButton+ColoredPopUpButtonCell, Xwt.XamMac' */ },
		{ NULL, 0 },
	};

	static const char *__xamarin_registration_assemblies []= {
		"mscorlib", 
		"ICSharpCode.Decompiler", 
		"ICSharpCode.NRefactory.CSharp", 
		"ICSharpCode.NRefactory.Cecil", 
		"ICSharpCode.NRefactory", 
		"ICSharpCode.SharpZipLib", 
		"MacPlatform", 
		"Microsoft.CodeAnalysis.CSharp.Features", 
		"Microsoft.CodeAnalysis.CSharp.Workspaces", 
		"Microsoft.CodeAnalysis.CSharp", 
		"Microsoft.CodeAnalysis.EditorFeatures.Text", 
		"Microsoft.CodeAnalysis.EditorFeatures", 
		"Microsoft.CodeAnalysis.Elfie", 
		"Microsoft.CodeAnalysis.Features", 
		"Microsoft.CodeAnalysis.VisualBasic.Features", 
		"Microsoft.CodeAnalysis.VisualBasic.Workspaces", 
		"Microsoft.CodeAnalysis.VisualBasic", 
		"Microsoft.CodeAnalysis.Workspaces.Desktop", 
		"Microsoft.CodeAnalysis.Workspaces", 
		"Microsoft.CodeAnalysis", 
		"Microsoft.TemplateEngine.Abstractions", 
		"Microsoft.TemplateEngine.Core.Contracts", 
		"Microsoft.TemplateEngine.Core", 
		"Microsoft.TemplateEngine.Edge", 
		"Microsoft.TemplateEngine.Orchestrator.RunnableProjects", 
		"Microsoft.TemplateEngine.Utils", 
		"Microsoft.VisualStudio.Composition", 
		"Microsoft.VisualStudio.CoreUtility", 
		"Microsoft.VisualStudio.Language.Intellisense", 
		"Microsoft.VisualStudio.Language.StandardClassification", 
		"Microsoft.VisualStudio.Text.Data", 
		"Microsoft.VisualStudio.Text.Implementation", 
		"Microsoft.VisualStudio.Text.Internal", 
		"Microsoft.VisualStudio.Text.Logic", 
		"Microsoft.VisualStudio.Text.UI.Wpf", 
		"Microsoft.VisualStudio.Text.UI", 
		"Microsoft.VisualStudio.Threading", 
		"Microsoft.VisualStudio.Validation", 
		"Mono.Addins.CecilReflector", 
		"Mono.Addins.Gui", 
		"Mono.Addins.Setup", 
		"Mono.Addins", 
		"Mono.Cecil.Mdb", 
		"Mono.Cecil.Pdb", 
		"Mono.Cecil.Rocks", 
		"Mono.Cecil", 
		"Mono.Debugging", 
		"MonoDevelop.Core", 
		"MonoDevelop.Ide", 
		"MonoDevelop.Projects.Formats.MSBuild", 
		"Newtonsoft.Json", 
		"System.AppContext", 
		"System.Collections.Immutable", 
		"System.Composition.AttributedModel", 
		"System.Composition.Convention", 
		"System.Composition.Hosting", 
		"System.Composition.Runtime", 
		"System.Composition.TypedParts", 
		"System.Console", 
		"System.Diagnostics.FileVersionInfo", 
		"System.Diagnostics.StackTrace", 
		"System.IO.Compression", 
		"System.IO.FileSystem.Primitives", 
		"System.IO.FileSystem", 
		"System.Reflection.Metadata", 
		"System.Runtime.InteropServices.RuntimeInformation", 
		"System.Security.Cryptography.Algorithms", 
		"System.Security.Cryptography.Encoding", 
		"System.Security.Cryptography.Primitives", 
		"System.Security.Cryptography.X509Certificates", 
		"System.Text.Encoding.CodePages", 
		"System.Threading.Tasks.Dataflow", 
		"System.Threading.Thread", 
		"System.ValueTuple", 
		"System.Xml.ReaderWriter", 
		"System.Xml.XPath.XDocument", 
		"System.Xml.XPath", 
		"System.Xml.XmlDocument", 
		"Xamarin.Mac", 
		"Xwt.Gtk.Mac", 
		"Xwt.Gtk", 
		"Xwt.XamMac", 
		"Xwt", 
		"YamlDotNet", 
		"Microsoft.Web.Infrastructure", 
		"MonoDevelop.AspNet", 
		"System.Web.Helpers", 
		"System.Web.Mvc", 
		"System.Web.Razor", 
		"System.Web.WebPages.Deployment", 
		"System.Web.WebPages.Razor", 
		"System.Web.WebPages", 
		"MonoDevelop.AspNetCore", 
		"MonoDevelop.DocFood", 
		"MonoDevelop.CSharpBinding.AspNet", 
		"MonoDevelop.CSharpBinding.Autotools", 
		"MonoDevelop.CSharpBinding", 
		"ChangeLogAddIn", 
		"MonoDevelop.AssemblyBrowser", 
		"MonoDevelop.Gettext", 
		"MonoDevelop.HexEditor", 
		"MonoDevelop.SourceEditor", 
		"ExtCore", 
		"FSharp.Compiler.CodeDom", 
		"FSharp.Compiler.Interactive.Settings", 
		"FSharp.Compiler.Service", 
		"FSharp.Core", 
		"FSharpBinding.Gui", 
		"FSharpBinding", 
		"FantomasLib", 
		"System.Reactive.Core", 
		"System.Reactive.Interfaces", 
		"System.Reactive.Linq", 
		"ILAsmBinding", 
		"MonoDevelop.Autotools", 
		"MonoDevelop.AzureFunctions", 
		"ARMClient.Authentication", 
		"ARMClient.Library", 
		"Autofac.Integration.WebApi", 
		"Autofac", 
		"Colors.Net", 
		"EdgeJs", 
		"FSharp.Compiler.Service.MSBuild.v12", 
		"FluentCommandLineParser", 
		"Humanizer", 
		"Ignite.SharpNetSH", 
		"Microsoft.AI.Agent.Intercept", 
		"Microsoft.AI.DependencyCollector", 
		"Microsoft.AI.PerfCounterCollector", 
		"Microsoft.AI.ServerTelemetryChannel", 
		"Microsoft.AI.WindowsServer", 
		"Microsoft.ApplicationInsights", 
		"Microsoft.AspNet.WebHooks.Common", 
		"Microsoft.AspNet.WebHooks.Receivers.Azure", 
		"Microsoft.AspNet.WebHooks.Receivers.Bitbucket", 
		"Microsoft.AspNet.WebHooks.Receivers.Dropbox", 
		"Microsoft.AspNet.WebHooks.Receivers.DynamicsCRM", 
		"Microsoft.AspNet.WebHooks.Receivers.Generic", 
		"Microsoft.AspNet.WebHooks.Receivers.GitHub", 
		"Microsoft.AspNet.WebHooks.Receivers.Instagram", 
		"Microsoft.AspNet.WebHooks.Receivers.MailChimp", 
		"Microsoft.AspNet.WebHooks.Receivers.Pusher", 
		"Microsoft.AspNet.WebHooks.Receivers.Salesforce", 
		"Microsoft.AspNet.WebHooks.Receivers.Slack", 
		"Microsoft.AspNet.WebHooks.Receivers.Stripe", 
		"Microsoft.AspNet.WebHooks.Receivers.Trello", 
		"Microsoft.AspNet.WebHooks.Receivers.WordPress", 
		"Microsoft.AspNet.WebHooks.Receivers", 
		"Microsoft.AspNetCore.Cryptography.Internal", 
		"Microsoft.AspNetCore.DataProtection.Abstractions", 
		"Microsoft.AspNetCore.DataProtection", 
		"Microsoft.AspNetCore.Hosting.Abstractions", 
		"Microsoft.AspNetCore.Hosting.Server.Abstractions", 
		"Microsoft.AspNetCore.Http.Abstractions", 
		"Microsoft.AspNetCore.Http.Features", 
		"Microsoft.AspNetCore.WebUtilities", 
		"Microsoft.Azure.ApiHub.Sdk", 
		"Microsoft.Azure.Documents.Client", 
		"Microsoft.Azure.KeyVault.Core", 
		"Microsoft.Azure.NotificationHubs", 
		"Microsoft.Azure.WebJobs.Extensions.ApiHub", 
		"Microsoft.Azure.WebJobs.Extensions.BotFramework", 
		"Microsoft.Azure.WebJobs.Extensions.DocumentDB", 
		"Microsoft.Azure.WebJobs.Extensions.Http", 
		"Microsoft.Azure.WebJobs.Extensions.MobileApps", 
		"Microsoft.Azure.WebJobs.Extensions.NotificationHubs", 
		"Microsoft.Azure.WebJobs.Extensions.SendGrid", 
		"Microsoft.Azure.WebJobs.Extensions.Twilio", 
		"Microsoft.Azure.WebJobs.Extensions", 
		"Microsoft.Azure.WebJobs.Host", 
		"Microsoft.Azure.WebJobs.Logging.ApplicationInsights", 
		"Microsoft.Azure.WebJobs.Logging", 
		"Microsoft.Azure.WebJobs.Script.Extensibility", 
		"Microsoft.Azure.WebJobs.Script.WebHost", 
		"Microsoft.Azure.WebJobs.Script", 
		"Microsoft.Azure.WebJobs.ServiceBus", 
		"Microsoft.Azure.WebJobs", 
		"Microsoft.Azure.WebSites.DataProtection", 
		"Microsoft.Bot.Connector.DirectLine", 
		"Microsoft.CodeAnalysis.CSharp.Scripting", 
		"Microsoft.CodeAnalysis.Scripting", 
		"Microsoft.Data.Edm", 
		"Microsoft.Data.OData", 
		"Microsoft.Data.Services.Client", 
		"Microsoft.Extensions.Configuration.Abstractions", 
		"Microsoft.Extensions.DependencyInjection.Abstractions", 
		"Microsoft.Extensions.DependencyInjection", 
		"Microsoft.Extensions.FileProviders.Abstractions", 
		"Microsoft.Extensions.Logging.Abstractions", 
		"Microsoft.Extensions.Logging", 
		"Microsoft.Extensions.Options", 
		"Microsoft.Extensions.Primitives", 
		"Microsoft.IdentityModel.Clients.ActiveDirectory.WindowsForms", 
		"Microsoft.IdentityModel.Clients.ActiveDirectory", 
		"Microsoft.IdentityModel.Logging", 
		"Microsoft.IdentityModel.Tokens", 
		"Microsoft.Rest.ClientRuntime", 
		"Microsoft.ServiceBus.Messaging.EventProcessorHost", 
		"Microsoft.ServiceBus", 
		"Microsoft.Win32.Primitives", 
		"Microsoft.WindowsAzure.Configuration", 
		"Microsoft.WindowsAzure.Mobile.Ext", 
		"Microsoft.WindowsAzure.Mobile", 
		"Microsoft.WindowsAzure.Storage", 
		"NCrontab", 
		"NuGet.Frameworks", 
		"NuGet.LibraryModel", 
		"NuGet.Versioning", 
		"RestSharp", 
		"SendGrid.CSharp.HTTP.Client", 
		"SendGrid.SmtpApi", 
		"SendGrid", 
		"System.Buffers", 
		"System.Diagnostics.DiagnosticSource", 
		"System.Globalization.Calendars", 
		"System.IO.Abstractions", 
		"System.IO.Compression.ZipFile", 
		"System.IdentityModel.Tokens.Jwt", 
		"System.Net.Http.Extensions", 
		"System.Net.Http.Formatting", 
		"System.Net.Http.Primitives", 
		"System.Net.Http", 
		"System.Net.Sockets", 
		"System.Spatial", 
		"System.Text.Encodings.Web", 
		"System.Web.Cors", 
		"System.Web.Http.Cors", 
		"System.Web.Http.SelfHost", 
		"System.Web.Http.WebHost", 
		"System.Web.Http", 
		"Twilio.Api", 
		"Humanizer.resources", 
		"Microsoft.Data.Edm.resources", 
		"Microsoft.Data.OData.resources", 
		"Microsoft.Data.Services.Client.resources", 
		"System.Spatial.resources", 
		"MonoDevelop.ConnectedServices", 
		"Mono.Debugger.Soft", 
		"Mono.Debugging.Soft", 
		"MonoDevelop.Debugger.Soft.AspNet", 
		"MonoDevelop.Debugger.Soft", 
		"Microsoft.VisualStudio.Shared.VSCodeDebugProtocol", 
		"MonoDevelop.Debugger.VsCodeDebugProtocol", 
		"MonoDevelop.Debugger", 
		"MonoDevelop.Deployment.Linux", 
		"MonoDevelop.Deployment", 
		"MonoDevelop.DesignerSupport", 
		"MonoDevelop.DotNetCore", 
		"MonoDevelop.GtkCore", 
		"libstetic", 
		"libsteticui", 
		"Lucene.Net", 
		"Microsoft.Web.XmlTransform", 
		"MonoDevelop.PackageManagement", 
		"NuGet.Commands", 
		"NuGet.Common", 
		"NuGet.Configuration", 
		"NuGet.DependencyResolver.Core", 
		"NuGet.Indexing", 
		"NuGet.PackageManagement", 
		"NuGet.Packaging.Core", 
		"NuGet.Packaging", 
		"NuGet.ProjectModel", 
		"NuGet.Protocol", 
		"NuGet.Resolver", 
		"MonoDevelop.Packaging", 
		"ClrHeapAllocationAnalyzer", 
		"MonoDevelop.Refactoring", 
		"RefactoringEssentials", 
		"MonoDevelop.RegexToolkit", 
		"Mono.TextTemplating", 
		"MonoDevelop.TextTemplating", 
		"Microsoft.TestPlatform.CommunicationUtilities", 
		"Microsoft.TestPlatform.CoreUtilities", 
		"Microsoft.TestPlatform.PlatformAbstractions", 
		"Microsoft.TestPlatform.VsTestConsole.TranslationLayer", 
		"Microsoft.VisualStudio.TestPlatform.Common", 
		"Microsoft.VisualStudio.TestPlatform.ObjectModel", 
		"MonoDevelop.UnitTesting.NUnit", 
		"MonoDevelop.UnitTesting", 
		"nunit.core", 
		"nunit.core.interfaces", 
		"nunit.framework", 
		"nunit.util", 
		"nunit.engine.api", 
		"nunit.engine", 
		"VisualStudioDatastoreConfigurationProvider", 
		"Microsoft.TestPlatform.TestHostRuntimeProvider", 
		"Microsoft.VisualStudio.TestPlatform.Extensions.Trx.TestLogger", 
		"Microsoft.DiaSymReader", 
		"Microsoft.DotNet.PlatformAbstractions", 
		"Microsoft.Extensions.DependencyModel", 
		"Microsoft.IntelliTrace.Core", 
		"Microsoft.TestPlatform.CrossPlatEngine", 
		"Microsoft.TestPlatform.Utilities", 
		"Microsoft.VisualStudio.ArchitectureTools.PEReader", 
		"Microsoft.VisualStudio.Coverage.Analysis", 
		"Microsoft.VisualStudio.Coverage.Interop", 
		"Microsoft.VisualStudio.Diagnostics.Utilities", 
		"Microsoft.VisualStudio.Enterprise.AspNetHelper", 
		"Microsoft.VisualStudio.QualityTools.AgentObject", 
		"Microsoft.VisualStudio.QualityTools.AgentProcessManager", 
		"Microsoft.VisualStudio.QualityTools.Common", 
		"Microsoft.VisualStudio.QualityTools.ControllerObject", 
		"Microsoft.VisualStudio.QualityTools.ExecutionCommon", 
		"Microsoft.VisualStudio.QualityTools.LoadTest", 
		"Microsoft.VisualStudio.QualityTools.LoadTestFramework", 
		"Microsoft.VisualStudio.QualityTools.Resource", 
		"Microsoft.VisualStudio.QualityTools.TMI", 
		"Microsoft.VisualStudio.QualityTools.Tips.GenericTest.Adapter", 
		"Microsoft.VisualStudio.QualityTools.Tips.GenericTest.ObjectModel", 
		"Microsoft.VisualStudio.QualityTools.Tips.GenericTest.Tip", 
		"Microsoft.VisualStudio.QualityTools.Tips.ManualTest.Adapter", 
		"Microsoft.VisualStudio.QualityTools.Tips.ManualTest.ObjectModel", 
		"Microsoft.VisualStudio.QualityTools.Tips.ManualTest.Tip", 
		"Microsoft.VisualStudio.QualityTools.Tips.OrderedTest.Adapter", 
		"Microsoft.VisualStudio.QualityTools.Tips.OrderedTest.ObjectModel", 
		"Microsoft.VisualStudio.QualityTools.Tips.OrderedTest.Tip", 
		"Microsoft.VisualStudio.QualityTools.Tips.UnitTest.Adapter", 
		"Microsoft.VisualStudio.QualityTools.Tips.UnitTest.AssemblyResolver", 
		"Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel", 
		"Microsoft.VisualStudio.QualityTools.Tips.UnitTest.Tip", 
		"Microsoft.VisualStudio.QualityTools.Tips.WebLoadTest.Tip", 
		"Microsoft.VisualStudio.QualityTools.UnitTestFramework", 
		"Microsoft.VisualStudio.QualityTools.WebTestFramework", 
		"Microsoft.VisualStudio.TestPlatform.Client", 
		"Microsoft.VisualStudio.TestPlatform.Fakes", 
		"Microsoft.VisualStudio.UwpTestHostRuntimeProvider.Deployment", 
		"Microsoft.TestPlatform.CommunicationUtilities.resources", 
		"Microsoft.TestPlatform.CoreUtilities.resources", 
		"Microsoft.TestPlatform.CrossPlatEngine.resources", 
		"Microsoft.TestPlatform.TestHostRuntimeProvider.resources", 
		"Microsoft.TestPlatform.Utilities.resources", 
		"Microsoft.TestPlatform.VsTestConsole.TranslationLayer.resources", 
		"Microsoft.VisualStudio.TestPlatform.Client.resources", 
		"Microsoft.VisualStudio.TestPlatform.Common.resources", 
		"Microsoft.VisualStudio.TestPlatform.Extensions.Trx.TestLogger.resources", 
		"Microsoft.VisualStudio.TestPlatform.ObjectModel.resources", 
		"vstest.console.resources", 
		"msdia140typelib_clr0200", 
		"MonoDevelop.WebReferences", 
		"MonoDeveloperExtensions", 
		"MonoDeveloperExtensions_nunit", 
		"TestRunner", 
		"nunit-console-runner", 
		"PerformanceDiagnosticsAddIn", 
		"MonoDevelop.VBNetBinding", 
		"LibGit2Sharp", 
		"MonoDevelop.VersionControl.Git", 
		"MonoDevelop.VersionControl.Subversion.Unix", 
		"MonoDevelop.VersionControl.Subversion", 
		"MonoDevelop.VersionControl", 
		"MonoDevelop.Xml"
	};

	static struct MTFullTokenReference __xamarin_token_references [] = {
	};

	static struct MTRegistrationMap __xamarin_registration_map = {
		__xamarin_registration_assemblies,
		__xamarin_class_map,
		__xamarin_token_references,
		353,
		2210,
		290,
		0
	};

void xamarin_create_classes () {
	__xamarin_class_map [0].handle = objc_getClass ("NSObject");
	__xamarin_class_map [1].handle = objc_getClass ("NSResponder");
	__xamarin_class_map [2].handle = objc_getClass ("NSWindow");
	__xamarin_class_map [3].handle = objc_getClass ("NSAlert");
	__xamarin_class_map [4].handle = objc_getClass ("NSView");
	__xamarin_class_map [5].handle = objc_getClass ("NSControl");
	__xamarin_class_map [6].handle = objc_getClass ("NSTextField");
	__xamarin_class_map [7].handle = objc_getClass ("NSButton");
	__xamarin_class_map [8].handle = objc_getClass ("NSCell");
	__xamarin_class_map [9].handle = objc_getClass ("NSActionCell");
	__xamarin_class_map [10].handle = objc_getClass ("NSButtonCell");
	__xamarin_class_map [11].handle = objc_getClass ("NSTextFieldCell");
	__xamarin_class_map [12].handle = objc_getClass ("NSPanel");
	__xamarin_class_map [13].handle = objc_getClass ("NSPopUpButton");
	__xamarin_class_map [14].handle = objc_getClass ("NSSearchFieldCell");
	__xamarin_class_map [15].handle = objc_getClass ("NSSearchField");
	__xamarin_class_map [16].handle = objc_getClass ("NSSegmentedCell");
	__xamarin_class_map [17].handle = objc_getClass ("NSSegmentedControl");
	__xamarin_class_map [18].handle = objc_getClass ("NSPathComponentCell");
	__xamarin_class_map [19].handle = objc_getClass ("NSPathControl");
	__xamarin_class_map [20].handle = objc_getClass ("NSAccessibilityElement");
	__xamarin_class_map [21].handle = objc_getClass ("NSMenuItem");
	__xamarin_class_map [22].handle = objc_getClass ("NSMenu");
	__xamarin_class_map [23].handle = objc_getClass ("CKRecordZoneID");
	__xamarin_class_map [24].handle = objc_getClass ("MPRemoteCommand");
	__xamarin_class_map [25].handle = objc_getClass ("MPChangePlaybackRateCommand");
	__xamarin_class_map [26].handle = objc_getClass ("VNObservation");
	__xamarin_class_map [27].handle = objc_getClass ("VNImageAlignmentObservation");
	__xamarin_class_map [28].handle = objc_getClass ("VNImageHomographicAlignmentObservation");
	__xamarin_class_map [29].handle = objc_getClass ("CKUserIdentityLookupInfo");
	__xamarin_class_map [30].handle = objc_getClass ("MPRemoteCommandEvent");
	__xamarin_class_map [31].handle = objc_getClass ("MPChangePlaybackRateCommandEvent");
	__xamarin_class_map [32].handle = objc_getClass ("AVAudioSequencer");
	__xamarin_class_map [33].handle = objc_getClass ("MPChangeRepeatModeCommand");
	__xamarin_class_map [34].handle = objc_getClass ("ACAccount");
	__xamarin_class_map [35].handle = objc_getClass ("NSIndexSet");
	__xamarin_class_map [36].handle = objc_getClass ("NSMutableIndexSet");
	__xamarin_class_map [37].handle = objc_getClass ("MPChangeRepeatModeCommandEvent");
	__xamarin_class_map [38].handle = objc_getClass ("ACAccountCredential");
	__xamarin_class_map [39].handle = objc_getClass ("MPChangeShuffleModeCommand");
	__xamarin_class_map [40].handle = objc_getClass ("MPChangeShuffleModeCommandEvent");
	__xamarin_class_map [41].handle = objc_getClass ("NSOrderedSet");
	__xamarin_class_map [42].handle = objc_getClass ("NSMutableOrderedSet");
	__xamarin_class_map [43].handle = objc_getClass ("MPContentItem");
	__xamarin_class_map [44].handle = objc_getClass ("VNRequest");
	__xamarin_class_map [45].handle = objc_getClass ("VNImageBasedRequest");
	__xamarin_class_map [46].handle = objc_getClass ("VNTargetedImageRequest");
	__xamarin_class_map [47].handle = objc_getClass ("VNImageRegistrationRequest");
	__xamarin_class_map [48].handle = objc_getClass ("CNContactFetchRequest");
	__xamarin_class_map [49].handle = objc_getClass ("NSSet");
	__xamarin_class_map [50].handle = objc_getClass ("NSMutableSet");
	__xamarin_class_map [51].handle = objc_getClass ("MPFeedbackCommand");
	__xamarin_class_map [52].handle = objc_getClass ("ACAccountType");
	__xamarin_class_map [53].handle = objc_getClass ("VNImageRequestHandler");
	__xamarin_class_map [54].handle = objc_getClass ("CNInstantMessageAddress");
	__xamarin_class_map [55].handle = objc_getClass ("MPFeedbackCommandEvent");
	__xamarin_class_map [56].handle = objc_getClass ("NSPersistentStoreDescription");
	__xamarin_class_map [57].handle = objc_getClass ("VNImageTranslationAlignmentObservation");
	__xamarin_class_map [58].handle = objc_getClass ("NSString");
	__xamarin_class_map [59].handle = objc_getClass ("NSMutableString");
	__xamarin_class_map [60].handle = objc_getClass ("CNSocialProfile");
	__xamarin_class_map [61].handle = objc_getClass ("NSPersistentStoreRequest");
	__xamarin_class_map [62].handle = objc_getClass ("CAAnimation");
	__xamarin_class_map [63].handle = objc_getClass ("CAPropertyAnimation");
	__xamarin_class_map [64].handle = objc_getClass ("CABasicAnimation");
	__xamarin_class_map [65].handle = objc_getClass ("CALayer");
	__xamarin_class_map [66].handle = objc_getClass ("CAScrollLayer");
	__xamarin_class_map [67].handle = objc_getClass ("VNPixelBufferObservation");
	__xamarin_class_map [68].handle = objc_getClass ("NSPersistentStoreResult");
	__xamarin_class_map [69].handle = objc_getClass ("NSURLRequest");
	__xamarin_class_map [70].handle = objc_getClass ("NSMutableURLRequest");
	__xamarin_class_map [71].handle = objc_getClass ("CAGradientLayer");
	__xamarin_class_map [72].handle = objc_getClass ("CAKeyframeAnimation");
	__xamarin_class_map [73].handle = objc_getClass ("VNDetectedObjectObservation");
	__xamarin_class_map [74].handle = objc_getClass ("VNRectangleObservation");
	__xamarin_class_map [75].handle = objc_getClass ("MPMediaItem");
	__xamarin_class_map [76].handle = objc_getClass ("NSAccessibilityCustomRotor");
	__xamarin_class_map [77].handle = objc_getClass ("MPMediaItemArtwork");
	__xamarin_class_map [78].handle = objc_getClass ("NSPropertyDescription");
	__xamarin_class_map [79].handle = objc_getClass ("NSAccessibilityCustomRotorItemResult");
	__xamarin_class_map [80].handle = objc_getClass ("CAMediaTimingFunction");
	__xamarin_class_map [81].handle = objc_getClass ("AVAudioTime");
	__xamarin_class_map [82].handle = objc_getClass ("NSPropertyMapping");
	__xamarin_class_map [83].handle = objc_getClass ("VNSequenceRequestHandler");
	__xamarin_class_map [84].handle = objc_getClass ("CATextLayer");
	__xamarin_class_map [85].handle = objc_getClass ("NSAccessibilityCustomRotorSearchParameters");
	__xamarin_class_map [86].handle = objc_getClass ("NSQueryGenerationToken");
	__xamarin_class_map [87].handle = objc_getClass ("NSAttributeDescription");
	__xamarin_class_map [88].handle = objc_getClass ("MPNowPlayingInfoCenter");
	__xamarin_class_map [89].handle = objc_getClass ("NSEntityDescription");
	__xamarin_class_map [90].handle = objc_getClass ("NSRelationshipDescription");
	__xamarin_class_map [91].handle = objc_getClass ("NSMergeConflict");
	__xamarin_class_map [92].handle = objc_getClass ("NSMergePolicy");
	__xamarin_class_map [93].handle = objc_getClass ("NSPersistentStore");
	__xamarin_class_map [94].handle = objc_getClass ("MPNowPlayingInfoLanguageOption");
	__xamarin_class_map [95].handle = objc_getClass ("NSSaveChangesRequest");
	__xamarin_class_map [96].handle = objc_getClass ("MPNowPlayingInfoLanguageOptionGroup");
	__xamarin_class_map [97].handle = objc_getClass ("AVAudioUnitComponentManager");
	__xamarin_class_map [98].handle = objc_getClass ("VNTextObservation");
	__xamarin_class_map [99].handle = objc_getClass ("AVAudioNode");
	__xamarin_class_map [100].handle = objc_getClass ("AVAudioUnit");
	__xamarin_class_map [101].handle = objc_getClass ("AVAudioUnitEffect");
	__xamarin_class_map [102].handle = objc_getClass ("AVAudioUnitDelay");
	__xamarin_class_map [103].handle = objc_getClass ("VNTrackingRequest");
	__xamarin_class_map [104].handle = objc_getClass ("NSNotification");
	__xamarin_class_map [105].handle = objc_getClass ("MPRatingCommand");
	__xamarin_class_map [106].handle = objc_getClass ("AVAudioUnitDistortion");
	__xamarin_class_map [107].handle = objc_getClass ("VNTrackObjectRequest");
	__xamarin_class_map [108].handle = objc_getClass ("MPRatingCommandEvent");
	__xamarin_class_map [109].handle = objc_getClass ("VNTrackRectangleRequest");
	__xamarin_class_map [110].handle = objc_getClass ("NSNotificationQueue");
	__xamarin_class_map [111].handle = objc_getClass ("AVAudioUnitEQ");
	__xamarin_class_map [112].handle = objc_getClass ("NSNull");
	__xamarin_class_map [113].handle = objc_getClass ("MPRemoteCommandCenter");
	__xamarin_class_map [114].handle = objc_getClass ("AVAudioUnitEQFilterParameters");
	__xamarin_class_map [115].handle = objc_getClass ("VNTranslationalImageRegistrationRequest");
	__xamarin_class_map [116].handle = objc_getClass ("WebScriptObject");
	__xamarin_class_map [117].handle = objc_getClass ("DOMObject");
	__xamarin_class_map [118].handle = objc_getClass ("DOMAbstractView");
	__xamarin_class_map [119].handle = objc_getClass ("NSValue");
	__xamarin_class_map [120].handle = objc_getClass ("NSNumber");
	__xamarin_class_map [121].handle = objc_getClass ("DOMNode");
	__xamarin_class_map [122].handle = objc_getClass ("DOMAttr");
	__xamarin_class_map [123].handle = objc_getClass ("AVAudioUnitGenerator");
	__xamarin_class_map [124].handle = objc_getClass ("MPSeekCommandEvent");
	__xamarin_class_map [125].handle = objc_getClass ("DOMBlob");
	__xamarin_class_map [126].handle = objc_getClass ("DOMCharacterData");
	__xamarin_class_map [127].handle = objc_getClass ("DOMText");
	__xamarin_class_map [128].handle = objc_getClass ("DOMCDATASection");
	__xamarin_class_map [129].handle = objc_getClass ("MPSkipIntervalCommand");
	__xamarin_class_map [130].handle = objc_getClass ("MPSkipIntervalCommandEvent");
	__xamarin_class_map [131].handle = objc_getClass ("DOMComment");
	__xamarin_class_map [132].handle = objc_getClass ("AVAudioUnitMIDIInstrument");
	__xamarin_class_map [133].handle = objc_getClass ("DOMCSSRule");
	__xamarin_class_map [134].handle = objc_getClass ("DOMCSSCharsetRule");
	__xamarin_class_map [135].handle = objc_getClass ("AVAudioUnitReverb");
	__xamarin_class_map [136].handle = objc_getClass ("DOMCSSFontFaceRule");
	__xamarin_class_map [137].handle = objc_getClass ("CIFilter");
	__xamarin_class_map [138].handle = objc_getClass ("CoreImage_CIAccordionFoldTransition");
	__xamarin_class_map [139].handle = objc_getClass ("MTLArgument");
	__xamarin_class_map [140].handle = objc_getClass ("DOMCSSMediaRule");
	__xamarin_class_map [141].handle = objc_getClass ("CoreImage_CICompositingFilter");
	__xamarin_class_map [142].handle = objc_getClass ("CoreImage_CIAdditionCompositing");
	__xamarin_class_map [143].handle = objc_getClass ("AVAudioUnitSampler");
	__xamarin_class_map [144].handle = objc_getClass ("DOMCSSPageRule");
	__xamarin_class_map [145].handle = objc_getClass ("CoreImage_CIAffineFilter");
	__xamarin_class_map [146].handle = objc_getClass ("CoreImage_CIAffineClamp");
	__xamarin_class_map [147].handle = objc_getClass ("AVAudioUnitTimeEffect");
	__xamarin_class_map [148].handle = objc_getClass ("NSFormatter");
	__xamarin_class_map [149].handle = objc_getClass ("NSNumberFormatter");
	__xamarin_class_map [150].handle = objc_getClass ("CoreImage_CIAffineTile");
	__xamarin_class_map [151].handle = objc_getClass ("MTLArgumentDescriptor");
	__xamarin_class_map [152].handle = objc_getClass ("DOMCSSRuleList");
	__xamarin_class_map [153].handle = objc_getClass ("AVAudioUnitTimePitch");
	__xamarin_class_map [154].handle = objc_getClass ("CoreImage_CIAffineTransform");
	__xamarin_class_map [155].handle = objc_getClass ("CoreImage_CIAreaAverage");
	__xamarin_class_map [156].handle = objc_getClass ("DOMCSSStyleDeclaration");
	__xamarin_class_map [157].handle = objc_getClass ("CoreImage_CIAreaHistogram");
	__xamarin_class_map [158].handle = objc_getClass ("AVAudioUnitVarispeed");
	__xamarin_class_map [159].handle = objc_getClass ("DOMCSSStyleRule");
	__xamarin_class_map [160].handle = objc_getClass ("CoreImage_CIAreaMaximum");
	__xamarin_class_map [161].handle = objc_getClass ("DOMStyleSheet");
	__xamarin_class_map [162].handle = objc_getClass ("DOMCSSStyleSheet");
	__xamarin_class_map [163].handle = objc_getClass ("CoreImage_CIAreaMaximumAlpha");
	__xamarin_class_map [164].handle = objc_getClass ("AVCameraCalibrationData");
	__xamarin_class_map [165].handle = objc_getClass ("DOMCSSUnknownRule");
	__xamarin_class_map [166].handle = objc_getClass ("CoreImage_CIAreaMinimum");
	__xamarin_class_map [167].handle = objc_getClass ("MTLType");
	__xamarin_class_map [168].handle = objc_getClass ("MTLArrayType");
	__xamarin_class_map [169].handle = objc_getClass ("CIColor");
	__xamarin_class_map [170].handle = objc_getClass ("CoreImage_CIAreaMinimumAlpha");
	__xamarin_class_map [171].handle = objc_getClass ("DOMCSSValue");
	__xamarin_class_map [172].handle = objc_getClass ("AVCaptureAudioChannel");
	__xamarin_class_map [173].handle = objc_getClass ("CoreImage_CIAreaMinMaxRed");
	__xamarin_class_map [174].handle = objc_getClass ("CIContext");
	__xamarin_class_map [175].handle = objc_getClass ("MTLAttribute");
	__xamarin_class_map [176].handle = objc_getClass ("AVCaptureOutput");
	__xamarin_class_map [177].handle = objc_getClass ("AVCaptureAudioDataOutput");
	__xamarin_class_map [178].handle = objc_getClass ("CoreImage_CIImageGenerator");
	__xamarin_class_map [179].handle = objc_getClass ("CoreImage_CIAttributedTextImageGenerator");
	__xamarin_class_map [180].handle = objc_getClass ("CIDetector");
	__xamarin_class_map [181].handle = objc_getClass ("MTLAttributeDescriptor");
	__xamarin_class_map [182].handle = objc_getClass ("MTLAttributeDescriptorArray");
	__xamarin_class_map [183].handle = objc_getClass ("CIBarcodeDescriptor");
	__xamarin_class_map [184].handle = objc_getClass ("CIAztecCodeDescriptor");
	__xamarin_class_map [185].handle = objc_getClass ("CoreImage_CICodeGenerator");
	__xamarin_class_map [186].handle = objc_getClass ("CoreImage_CIAztecCodeGenerator");
	__xamarin_class_map [187].handle = objc_getClass ("AVCaptureFileOutput");
	__xamarin_class_map [188].handle = objc_getClass ("AVCaptureAudioFileOutput");
	__xamarin_class_map [189].handle = objc_getClass ("AVCaptureAudioPreviewOutput");
	__xamarin_class_map [190].handle = objc_getClass ("NSOperation");
	__xamarin_class_map [191].handle = objc_getClass ("CoreImage_CIBarcodeGenerator");
	__xamarin_class_map [192].handle = objc_getClass ("DOMDocument");
	__xamarin_class_map [193].handle = objc_getClass ("CoreImage_CICmykHalftone");
	__xamarin_class_map [194].handle = objc_getClass ("CoreImage_CICMYKHalftone");
	__xamarin_class_map [195].handle = objc_getClass ("CoreImage_CITransitionFilter");
	__xamarin_class_map [196].handle = objc_getClass ("CoreImage_CIBarsSwipeTransition");
	__xamarin_class_map [197].handle = objc_getClass ("DOMDocumentFragment");
	__xamarin_class_map [198].handle = objc_getClass ("CoreImage_CIBicubicScaleTransform");
	__xamarin_class_map [199].handle = objc_getClass ("CIImage");
	__xamarin_class_map [200].handle = objc_getClass ("NSOperationQueue");
	__xamarin_class_map [201].handle = objc_getClass ("DOMDocumentType");
	__xamarin_class_map [202].handle = objc_getClass ("CoreImage_CIBlendFilter");
	__xamarin_class_map [203].handle = objc_getClass ("CISampler");
	__xamarin_class_map [204].handle = objc_getClass ("NSAccessibilityCustomAction");
	__xamarin_class_map [205].handle = objc_getClass ("CIVector");
	__xamarin_class_map [206].handle = objc_getClass ("AVCaptureConnection");
	__xamarin_class_map [207].handle = objc_getClass ("CLHeading");
	__xamarin_class_map [208].handle = objc_getClass ("CLLocation");
	__xamarin_class_map [209].handle = objc_getClass ("AVCaptureDataOutputSynchronizer");
	__xamarin_class_map [210].handle = objc_getClass ("CIKernel");
	__xamarin_class_map [211].handle = objc_getClass ("CIColorKernel");
	__xamarin_class_map [212].handle = objc_getClass ("CIBlendKernel");
	__xamarin_class_map [213].handle = objc_getClass ("CoreImage_CIBlendWithMask");
	__xamarin_class_map [214].handle = objc_getClass ("CoreImage_CIBlendWithAlphaMask");
	__xamarin_class_map [215].handle = objc_getClass ("NSOrthography");
	__xamarin_class_map [216].handle = objc_getClass ("CoreImage_CIBlendWithBlueMask");
	__xamarin_class_map [217].handle = objc_getClass ("NSStream");
	__xamarin_class_map [218].handle = objc_getClass ("NSOutputStream");
	__xamarin_class_map [219].handle = objc_getClass ("DOMElement");
	__xamarin_class_map [220].handle = objc_getClass ("MTLBufferLayoutDescriptor");
	__xamarin_class_map [221].handle = objc_getClass ("DOMEntityReference");
	__xamarin_class_map [222].handle = objc_getClass ("MTLBufferLayoutDescriptorArray");
	__xamarin_class_map [223].handle = objc_getClass ("CoreImage_CIBlendWithRedMask");
	__xamarin_class_map [224].handle = objc_getClass ("CoreImage_CIBloom");
	__xamarin_class_map [225].handle = objc_getClass ("DOMEvent");
	__xamarin_class_map [226].handle = objc_getClass ("CoreImage_CILinearBlur");
	__xamarin_class_map [227].handle = objc_getClass ("CoreImage_CIBokehBlur");
	__xamarin_class_map [228].handle = objc_getClass ("MTLCaptureManager");
	__xamarin_class_map [229].handle = objc_getClass ("NSPersonNameComponents");
	__xamarin_class_map [230].handle = objc_getClass ("CoreImage_CIBoxBlur");
	__xamarin_class_map [231].handle = objc_getClass ("CoreImage_CIDistortionFilter");
	__xamarin_class_map [232].handle = objc_getClass ("CoreImage_CIBumpDistortion");
	__xamarin_class_map [233].handle = objc_getClass ("NSPersonNameComponentsFormatter");
	__xamarin_class_map [234].handle = objc_getClass ("CoreImage_CIBumpDistortionLinear");
	__xamarin_class_map [235].handle = objc_getClass ("NSPipe");
	__xamarin_class_map [236].handle = objc_getClass ("DOMFile");
	__xamarin_class_map [237].handle = objc_getClass ("CoreImage_CICheckerboardGenerator");
	__xamarin_class_map [238].handle = objc_getClass ("DOMFileList");
	__xamarin_class_map [239].handle = objc_getClass ("CoreImage_CICircleSplashDistortion");
	__xamarin_class_map [240].handle = objc_getClass ("NSAppearance");
	__xamarin_class_map [241].handle = objc_getClass ("NSPort");
	__xamarin_class_map [242].handle = objc_getClass ("CoreImage_CIScreenFilter");
	__xamarin_class_map [243].handle = objc_getClass ("CoreImage_CICircularScreen");
	__xamarin_class_map [244].handle = objc_getClass ("AVCaptureDeviceFormat");
	__xamarin_class_map [245].handle = objc_getClass ("CoreImage_CICircularWrap");
	__xamarin_class_map [246].handle = objc_getClass ("AVCaptureInput");
	__xamarin_class_map [247].handle = objc_getClass ("AVCaptureDeviceInput");
	__xamarin_class_map [248].handle = objc_getClass ("CoreImage_CIClamp");
	__xamarin_class_map [249].handle = objc_getClass ("DOMHTMLElement");
	__xamarin_class_map [250].handle = objc_getClass ("DOMHTMLAnchorElement");
	__xamarin_class_map [251].handle = objc_getClass ("NSPortMessage");
	__xamarin_class_map [252].handle = objc_getClass ("AVCaptureDeviceInputSource");
	__xamarin_class_map [253].handle = objc_getClass ("CoreImage_CICode128BarcodeGenerator");
	__xamarin_class_map [254].handle = objc_getClass ("NSPortNameServer");
	__xamarin_class_map [255].handle = objc_getClass ("DOMHTMLAppletElement");
	__xamarin_class_map [256].handle = objc_getClass ("NSPredicate");
	__xamarin_class_map [257].handle = objc_getClass ("DOMHTMLAreaElement");
	__xamarin_class_map [258].handle = objc_getClass ("DOMHTMLBaseElement");
	__xamarin_class_map [259].handle = objc_getClass ("MTLCompileOptions");
	__xamarin_class_map [260].handle = objc_getClass ("DOMHTMLBaseFontElement");
	__xamarin_class_map [261].handle = objc_getClass ("CoreImage_CIColorBlendMode");
	__xamarin_class_map [262].handle = objc_getClass ("CoreImage_CIColorBurnBlendMode");
	__xamarin_class_map [263].handle = objc_getClass ("CoreImage_CIColorClamp");
	__xamarin_class_map [264].handle = objc_getClass ("DOMHTMLBodyElement");
	__xamarin_class_map [265].handle = objc_getClass ("CoreImage_CIColorControls");
	__xamarin_class_map [266].handle = objc_getClass ("DOMHTMLBRElement");
	__xamarin_class_map [267].handle = objc_getClass ("CoreImage_CIColorCrossPolynomial");
	__xamarin_class_map [268].handle = objc_getClass ("CoreImage_CIColorCube");
	__xamarin_class_map [269].handle = objc_getClass ("DOMHTMLButtonElement");
	__xamarin_class_map [270].handle = objc_getClass ("CoreImage_CIColorCubesMixedWithMask");
	__xamarin_class_map [271].handle = objc_getClass ("DOMHTMLCollection");
	__xamarin_class_map [272].handle = objc_getClass ("CoreImage_CIColorCubeWithColorSpace");
	__xamarin_class_map [273].handle = objc_getClass ("AVCaptureInputPort");
	__xamarin_class_map [274].handle = objc_getClass ("MTLComputePipelineDescriptor");
	__xamarin_class_map [275].handle = objc_getClass ("DOMHTMLDirectoryElement");
	__xamarin_class_map [276].handle = objc_getClass ("CoreImage_CIColorCurves");
	__xamarin_class_map [277].handle = objc_getClass ("MTLComputePipelineReflection");
	__xamarin_class_map [278].handle = objc_getClass ("CoreImage_CIColorDodgeBlendMode");
	__xamarin_class_map [279].handle = objc_getClass ("CoreImage_CIColorInvert");
	__xamarin_class_map [280].handle = objc_getClass ("DOMHTMLDivElement");
	__xamarin_class_map [281].handle = objc_getClass ("AVCaptureMovieFileOutput");
	__xamarin_class_map [282].handle = objc_getClass ("DOMHTMLDListElement");
	__xamarin_class_map [283].handle = objc_getClass ("CoreImage_CIColorMap");
	__xamarin_class_map [284].handle = objc_getClass ("CoreImage_CIColorMatrix");
	__xamarin_class_map [285].handle = objc_getClass ("CoreImage_CIColorMonochrome");
	__xamarin_class_map [286].handle = objc_getClass ("DOMHTMLDocument");
	__xamarin_class_map [287].handle = objc_getClass ("CoreImage_CIColorPolynomial");
	__xamarin_class_map [288].handle = objc_getClass ("AVCaptureScreenInput");
	__xamarin_class_map [289].handle = objc_getClass ("CoreImage_CIColorPosterize");
	__xamarin_class_map [290].handle = objc_getClass ("CoreImage_CIColumnAverage");
	__xamarin_class_map [291].handle = objc_getClass ("MTLDepthStencilDescriptor");
	__xamarin_class_map [292].handle = objc_getClass ("CoreImage_CIComicEffect");
	__xamarin_class_map [293].handle = objc_getClass ("CoreImage_CIConstantColorGenerator");
	__xamarin_class_map [294].handle = objc_getClass ("DOMHTMLEmbedElement");
	__xamarin_class_map [295].handle = objc_getClass ("DOMHTMLFieldSetElement");
	__xamarin_class_map [296].handle = objc_getClass ("DOMHTMLFontElement");
	__xamarin_class_map [297].handle = objc_getClass ("AVCaptureSynchronizedData");
	__xamarin_class_map [298].handle = objc_getClass ("DOMHTMLFormElement");
	__xamarin_class_map [299].handle = objc_getClass ("NSPropertyListSerialization");
	__xamarin_class_map [300].handle = objc_getClass ("AVCaptureSynchronizedDataCollection");
	__xamarin_class_map [301].handle = objc_getClass ("NSData");
	__xamarin_class_map [302].handle = objc_getClass ("NSMutableData");
	__xamarin_class_map [303].handle = objc_getClass ("NSPurgeableData");
	__xamarin_class_map [304].handle = objc_getClass ("DOMHTMLFrameElement");
	__xamarin_class_map [305].handle = objc_getClass ("AVCaptureVideoDataOutput");
	__xamarin_class_map [306].handle = objc_getClass ("NSRecursiveLock");
	__xamarin_class_map [307].handle = objc_getClass ("DOMHTMLFrameSetElement");
	__xamarin_class_map [308].handle = objc_getClass ("DOMHTMLHeadElement");
	__xamarin_class_map [309].handle = objc_getClass ("DOMHTMLHeadingElement");
	__xamarin_class_map [310].handle = objc_getClass ("DOMHTMLHRElement");
	__xamarin_class_map [311].handle = objc_getClass ("CoreImage_CIConvolutionCore");
	__xamarin_class_map [312].handle = objc_getClass ("CoreImage_CIConvolution3X3");
	__xamarin_class_map [313].handle = objc_getClass ("NSRegularExpression");
	__xamarin_class_map [314].handle = objc_getClass ("CoreImage_CIConvolution5X5");
	__xamarin_class_map [315].handle = objc_getClass ("DOMHTMLHtmlElement");
	__xamarin_class_map [316].handle = objc_getClass ("CoreImage_CIConvolution7X7");
	__xamarin_class_map [317].handle = objc_getClass ("CoreImage_CIConvolution9Horizontal");
	__xamarin_class_map [318].handle = objc_getClass ("NSRunLoop");
	__xamarin_class_map [319].handle = objc_getClass ("CoreImage_CIConvolution9Vertical");
	__xamarin_class_map [320].handle = objc_getClass ("DOMHTMLIFrameElement");
	__xamarin_class_map [321].handle = objc_getClass ("CoreImage_CICopyMachineTransition");
	__xamarin_class_map [322].handle = objc_getClass ("NSScriptCommand");
	__xamarin_class_map [323].handle = objc_getClass ("CoreImage_CICrop");
	__xamarin_class_map [324].handle = objc_getClass ("CoreImage_CICrystallize");
	__xamarin_class_map [325].handle = objc_getClass ("NSAlignmentFeedbackFilter");
	__xamarin_class_map [326].handle = objc_getClass ("AVAsset");
	__xamarin_class_map [327].handle = objc_getClass ("AVComposition");
	__xamarin_class_map [328].handle = objc_getClass ("DOMHTMLImageElement");
	__xamarin_class_map [329].handle = objc_getClass ("CoreImage_CIDarkenBlendMode");
	__xamarin_class_map [330].handle = objc_getClass ("NSScriptCommandDescription");
	__xamarin_class_map [331].handle = objc_getClass ("MTLFunctionConstant");
	__xamarin_class_map [332].handle = objc_getClass ("AVAssetTrack");
	__xamarin_class_map [333].handle = objc_getClass ("AVCompositionTrack");
	__xamarin_class_map [334].handle = objc_getClass ("CIDataMatrixCodeDescriptor");
	__xamarin_class_map [335].handle = objc_getClass ("MTLFunctionConstantValues");
	__xamarin_class_map [336].handle = objc_getClass ("CWConfiguration");
	__xamarin_class_map [337].handle = objc_getClass ("CoreImage_CIDepthBlurEffect");
	__xamarin_class_map [338].handle = objc_getClass ("AVAssetTrackSegment");
	__xamarin_class_map [339].handle = objc_getClass ("AVCompositionTrackSegment");
	__xamarin_class_map [340].handle = objc_getClass ("CWInterface");
	__xamarin_class_map [341].handle = objc_getClass ("CoreImage_CIDepthDisparityConverter");
	__xamarin_class_map [342].handle = objc_getClass ("DOMHTMLInputElement");
	__xamarin_class_map [343].handle = objc_getClass ("EKObject");
	__xamarin_class_map [344].handle = objc_getClass ("EKRecurrenceRule");
	__xamarin_class_map [345].handle = objc_getClass ("EKRecurrenceDayOfWeek");
	__xamarin_class_map [346].handle = objc_getClass ("EKCalendarItem");
	__xamarin_class_map [347].handle = objc_getClass ("EKEvent");
	__xamarin_class_map [348].handle = objc_getClass ("EKAlarm");
	__xamarin_class_map [349].handle = objc_getClass ("CoreImage_CIDepthOfField");
	__xamarin_class_map [350].handle = objc_getClass ("DOMHTMLLabelElement");
	__xamarin_class_map [351].handle = objc_getClass ("CoreImage_CIDepthToDisparity");
	__xamarin_class_map [352].handle = objc_getClass ("MTLHeapDescriptor");
	__xamarin_class_map [353].handle = objc_getClass ("DOMHTMLLegendElement");
	__xamarin_class_map [354].handle = objc_getClass ("GCExtendedGamepad");
	__xamarin_class_map [355].handle = objc_getClass ("GCExtendedGamepadSnapshot");
	__xamarin_class_map [356].handle = objc_getClass ("NSSortDescriptor");
	__xamarin_class_map [357].handle = objc_getClass ("DOMHTMLLIElement");
	__xamarin_class_map [358].handle = objc_getClass ("GCGamepad");
	__xamarin_class_map [359].handle = objc_getClass ("GCGamepadSnapshot");
	__xamarin_class_map [360].handle = objc_getClass ("NSAnimationContext");
	__xamarin_class_map [361].handle = objc_getClass ("DOMHTMLLinkElement");
	__xamarin_class_map [362].handle = objc_getClass ("CoreImage_CIDifferenceBlendMode");
	__xamarin_class_map [363].handle = objc_getClass ("GKBehavior");
	__xamarin_class_map [364].handle = objc_getClass ("DOMHTMLMapElement");
	__xamarin_class_map [365].handle = objc_getClass ("CoreImage_CIDiscBlur");
	__xamarin_class_map [366].handle = objc_getClass ("DOMHTMLMarqueeElement");
	__xamarin_class_map [367].handle = objc_getClass ("GKComponentSystem");
	__xamarin_class_map [368].handle = objc_getClass ("CoreImage_CIDisintegrateWithMaskTransition");
	__xamarin_class_map [369].handle = objc_getClass ("GKCompositeBehavior");
	__xamarin_class_map [370].handle = objc_getClass ("DOMHTMLMenuElement");
	__xamarin_class_map [371].handle = objc_getClass ("CoreImage_CIDisparityToDepth");
	__xamarin_class_map [372].handle = objc_getClass ("GKEntity");
	__xamarin_class_map [373].handle = objc_getClass ("AVContentKeyResponse");
	__xamarin_class_map [374].handle = objc_getClass ("CoreImage_CIDisplacementDistortion");
	__xamarin_class_map [375].handle = objc_getClass ("DOMHTMLMetaElement");
	__xamarin_class_map [376].handle = objc_getClass ("CoreImage_CIDissolveTransition");
	__xamarin_class_map [377].handle = objc_getClass ("GKGraph");
	__xamarin_class_map [378].handle = objc_getClass ("GKGridGraph");
	__xamarin_class_map [379].handle = objc_getClass ("DOMHTMLModElement");
	__xamarin_class_map [380].handle = objc_getClass ("GKObstacleGraph");
	__xamarin_class_map [381].handle = objc_getClass ("AVContentKeySession");
	__xamarin_class_map [382].handle = objc_getClass ("CoreImage_CIDivideBlendMode");
	__xamarin_class_map [383].handle = objc_getClass ("GKPath");
	__xamarin_class_map [384].handle = objc_getClass ("NSImageRep");
	__xamarin_class_map [385].handle = objc_getClass ("NSCachedImageRep");
	__xamarin_class_map [386].handle = objc_getClass ("CoreImage_CIDotScreen");
	__xamarin_class_map [387].handle = objc_getClass ("MTLPipelineBufferDescriptor");
	__xamarin_class_map [388].handle = objc_getClass ("GKObstacle");
	__xamarin_class_map [389].handle = objc_getClass ("GKPolygonObstacle");
	__xamarin_class_map [390].handle = objc_getClass ("DOMHTMLObjectElement");
	__xamarin_class_map [391].handle = objc_getClass ("CoreImage_CIDroste");
	__xamarin_class_map [392].handle = objc_getClass ("MTLPipelineBufferDescriptorArray");
	__xamarin_class_map [393].handle = objc_getClass ("GKState");
	__xamarin_class_map [394].handle = objc_getClass ("DOMHTMLOListElement");
	__xamarin_class_map [395].handle = objc_getClass ("CoreImage_CIEdgePreserveUpsampleFilter");
	__xamarin_class_map [396].handle = objc_getClass ("GKStateMachine");
	__xamarin_class_map [397].handle = objc_getClass ("NSTouchBarItem");
	__xamarin_class_map [398].handle = objc_getClass ("NSCandidateListTouchBarItem");
	__xamarin_class_map [399].handle = objc_getClass ("CoreImage_CIEdges");
	__xamarin_class_map [400].handle = objc_getClass ("DOMHTMLOptGroupElement");
	__xamarin_class_map [401].handle = objc_getClass ("CoreImage_CIEdgeWork");
	__xamarin_class_map [402].handle = objc_getClass ("GLKMesh");
	__xamarin_class_map [403].handle = objc_getClass ("AVMetadataGroup");
	__xamarin_class_map [404].handle = objc_getClass ("AVDateRangeMetadataGroup");
	__xamarin_class_map [405].handle = objc_getClass ("MTLPointerType");
	__xamarin_class_map [406].handle = objc_getClass ("DOMHTMLOptionElement");
	__xamarin_class_map [407].handle = objc_getClass ("CoreImage_CITileFilter");
	__xamarin_class_map [408].handle = objc_getClass ("CoreImage_CIEightfoldReflectedTile");
	__xamarin_class_map [409].handle = objc_getClass ("CoreImage_CIExclusionBlendMode");
	__xamarin_class_map [410].handle = objc_getClass ("DOMHTMLOptionsCollection");
	__xamarin_class_map [411].handle = objc_getClass ("AVDepthData");
	__xamarin_class_map [412].handle = objc_getClass ("CoreImage_CIExposureAdjust");
	__xamarin_class_map [413].handle = objc_getClass ("DOMHTMLParagraphElement");
	__xamarin_class_map [414].handle = objc_getClass ("CoreImage_CIFaceBalance");
	__xamarin_class_map [415].handle = objc_getClass ("DOMHTMLParamElement");
	__xamarin_class_map [416].handle = objc_getClass ("DOMHTMLPreElement");
	__xamarin_class_map [417].handle = objc_getClass ("CIFeature");
	__xamarin_class_map [418].handle = objc_getClass ("CIFaceFeature");
	__xamarin_class_map [419].handle = objc_getClass ("DOMHTMLQuoteElement");
	__xamarin_class_map [420].handle = objc_getClass ("CoreImage_CIFalseColor");
	__xamarin_class_map [421].handle = objc_getClass ("DOMHTMLScriptElement");
	__xamarin_class_map [422].handle = objc_getClass ("NSTextCheckingResult");
	__xamarin_class_map [423].handle = objc_getClass ("DOMHTMLSelectElement");
	__xamarin_class_map [424].handle = objc_getClass ("AVURLAsset");
	__xamarin_class_map [425].handle = objc_getClass ("AVFragmentedAsset");
	__xamarin_class_map [426].handle = objc_getClass ("INCallRecord");
	__xamarin_class_map [427].handle = objc_getClass ("DOMHTMLStyleElement");
	__xamarin_class_map [428].handle = objc_getClass ("INIntentResolutionResult");
	__xamarin_class_map [429].handle = objc_getClass ("INCallRecordTypeResolutionResult");
	__xamarin_class_map [430].handle = objc_getClass ("DOMHTMLTableCaptionElement");
	__xamarin_class_map [431].handle = objc_getClass ("AVFragmentedAssetMinder");
	__xamarin_class_map [432].handle = objc_getClass ("AVFragmentedAssetTrack");
	__xamarin_class_map [433].handle = objc_getClass ("DOMHTMLTableCellElement");
	__xamarin_class_map [434].handle = objc_getClass ("NSTimer");
	__xamarin_class_map [435].handle = objc_getClass ("DOMHTMLTableColElement");
	__xamarin_class_map [436].handle = objc_getClass ("MTLRenderPassAttachmentDescriptor");
	__xamarin_class_map [437].handle = objc_getClass ("NSTimeZone");
	__xamarin_class_map [438].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptor");
	__xamarin_class_map [439].handle = objc_getClass ("AVFragmentedMovieMinder");
	__xamarin_class_map [440].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptorArray");
	__xamarin_class_map [441].handle = objc_getClass ("CIFilterGenerator");
	__xamarin_class_map [442].handle = objc_getClass ("DOMHTMLTableElement");
	__xamarin_class_map [443].handle = objc_getClass ("NSController");
	__xamarin_class_map [444].handle = objc_getClass ("NSObjectController");
	__xamarin_class_map [445].handle = objc_getClass ("NSArrayController");
	__xamarin_class_map [446].handle = objc_getClass ("MTLRenderPassDepthAttachmentDescriptor");
	__xamarin_class_map [447].handle = objc_getClass ("NSTypesetter");
	__xamarin_class_map [448].handle = objc_getClass ("NSATSTypesetter");
	__xamarin_class_map [449].handle = objc_getClass ("DOMHTMLTableRowElement");
	__xamarin_class_map [450].handle = objc_getClass ("MTLRenderPassDescriptor");
	__xamarin_class_map [451].handle = objc_getClass ("AVFrameRateRange");
	__xamarin_class_map [452].handle = objc_getClass ("INMessageAttributeOptionsResolutionResult");
	__xamarin_class_map [453].handle = objc_getClass ("MTLRenderPassStencilAttachmentDescriptor");
	__xamarin_class_map [454].handle = objc_getClass ("DOMHTMLTableSectionElement");
	__xamarin_class_map [455].handle = objc_getClass ("INMessageAttributeResolutionResult");
	__xamarin_class_map [456].handle = objc_getClass ("CIFilterShape");
	__xamarin_class_map [457].handle = objc_getClass ("NSUnit");
	__xamarin_class_map [458].handle = objc_getClass ("DOMHTMLTextAreaElement");
	__xamarin_class_map [459].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptor");
	__xamarin_class_map [460].handle = objc_getClass ("CoreImage_CIFlashTransition");
	__xamarin_class_map [461].handle = objc_getClass ("NSDimension");
	__xamarin_class_map [462].handle = objc_getClass ("NSUnitAcceleration");
	__xamarin_class_map [463].handle = objc_getClass ("CoreImage_CIFourfoldReflectedTile");
	__xamarin_class_map [464].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptorArray");
	__xamarin_class_map [465].handle = objc_getClass ("DOMImplementation");
	__xamarin_class_map [466].handle = objc_getClass ("AVMediaDataStorage");
	__xamarin_class_map [467].handle = objc_getClass ("CoreImage_CIFourfoldRotatedTile");
	__xamarin_class_map [468].handle = objc_getClass ("DOMCSSImportRule");
	__xamarin_class_map [469].handle = objc_getClass ("NSUnitAngle");
	__xamarin_class_map [470].handle = objc_getClass ("CoreImage_CIFourfoldTranslatedTile");
	__xamarin_class_map [471].handle = objc_getClass ("AVMediaSelection");
	__xamarin_class_map [472].handle = objc_getClass ("NSBezierPath");
	__xamarin_class_map [473].handle = objc_getClass ("CoreImage_CIGammaAdjust");
	__xamarin_class_map [474].handle = objc_getClass ("NSUnitArea");
	__xamarin_class_map [475].handle = objc_getClass ("INIntent");
	__xamarin_class_map [476].handle = objc_getClass ("INSearchCallHistoryIntent");
	__xamarin_class_map [477].handle = objc_getClass ("DOMUIEvent");
	__xamarin_class_map [478].handle = objc_getClass ("DOMKeyboardEvent");
	__xamarin_class_map [479].handle = objc_getClass ("CoreImage_CIGaussianBlur");
	__xamarin_class_map [480].handle = objc_getClass ("AVMediaSelectionGroup");
	__xamarin_class_map [481].handle = objc_getClass ("CoreImage_CIGaussianGradient");
	__xamarin_class_map [482].handle = objc_getClass ("NSUnitConcentrationMass");
	__xamarin_class_map [483].handle = objc_getClass ("DOMMediaList");
	__xamarin_class_map [484].handle = objc_getClass ("CoreImage_CIGlassDistortion");
	__xamarin_class_map [485].handle = objc_getClass ("NSUnitConverter");
	__xamarin_class_map [486].handle = objc_getClass ("MTLRenderPipelineDescriptor");
	__xamarin_class_map [487].handle = objc_getClass ("CoreImage_CIGlassLozenge");
	__xamarin_class_map [488].handle = objc_getClass ("AVMediaSelectionOption");
	__xamarin_class_map [489].handle = objc_getClass ("NSUnitConverterLinear");
	__xamarin_class_map [490].handle = objc_getClass ("DOMMouseEvent");
	__xamarin_class_map [491].handle = objc_getClass ("CoreImage_CIGlideReflectedTile");
	__xamarin_class_map [492].handle = objc_getClass ("INSpeakableString");
	__xamarin_class_map [493].handle = objc_getClass ("MTLRenderPipelineReflection");
	__xamarin_class_map [494].handle = objc_getClass ("NSUnitDispersion");
	__xamarin_class_map [495].handle = objc_getClass ("CoreImage_CIGloom");
	__xamarin_class_map [496].handle = objc_getClass ("NSBitmapImageRep");
	__xamarin_class_map [497].handle = objc_getClass ("DOMNamedNodeMap");
	__xamarin_class_map [498].handle = objc_getClass ("CoreImage_CIHardLightBlendMode");
	__xamarin_class_map [499].handle = objc_getClass ("NSUnitDuration");
	__xamarin_class_map [500].handle = objc_getClass ("CoreImage_CIHatchedScreen");
	__xamarin_class_map [501].handle = objc_getClass ("CoreImage_CIHeightFieldFromMask");
	__xamarin_class_map [502].handle = objc_getClass ("IOSurface");
	__xamarin_class_map [503].handle = objc_getClass ("NSUnitElectricCharge");
	__xamarin_class_map [504].handle = objc_getClass ("CoreImage_CIHexagonalPixellate");
	__xamarin_class_map [505].handle = objc_getClass ("NSBox");
	__xamarin_class_map [506].handle = objc_getClass ("NSUnitElectricCurrent");
	__xamarin_class_map [507].handle = objc_getClass ("CoreImage_CIHighlightShadowAdjust");
	__xamarin_class_map [508].handle = objc_getClass ("JSContext");
	__xamarin_class_map [509].handle = objc_getClass ("JSValue");
	__xamarin_class_map [510].handle = objc_getClass ("CoreImage_CIHistogramDisplayFilter");
	__xamarin_class_map [511].handle = objc_getClass ("NSUnitElectricPotentialDifference");
	__xamarin_class_map [512].handle = objc_getClass ("CoreImage_CIHoleDistortion");
	__xamarin_class_map [513].handle = objc_getClass ("DOMNodeIterator");
	__xamarin_class_map [514].handle = objc_getClass ("NSUnitElectricResistance");
	__xamarin_class_map [515].handle = objc_getClass ("CoreImage_CIHueAdjust");
	__xamarin_class_map [516].handle = objc_getClass ("DOMNodeList");
	__xamarin_class_map [517].handle = objc_getClass ("MKShape");
	__xamarin_class_map [518].handle = objc_getClass ("MKMultiPoint");
	__xamarin_class_map [519].handle = objc_getClass ("MKPolyline");
	__xamarin_class_map [520].handle = objc_getClass ("MKGeodesicPolyline");
	__xamarin_class_map [521].handle = objc_getClass ("CoreImage_CIHueBlendMode");
	__xamarin_class_map [522].handle = objc_getClass ("NSUnitEnergy");
	__xamarin_class_map [523].handle = objc_getClass ("MTLSamplerDescriptor");
	__xamarin_class_map [524].handle = objc_getClass ("CoreImage_CIHueSaturationValueGradient");
	__xamarin_class_map [525].handle = objc_getClass ("DOMOverflowEvent");
	__xamarin_class_map [526].handle = objc_getClass ("NSUnitFrequency");
	__xamarin_class_map [527].handle = objc_getClass ("MKMapItem");
	__xamarin_class_map [528].handle = objc_getClass ("NSCIImageRep");
	__xamarin_class_map [529].handle = objc_getClass ("DOMProcessingInstruction");
	__xamarin_class_map [530].handle = objc_getClass ("NSUnitFuelEfficiency");
	__xamarin_class_map [531].handle = objc_getClass ("DOMProgressEvent");
	__xamarin_class_map [532].handle = objc_getClass ("NSUnitIlluminance");
	__xamarin_class_map [533].handle = objc_getClass ("MTLStageInputOutputDescriptor");
	__xamarin_class_map [534].handle = objc_getClass ("MKPolygon");
	__xamarin_class_map [535].handle = objc_getClass ("NSBrowserCell");
	__xamarin_class_map [536].handle = objc_getClass ("NSUnitLength");
	__xamarin_class_map [537].handle = objc_getClass ("DOMRange");
	__xamarin_class_map [538].handle = objc_getClass ("MTLStencilDescriptor");
	__xamarin_class_map [539].handle = objc_getClass ("NSClipView");
	__xamarin_class_map [540].handle = objc_getClass ("AVMetadataObject");
	__xamarin_class_map [541].handle = objc_getClass ("AVMetadataFaceObject");
	__xamarin_class_map [542].handle = objc_getClass ("NSUnitMass");
	__xamarin_class_map [543].handle = objc_getClass ("DOMStyleSheetList");
	__xamarin_class_map [544].handle = objc_getClass ("NSUnitPower");
	__xamarin_class_map [545].handle = objc_getClass ("MTLStructMember");
	__xamarin_class_map [546].handle = objc_getClass ("CIImageAccumulator");
	__xamarin_class_map [547].handle = objc_getClass ("DOMWheelEvent");
	__xamarin_class_map [548].handle = objc_getClass ("NSUnitPressure");
	__xamarin_class_map [549].handle = objc_getClass ("MTLStructType");
	__xamarin_class_map [550].handle = objc_getClass ("AVMetadataItemFilter");
	__xamarin_class_map [551].handle = objc_getClass ("WebArchive");
	__xamarin_class_map [552].handle = objc_getClass ("NSUnitSpeed");
	__xamarin_class_map [553].handle = objc_getClass ("AVMetadataItemValueRequest");
	__xamarin_class_map [554].handle = objc_getClass ("WebBackForwardList");
	__xamarin_class_map [555].handle = objc_getClass ("NSUnitTemperature");
	__xamarin_class_map [556].handle = objc_getClass ("WebDataSource");
	__xamarin_class_map [557].handle = objc_getClass ("CIImageProcessorKernel");
	__xamarin_class_map [558].handle = objc_getClass ("NSUnitVolume");
	__xamarin_class_map [559].handle = objc_getClass ("NSURLDownload");
	__xamarin_class_map [560].handle = objc_getClass ("WebDownload");
	__xamarin_class_map [561].handle = objc_getClass ("MTLVertexAttributeDescriptorArray");
	__xamarin_class_map [562].handle = objc_getClass ("MTLVertexBufferLayoutDescriptorArray");
	__xamarin_class_map [563].handle = objc_getClass ("AVMovie");
	__xamarin_class_map [564].handle = objc_getClass ("MTLVertexDescriptor");
	__xamarin_class_map [565].handle = objc_getClass ("MTLTextureDescriptor");
	__xamarin_class_map [566].handle = objc_getClass ("MTKMesh");
	__xamarin_class_map [567].handle = objc_getClass ("MTKMeshBufferAllocator");
	__xamarin_class_map [568].handle = objc_getClass ("AVMovieTrack");
	__xamarin_class_map [569].handle = objc_getClass ("CoreImage_CIKaleidoscope");
	__xamarin_class_map [570].handle = objc_getClass ("MTLTextureReferenceType");
	__xamarin_class_map [571].handle = objc_getClass ("MPSKernel");
	__xamarin_class_map [572].handle = objc_getClass ("MPSUnaryImageKernel");
	__xamarin_class_map [573].handle = objc_getClass ("MPSImageLanczosScale");
	__xamarin_class_map [574].handle = objc_getClass ("WebFrame");
	__xamarin_class_map [575].handle = objc_getClass ("MPSCNNConvolutionDescriptor");
	__xamarin_class_map [576].handle = objc_getClass ("NSCollectionView");
	__xamarin_class_map [577].handle = objc_getClass ("NSCollectionViewLayout");
	__xamarin_class_map [578].handle = objc_getClass ("NSCollectionViewFlowLayout");
	__xamarin_class_map [579].handle = objc_getClass ("MPSCNNKernel");
	__xamarin_class_map [580].handle = objc_getClass ("MPSCNNNeuron");
	__xamarin_class_map [581].handle = objc_getClass ("MPSCNNNeuronPReLU");
	__xamarin_class_map [582].handle = objc_getClass ("CoreImage_CILabDeltaE");
	__xamarin_class_map [583].handle = objc_getClass ("MPSCNNBinaryConvolution");
	__xamarin_class_map [584].handle = objc_getClass ("MPSCNNBinaryFullyConnected");
	__xamarin_class_map [585].handle = objc_getClass ("AVMusicTrack");
	__xamarin_class_map [586].handle = objc_getClass ("NSCollectionViewLayoutInvalidationContext");
	__xamarin_class_map [587].handle = objc_getClass ("NSCollectionViewFlowLayoutInvalidationContext");
	__xamarin_class_map [588].handle = objc_getClass ("CoreImage_CILanczosScaleTransform");
	__xamarin_class_map [589].handle = objc_getClass ("CoreImage_CILenticularHaloGenerator");
	__xamarin_class_map [590].handle = objc_getClass ("MTLVertexAttribute");
	__xamarin_class_map [591].handle = objc_getClass ("AVAudioMix");
	__xamarin_class_map [592].handle = objc_getClass ("AVMutableAudioMix");
	__xamarin_class_map [593].handle = objc_getClass ("CoreImage_CILightenBlendMode");
	__xamarin_class_map [594].handle = objc_getClass ("NSCollectionViewGridLayout");
	__xamarin_class_map [595].handle = objc_getClass ("MTLVertexAttributeDescriptor");
	__xamarin_class_map [596].handle = objc_getClass ("CoreImage_CILightTunnel");
	__xamarin_class_map [597].handle = objc_getClass ("AVAudioMixInputParameters");
	__xamarin_class_map [598].handle = objc_getClass ("AVMutableAudioMixInputParameters");
	__xamarin_class_map [599].handle = objc_getClass ("NSViewController");
	__xamarin_class_map [600].handle = objc_getClass ("NSCollectionViewItem");
	__xamarin_class_map [601].handle = objc_getClass ("CoreImage_CILinearBurnBlendMode");
	__xamarin_class_map [602].handle = objc_getClass ("MTLVertexBufferLayoutDescriptor");
	__xamarin_class_map [603].handle = objc_getClass ("WebFrameView");
	__xamarin_class_map [604].handle = objc_getClass ("AVMutableComposition");
	__xamarin_class_map [605].handle = objc_getClass ("CoreImage_CILinearDodgeBlendMode");
	__xamarin_class_map [606].handle = objc_getClass ("CoreImage_CILinearGradient");
	__xamarin_class_map [607].handle = objc_getClass ("MDLAnimatedValue");
	__xamarin_class_map [608].handle = objc_getClass ("MDLAnimatedScalarArray");
	__xamarin_class_map [609].handle = objc_getClass ("MDLAnimatedVector3Array");
	__xamarin_class_map [610].handle = objc_getClass ("MDLAnimatedQuaternionArray");
	__xamarin_class_map [611].handle = objc_getClass ("MDLAnimatedScalar");
	__xamarin_class_map [612].handle = objc_getClass ("MDLAnimatedVector2");
	__xamarin_class_map [613].handle = objc_getClass ("MDLAnimatedVector3");
	__xamarin_class_map [614].handle = objc_getClass ("MDLAnimatedVector4");
	__xamarin_class_map [615].handle = objc_getClass ("MDLAnimatedMatrix4x4");
	__xamarin_class_map [616].handle = objc_getClass ("MDLMatrix4x4Array");
	__xamarin_class_map [617].handle = objc_getClass ("WebHistory");
	__xamarin_class_map [618].handle = objc_getClass ("MDLAsset");
	__xamarin_class_map [619].handle = objc_getClass ("CoreImage_CILinearToSRGBToneCurve");
	__xamarin_class_map [620].handle = objc_getClass ("AVMutableCompositionTrack");
	__xamarin_class_map [621].handle = objc_getClass ("MDLTexture");
	__xamarin_class_map [622].handle = objc_getClass ("MDLNoiseTexture");
	__xamarin_class_map [623].handle = objc_getClass ("CoreImage_CILineOverlay");
	__xamarin_class_map [624].handle = objc_getClass ("MDLTransform");
	__xamarin_class_map [625].handle = objc_getClass ("AVMutableDateRangeMetadataGroup");
	__xamarin_class_map [626].handle = objc_getClass ("CoreImage_CILineScreen");
	__xamarin_class_map [627].handle = objc_getClass ("AVMutableMediaSelection");
	__xamarin_class_map [628].handle = objc_getClass ("NSCollectionViewLayoutAttributes");
	__xamarin_class_map [629].handle = objc_getClass ("CoreImage_CILuminosityBlendMode");
	__xamarin_class_map [630].handle = objc_getClass ("MDLVertexDescriptor");
	__xamarin_class_map [631].handle = objc_getClass ("CoreImage_CIMaskedVariableBlur");
	__xamarin_class_map [632].handle = objc_getClass ("AVMetadataItem");
	__xamarin_class_map [633].handle = objc_getClass ("AVMutableMetadataItem");
	__xamarin_class_map [634].handle = objc_getClass ("CoreImage_CIMaskToAlpha");
	__xamarin_class_map [635].handle = objc_getClass ("MCPeerID");
	__xamarin_class_map [636].handle = objc_getClass ("MCAdvertiserAssistant");
	__xamarin_class_map [637].handle = objc_getClass ("CoreImage_CIMaximumComponent");
	__xamarin_class_map [638].handle = objc_getClass ("MTKMeshBuffer");
	__xamarin_class_map [639].handle = objc_getClass ("CoreImage_CIMaximumCompositing");
	__xamarin_class_map [640].handle = objc_getClass ("CoreImage_CIMedianFilter");
	__xamarin_class_map [641].handle = objc_getClass ("AVMutableMovie");
	__xamarin_class_map [642].handle = objc_getClass ("CoreImage_CIMinimumComponent");
	__xamarin_class_map [643].handle = objc_getClass ("NSURLAuthenticationChallenge");
	__xamarin_class_map [644].handle = objc_getClass ("NSCollectionViewTransitionLayout");
	__xamarin_class_map [645].handle = objc_getClass ("CoreImage_CIMinimumCompositing");
	__xamarin_class_map [646].handle = objc_getClass ("CoreImage_CIModTransition");
	__xamarin_class_map [647].handle = objc_getClass ("NSCollectionViewUpdateItem");
	__xamarin_class_map [648].handle = objc_getClass ("MTKSubmesh");
	__xamarin_class_map [649].handle = objc_getClass ("NSColorPickerTouchBarItem");
	__xamarin_class_map [650].handle = objc_getClass ("CoreImage_CIMorphology");
	__xamarin_class_map [651].handle = objc_getClass ("WebPreferences");
	__xamarin_class_map [652].handle = objc_getClass ("CoreImage_CIMorphologyGradient");
	__xamarin_class_map [653].handle = objc_getClass ("CoreImage_CIMorphologyMaximum");
	__xamarin_class_map [654].handle = objc_getClass ("WebResource");
	__xamarin_class_map [655].handle = objc_getClass ("NSColorSpace");
	__xamarin_class_map [656].handle = objc_getClass ("CoreImage_CIMorphologyMinimum");
	__xamarin_class_map [657].handle = objc_getClass ("AVMutableMovieTrack");
	__xamarin_class_map [658].handle = objc_getClass ("CoreImage_CIMotionBlur");
	__xamarin_class_map [659].handle = objc_getClass ("NSColorWell");
	__xamarin_class_map [660].handle = objc_getClass ("CoreImage_CIMultiplyBlendMode");
	__xamarin_class_map [661].handle = objc_getClass ("CoreImage_CIMultiplyCompositing");
	__xamarin_class_map [662].handle = objc_getClass ("NSURLComponents");
	__xamarin_class_map [663].handle = objc_getClass ("CoreImage_CINinePartStretched");
	__xamarin_class_map [664].handle = objc_getClass ("AVTimedMetadataGroup");
	__xamarin_class_map [665].handle = objc_getClass ("AVMutableTimedMetadataGroup");
	__xamarin_class_map [666].handle = objc_getClass ("CoreImage_CINinePartTiled");
	__xamarin_class_map [667].handle = objc_getClass ("CoreImage_CINoiseReduction");
	__xamarin_class_map [668].handle = objc_getClass ("CoreImage_CIOpTile");
	__xamarin_class_map [669].handle = objc_getClass ("CoreImage_CIOverlayBlendMode");
	__xamarin_class_map [670].handle = objc_getClass ("AVVideoComposition");
	__xamarin_class_map [671].handle = objc_getClass ("AVMutableVideoComposition");
	__xamarin_class_map [672].handle = objc_getClass ("CoreImage_CIPageCurlTransition");
	__xamarin_class_map [673].handle = objc_getClass ("CoreImage_CIPageCurlWithShadowTransition");
	__xamarin_class_map [674].handle = objc_getClass ("AVVideoCompositionInstruction");
	__xamarin_class_map [675].handle = objc_getClass ("AVMutableVideoCompositionInstruction");
	__xamarin_class_map [676].handle = objc_getClass ("CoreImage_CIParallelogramTile");
	__xamarin_class_map [677].handle = objc_getClass ("CoreImage_CIPdf417BarcodeGenerator");
	__xamarin_class_map [678].handle = objc_getClass ("AVVideoCompositionLayerInstruction");
	__xamarin_class_map [679].handle = objc_getClass ("AVMutableVideoCompositionLayerInstruction");
	__xamarin_class_map [680].handle = objc_getClass ("NSComboBoxCell");
	__xamarin_class_map [681].handle = objc_getClass ("CIPDF417CodeDescriptor");
	__xamarin_class_map [682].handle = objc_getClass ("MTKView");
	__xamarin_class_map [683].handle = objc_getClass ("CoreImage_CIPerspectiveTransform");
	__xamarin_class_map [684].handle = objc_getClass ("CoreImage_CIPerspectiveCorrection");
	__xamarin_class_map [685].handle = objc_getClass ("AVOutputSettingsAssistant");
	__xamarin_class_map [686].handle = objc_getClass ("CoreImage_CIPerspectiveTile");
	__xamarin_class_map [687].handle = objc_getClass ("NSColorList");
	__xamarin_class_map [688].handle = objc_getClass ("AVContentKeyRequest");
	__xamarin_class_map [689].handle = objc_getClass ("AVPersistableContentKeyRequest");
	__xamarin_class_map [690].handle = objc_getClass ("CoreImage_CIPerspectiveTransformWithExtent");
	__xamarin_class_map [691].handle = objc_getClass ("CoreImage_CIPhotoEffect");
	__xamarin_class_map [692].handle = objc_getClass ("NSURLCredential");
	__xamarin_class_map [693].handle = objc_getClass ("CoreImage_CIPhotoEffectChrome");
	__xamarin_class_map [694].handle = objc_getClass ("MPSBinaryImageKernel");
	__xamarin_class_map [695].handle = objc_getClass ("CoreImage_CIPhotoEffectFade");
	__xamarin_class_map [696].handle = objc_getClass ("CoreImage_CIPhotoEffectInstant");
	__xamarin_class_map [697].handle = objc_getClass ("CoreImage_CIPhotoEffectMono");
	__xamarin_class_map [698].handle = objc_getClass ("MPSNNFilterNode");
	__xamarin_class_map [699].handle = objc_getClass ("MPSCNNConvolutionNode");
	__xamarin_class_map [700].handle = objc_getClass ("MPSCNNBinaryConvolutionNode");
	__xamarin_class_map [701].handle = objc_getClass ("NSColorPicker");
	__xamarin_class_map [702].handle = objc_getClass ("CoreImage_CIPhotoEffectNoir");
	__xamarin_class_map [703].handle = objc_getClass ("CoreImage_CIPhotoEffectProcess");
	__xamarin_class_map [704].handle = objc_getClass ("CoreImage_CIPhotoEffectTonal");
	__xamarin_class_map [705].handle = objc_getClass ("MPSCNNBinaryFullyConnectedNode");
	__xamarin_class_map [706].handle = objc_getClass ("CoreImage_CIPhotoEffectTransfer");
	__xamarin_class_map [707].handle = objc_getClass ("CoreImage_CIPinchDistortion");
	__xamarin_class_map [708].handle = objc_getClass ("CoreImage_CIPinLightBlendMode");
	__xamarin_class_map [709].handle = objc_getClass ("CoreImage_CIPixellate");
	__xamarin_class_map [710].handle = objc_getClass ("CIPlugIn");
	__xamarin_class_map [711].handle = objc_getClass ("CoreImage_CIPointillize");
	__xamarin_class_map [712].handle = objc_getClass ("MPSCNNBinaryKernel");
	__xamarin_class_map [713].handle = objc_getClass ("CIQRCodeDescriptor");
	__xamarin_class_map [714].handle = objc_getClass ("NSURLProtectionSpace");
	__xamarin_class_map [715].handle = objc_getClass ("CIQRCodeFeature");
	__xamarin_class_map [716].handle = objc_getClass ("CoreImage_CIQRCodeGenerator");
	__xamarin_class_map [717].handle = objc_getClass ("MPSCNNConvolution");
	__xamarin_class_map [718].handle = objc_getClass ("NSURLProtocol");
	__xamarin_class_map [719].handle = objc_getClass ("CoreImage_CIRadialGradient");
	__xamarin_class_map [720].handle = objc_getClass ("NSURLQueryItem");
	__xamarin_class_map [721].handle = objc_getClass ("CoreImage_CIRandomGenerator");
	__xamarin_class_map [722].handle = objc_getClass ("NSDictionaryController");
	__xamarin_class_map [723].handle = objc_getClass ("AVPlayerItemAccessLog");
	__xamarin_class_map [724].handle = objc_getClass ("NSCursor");
	__xamarin_class_map [725].handle = objc_getClass ("NSDictionaryControllerKeyValuePair");
	__xamarin_class_map [726].handle = objc_getClass ("NSURLResponse");
	__xamarin_class_map [727].handle = objc_getClass ("NSCustomImageRep");
	__xamarin_class_map [728].handle = objc_getClass ("AVPlayerItemAccessLogEvent");
	__xamarin_class_map [729].handle = objc_getClass ("NSDockTile");
	__xamarin_class_map [730].handle = objc_getClass ("NSCustomTouchBarItem");
	__xamarin_class_map [731].handle = objc_getClass ("AVPlayerItemErrorLog");
	__xamarin_class_map [732].handle = objc_getClass ("CIRectangleFeature");
	__xamarin_class_map [733].handle = objc_getClass ("NSDataAsset");
	__xamarin_class_map [734].handle = objc_getClass ("MPSState");
	__xamarin_class_map [735].handle = objc_getClass ("MPSCNNConvolutionState");
	__xamarin_class_map [736].handle = objc_getClass ("WKBackForwardList");
	__xamarin_class_map [737].handle = objc_getClass ("MPSNNStateNode");
	__xamarin_class_map [738].handle = objc_getClass ("MPSCNNConvolutionStateNode");
	__xamarin_class_map [739].handle = objc_getClass ("AVPlayerItemErrorLogEvent");
	__xamarin_class_map [740].handle = objc_getClass ("WKBackForwardListItem");
	__xamarin_class_map [741].handle = objc_getClass ("CIRenderDestination");
	__xamarin_class_map [742].handle = objc_getClass ("MPSCNNConvolutionTranspose");
	__xamarin_class_map [743].handle = objc_getClass ("WKContentRuleList");
	__xamarin_class_map [744].handle = objc_getClass ("AVPlayerItemOutput");
	__xamarin_class_map [745].handle = objc_getClass ("AVPlayerItemLegibleOutput");
	__xamarin_class_map [746].handle = objc_getClass ("CIRenderInfo");
	__xamarin_class_map [747].handle = objc_getClass ("MPSCNNConvolutionTransposeNode");
	__xamarin_class_map [748].handle = objc_getClass ("CIRenderTask");
	__xamarin_class_map [749].handle = objc_getClass ("AVPlayerItemMediaDataCollector");
	__xamarin_class_map [750].handle = objc_getClass ("MPSCNNCrossChannelNormalization");
	__xamarin_class_map [751].handle = objc_getClass ("CoreImage_CIRippleTransition");
	__xamarin_class_map [752].handle = objc_getClass ("CoreImage_CIRowAverage");
	__xamarin_class_map [753].handle = objc_getClass ("MPSCNNNormalizationNode");
	__xamarin_class_map [754].handle = objc_getClass ("MPSCNNCrossChannelNormalizationNode");
	__xamarin_class_map [755].handle = objc_getClass ("AVPlayerItemMetadataCollector");
	__xamarin_class_map [756].handle = objc_getClass ("WKFrameInfo");
	__xamarin_class_map [757].handle = objc_getClass ("MPSCNNDepthWiseConvolutionDescriptor");
	__xamarin_class_map [758].handle = objc_getClass ("CoreImage_CISaturationBlendMode");
	__xamarin_class_map [759].handle = objc_getClass ("NSURLSessionConfiguration");
	__xamarin_class_map [760].handle = objc_getClass ("MPSCNNPooling");
	__xamarin_class_map [761].handle = objc_getClass ("MPSCNNDilatedPoolingMax");
	__xamarin_class_map [762].handle = objc_getClass ("CoreImage_CIScreenBlendMode");
	__xamarin_class_map [763].handle = objc_getClass ("MPSCNNDilatedPoolingMaxNode");
	__xamarin_class_map [764].handle = objc_getClass ("CoreImage_CISepiaTone");
	__xamarin_class_map [765].handle = objc_getClass ("CoreImage_CIShadedMaterial");
	__xamarin_class_map [766].handle = objc_getClass ("MPSCNNFullyConnected");
	__xamarin_class_map [767].handle = objc_getClass ("NSURLSessionTask");
	__xamarin_class_map [768].handle = objc_getClass ("NSURLSessionDataTask");
	__xamarin_class_map [769].handle = objc_getClass ("CoreImage_CISharpenLuminance");
	__xamarin_class_map [770].handle = objc_getClass ("WKNavigation");
	__xamarin_class_map [771].handle = objc_getClass ("AVPlayerItemMetadataOutput");
	__xamarin_class_map [772].handle = objc_getClass ("MPSCNNFullyConnectedNode");
	__xamarin_class_map [773].handle = objc_getClass ("CoreImage_CISixfoldReflectedTile");
	__xamarin_class_map [774].handle = objc_getClass ("CoreImage_CISixfoldRotatedTile");
	__xamarin_class_map [775].handle = objc_getClass ("CoreImage_CISmoothLinearGradient");
	__xamarin_class_map [776].handle = objc_getClass ("CoreImage_CISoftLightBlendMode");
	__xamarin_class_map [777].handle = objc_getClass ("CoreImage_CISourceAtopCompositing");
	__xamarin_class_map [778].handle = objc_getClass ("NSURLSessionDownloadTask");
	__xamarin_class_map [779].handle = objc_getClass ("CoreImage_CISourceInCompositing");
	__xamarin_class_map [780].handle = objc_getClass ("WKNavigationAction");
	__xamarin_class_map [781].handle = objc_getClass ("CoreImage_CISourceOutCompositing");
	__xamarin_class_map [782].handle = objc_getClass ("NSEPSImageRep");
	__xamarin_class_map [783].handle = objc_getClass ("MPSCNNLocalContrastNormalization");
	__xamarin_class_map [784].handle = objc_getClass ("CoreImage_CISourceOverCompositing");
	__xamarin_class_map [785].handle = objc_getClass ("CoreImage_CISpotColor");
	__xamarin_class_map [786].handle = objc_getClass ("MPSCNNLocalContrastNormalizationNode");
	__xamarin_class_map [787].handle = objc_getClass ("CoreImage_CISpotLight");
	__xamarin_class_map [788].handle = objc_getClass ("MPSCNNLogSoftMax");
	__xamarin_class_map [789].handle = objc_getClass ("CoreImage_CISRGBToneCurveToLinear");
	__xamarin_class_map [790].handle = objc_getClass ("MPSCNNLogSoftMaxNode");
	__xamarin_class_map [791].handle = objc_getClass ("WKNavigationResponse");
	__xamarin_class_map [792].handle = objc_getClass ("CoreImage_CIStarShineGenerator");
	__xamarin_class_map [793].handle = objc_getClass ("NSDocumentController");
	__xamarin_class_map [794].handle = objc_getClass ("AVPlayerItemTrack");
	__xamarin_class_map [795].handle = objc_getClass ("CoreImage_CIStraightenFilter");
	__xamarin_class_map [796].handle = objc_getClass ("MPSCNNNeuronAbsolute");
	__xamarin_class_map [797].handle = objc_getClass ("CoreImage_CIStretchCrop");
	__xamarin_class_map [798].handle = objc_getClass ("WKOpenPanelParameters");
	__xamarin_class_map [799].handle = objc_getClass ("MPSCNNNeuronNode");
	__xamarin_class_map [800].handle = objc_getClass ("MPSCNNNeuronAbsoluteNode");
	__xamarin_class_map [801].handle = objc_getClass ("CoreImage_CIStripesGenerator");
	__xamarin_class_map [802].handle = objc_getClass ("NSURLSessionTaskMetrics");
	__xamarin_class_map [803].handle = objc_getClass ("MPSCNNNeuronELU");
	__xamarin_class_map [804].handle = objc_getClass ("CoreImage_CISubtractBlendMode");
	__xamarin_class_map [805].handle = objc_getClass ("WKPreferences");
	__xamarin_class_map [806].handle = objc_getClass ("NSDraggingImageComponent");
	__xamarin_class_map [807].handle = objc_getClass ("MPSCNNNeuronELUNode");
	__xamarin_class_map [808].handle = objc_getClass ("CoreImage_CISunbeamsGenerator");
	__xamarin_class_map [809].handle = objc_getClass ("WKProcessPool");
	__xamarin_class_map [810].handle = objc_getClass ("MPSCNNNeuronHardSigmoid");
	__xamarin_class_map [811].handle = objc_getClass ("NSFilePromiseProvider");
	__xamarin_class_map [812].handle = objc_getClass ("AVPlayerLayer");
	__xamarin_class_map [813].handle = objc_getClass ("CoreImage_CISwipeTransition");
	__xamarin_class_map [814].handle = objc_getClass ("NSURLSessionTaskTransactionMetrics");
	__xamarin_class_map [815].handle = objc_getClass ("WKScriptMessage");
	__xamarin_class_map [816].handle = objc_getClass ("MPSCNNNeuronHardSigmoidNode");
	__xamarin_class_map [817].handle = objc_getClass ("CoreImage_CITemperatureAndTint");
	__xamarin_class_map [818].handle = objc_getClass ("NSURLSessionUploadTask");
	__xamarin_class_map [819].handle = objc_getClass ("AVPlayerLooper");
	__xamarin_class_map [820].handle = objc_getClass ("MPSCNNNeuronLinear");
	__xamarin_class_map [821].handle = objc_getClass ("WKSecurityOrigin");
	__xamarin_class_map [822].handle = objc_getClass ("CITextFeature");
	__xamarin_class_map [823].handle = objc_getClass ("NSFilePromiseReceiver");
	__xamarin_class_map [824].handle = objc_getClass ("MPSCNNNeuronLinearNode");
	__xamarin_class_map [825].handle = objc_getClass ("CoreImage_CITextImageGenerator");
	__xamarin_class_map [826].handle = objc_getClass ("AVPlayerMediaSelectionCriteria");
	__xamarin_class_map [827].handle = objc_getClass ("NSDraggingItem");
	__xamarin_class_map [828].handle = objc_getClass ("WKSnapshotConfiguration");
	__xamarin_class_map [829].handle = objc_getClass ("CoreImage_CIThermal");
	__xamarin_class_map [830].handle = objc_getClass ("NSDraggingSession");
	__xamarin_class_map [831].handle = objc_getClass ("MPSCNNNeuronPReLUNode");
	__xamarin_class_map [832].handle = objc_getClass ("CoreImage_CIToneCurve");
	__xamarin_class_map [833].handle = objc_getClass ("MPSCNNNeuronReLU");
	__xamarin_class_map [834].handle = objc_getClass ("CoreImage_CITorusLensDistortion");
	__xamarin_class_map [835].handle = objc_getClass ("MPSCNNNeuronReLUN");
	__xamarin_class_map [836].handle = objc_getClass ("AVPlayer");
	__xamarin_class_map [837].handle = objc_getClass ("AVQueuePlayer");
	__xamarin_class_map [838].handle = objc_getClass ("MPSCNNNeuronReLUNNode");
	__xamarin_class_map [839].handle = objc_getClass ("CoreImage_CITriangleKaleidoscope");
	__xamarin_class_map [840].handle = objc_getClass ("CoreImage_CITriangleTile");
	__xamarin_class_map [841].handle = objc_getClass ("MPSCNNNeuronReLUNode");
	__xamarin_class_map [842].handle = objc_getClass ("WKUserContentController");
	__xamarin_class_map [843].handle = objc_getClass ("CoreImage_CITwelvefoldReflectedTile");
	__xamarin_class_map [844].handle = objc_getClass ("MPSCNNNeuronSigmoid");
	__xamarin_class_map [845].handle = objc_getClass ("CoreImage_CITwirlDistortion");
	__xamarin_class_map [846].handle = objc_getClass ("WKUserScript");
	__xamarin_class_map [847].handle = objc_getClass ("MPSCNNNeuronSigmoidNode");
	__xamarin_class_map [848].handle = objc_getClass ("CoreImage_CIUnsharpMask");
	__xamarin_class_map [849].handle = objc_getClass ("MPSCNNNeuronSoftPlus");
	__xamarin_class_map [850].handle = objc_getClass ("NSFontAssetRequest");
	__xamarin_class_map [851].handle = objc_getClass ("WKWebsiteDataRecord");
	__xamarin_class_map [852].handle = objc_getClass ("MPSCNNNeuronSoftPlusNode");
	__xamarin_class_map [853].handle = objc_getClass ("MPSCNNNeuronSoftSign");
	__xamarin_class_map [854].handle = objc_getClass ("MPSCNNNeuronSoftSignNode");
	__xamarin_class_map [855].handle = objc_getClass ("CoreImage_CIVibrance");
	__xamarin_class_map [856].handle = objc_getClass ("MPSCNNNeuronTanH");
	__xamarin_class_map [857].handle = objc_getClass ("CoreImage_CIVignette");
	__xamarin_class_map [858].handle = objc_getClass ("MPSCNNNeuronTanHNode");
	__xamarin_class_map [859].handle = objc_getClass ("CoreImage_CIVignetteEffect");
	__xamarin_class_map [860].handle = objc_getClass ("AVSampleBufferRequest");
	__xamarin_class_map [861].handle = objc_getClass ("CoreImage_CIVortexDistortion");
	__xamarin_class_map [862].handle = objc_getClass ("NSUserNotification");
	__xamarin_class_map [863].handle = objc_getClass ("NSUserNotificationAction");
	__xamarin_class_map [864].handle = objc_getClass ("CIWarpKernel");
	__xamarin_class_map [865].handle = objc_getClass ("NSFontDescriptor");
	__xamarin_class_map [866].handle = objc_getClass ("CoreImage_CIWhitePointAdjust");
	__xamarin_class_map [867].handle = objc_getClass ("CoreImage_CIXRay");
	__xamarin_class_map [868].handle = objc_getClass ("PDFAction");
	__xamarin_class_map [869].handle = objc_getClass ("CoreImage_CIZoomBlur");
	__xamarin_class_map [870].handle = objc_getClass ("WKWebViewConfiguration");
	__xamarin_class_map [871].handle = objc_getClass ("MPSCNNPoolingAverage");
	__xamarin_class_map [872].handle = objc_getClass ("PDFActionGoTo");
	__xamarin_class_map [873].handle = objc_getClass ("AVSampleCursor");
	__xamarin_class_map [874].handle = objc_getClass ("CLRegion");
	__xamarin_class_map [875].handle = objc_getClass ("CLCircularRegion");
	__xamarin_class_map [876].handle = objc_getClass ("WKWindowFeatures");
	__xamarin_class_map [877].handle = objc_getClass ("MPSCNNPoolingNode");
	__xamarin_class_map [878].handle = objc_getClass ("MPSCNNPoolingAverageNode");
	__xamarin_class_map [879].handle = objc_getClass ("PDFActionNamed");
	__xamarin_class_map [880].handle = objc_getClass ("NSFontManager");
	__xamarin_class_map [881].handle = objc_getClass ("MPSCNNPoolingL2Norm");
	__xamarin_class_map [882].handle = objc_getClass ("NSUUID");
	__xamarin_class_map [883].handle = objc_getClass ("NSFontPanel");
	__xamarin_class_map [884].handle = objc_getClass ("PDFActionRemoteGoTo");
	__xamarin_class_map [885].handle = objc_getClass ("MPSCNNPoolingL2NormNode");
	__xamarin_class_map [886].handle = objc_getClass ("AVAssetImageGenerator");
	__xamarin_class_map [887].handle = objc_getClass ("AVAssetReaderOutput");
	__xamarin_class_map [888].handle = objc_getClass ("AVAssetReaderVideoCompositionOutput");
	__xamarin_class_map [889].handle = objc_getClass ("AVSynchronizedLayer");
	__xamarin_class_map [890].handle = objc_getClass ("PDFActionResetForm");
	__xamarin_class_map [891].handle = objc_getClass ("MPSCNNPoolingMax");
	__xamarin_class_map [892].handle = objc_getClass ("AVAssetResourceLoadingDataRequest");
	__xamarin_class_map [893].handle = objc_getClass ("PDFActionURL");
	__xamarin_class_map [894].handle = objc_getClass ("AVAudioBuffer");
	__xamarin_class_map [895].handle = objc_getClass ("MPSCNNPoolingMaxNode");
	__xamarin_class_map [896].handle = objc_getClass ("AVTextStyleRule");
	__xamarin_class_map [897].handle = objc_getClass ("AVAudioChannelLayout");
	__xamarin_class_map [898].handle = objc_getClass ("NSMatrix");
	__xamarin_class_map [899].handle = objc_getClass ("NSForm");
	__xamarin_class_map [900].handle = objc_getClass ("AVAudioFormat");
	__xamarin_class_map [901].handle = objc_getClass ("NSValueTransformer");
	__xamarin_class_map [902].handle = objc_getClass ("MPSCNNSoftMax");
	__xamarin_class_map [903].handle = objc_getClass ("AVAudioPlayer");
	__xamarin_class_map [904].handle = objc_getClass ("NSXPCListenerEndpoint");
	__xamarin_class_map [905].handle = objc_getClass ("MPSCNNSoftMaxNode");
	__xamarin_class_map [906].handle = objc_getClass ("NSFormCell");
	__xamarin_class_map [907].handle = objc_getClass ("AVAudioRecorder");
	__xamarin_class_map [908].handle = objc_getClass ("MPSCNNSpatialNormalization");
	__xamarin_class_map [909].handle = objc_getClass ("MPSCNNSpatialNormalizationNode");
	__xamarin_class_map [910].handle = objc_getClass ("GCControllerElement");
	__xamarin_class_map [911].handle = objc_getClass ("GCControllerAxisInput");
	__xamarin_class_map [912].handle = objc_getClass ("PDFAnnotation");
	__xamarin_class_map [913].handle = objc_getClass ("MPSCNNSubPixelConvolutionDescriptor");
	__xamarin_class_map [914].handle = objc_getClass ("MPSCNNUpsampling");
	__xamarin_class_map [915].handle = objc_getClass ("GCControllerButtonInput");
	__xamarin_class_map [916].handle = objc_getClass ("PDFAnnotationButtonWidget");
	__xamarin_class_map [917].handle = objc_getClass ("MPSCNNUpsamplingBilinear");
	__xamarin_class_map [918].handle = objc_getClass ("GCControllerDirectionPad");
	__xamarin_class_map [919].handle = objc_getClass ("MPSCNNUpsamplingBilinearNode");
	__xamarin_class_map [920].handle = objc_getClass ("PDFAnnotationChoiceWidget");
	__xamarin_class_map [921].handle = objc_getClass ("MPSCNNUpsamplingNearest");
	__xamarin_class_map [922].handle = objc_getClass ("PDFAnnotationCircle");
	__xamarin_class_map [923].handle = objc_getClass ("MPSCNNUpsamplingNearestNode");
	__xamarin_class_map [924].handle = objc_getClass ("NSImageCell");
	__xamarin_class_map [925].handle = objc_getClass ("NSGlyphGenerator");
	__xamarin_class_map [926].handle = objc_getClass ("PDFAnnotationFreeText");
	__xamarin_class_map [927].handle = objc_getClass ("CLPlacemark");
	__xamarin_class_map [928].handle = objc_getClass ("MPSRNNDescriptor");
	__xamarin_class_map [929].handle = objc_getClass ("MPSGRUDescriptor");
	__xamarin_class_map [930].handle = objc_getClass ("NSGlyphInfo");
	__xamarin_class_map [931].handle = objc_getClass ("PDFAnnotationInk");
	__xamarin_class_map [932].handle = objc_getClass ("AVVideoCompositionCoreAnimationTool");
	__xamarin_class_map [933].handle = objc_getClass ("AVAudioConnectionPoint");
	__xamarin_class_map [934].handle = objc_getClass ("GCMotion");
	__xamarin_class_map [935].handle = objc_getClass ("NSGradient");
	__xamarin_class_map [936].handle = objc_getClass ("MPSImage");
	__xamarin_class_map [937].handle = objc_getClass ("MPSImageArithmetic");
	__xamarin_class_map [938].handle = objc_getClass ("MPSImageAdd");
	__xamarin_class_map [939].handle = objc_getClass ("PDFAnnotationLine");
	__xamarin_class_map [940].handle = objc_getClass ("NSGraphicsContext");
	__xamarin_class_map [941].handle = objc_getClass ("MPSImageAreaMax");
	__xamarin_class_map [942].handle = objc_getClass ("AVVideoCompositionRenderContext");
	__xamarin_class_map [943].handle = objc_getClass ("MPSImageAreaMin");
	__xamarin_class_map [944].handle = objc_getClass ("PDFAnnotationLink");
	__xamarin_class_map [945].handle = objc_getClass ("GKChallenge");
	__xamarin_class_map [946].handle = objc_getClass ("GKAchievementChallenge");
	__xamarin_class_map [947].handle = objc_getClass ("NSGridCell");
	__xamarin_class_map [948].handle = objc_getClass ("PDFAnnotationMarkup");
	__xamarin_class_map [949].handle = objc_getClass ("MPSImageScale");
	__xamarin_class_map [950].handle = objc_getClass ("MPSImageBilinearScale");
	__xamarin_class_map [951].handle = objc_getClass ("NSGridColumn");
	__xamarin_class_map [952].handle = objc_getClass ("PDFAnnotationPopup");
	__xamarin_class_map [953].handle = objc_getClass ("MPSImageBox");
	__xamarin_class_map [954].handle = objc_getClass ("PDFAnnotationSquare");
	__xamarin_class_map [955].handle = objc_getClass ("NSGridRow");
	__xamarin_class_map [956].handle = objc_getClass ("GKBasePlayer");
	__xamarin_class_map [957].handle = objc_getClass ("MPSImageConversion");
	__xamarin_class_map [958].handle = objc_getClass ("PDFAnnotationStamp");
	__xamarin_class_map [959].handle = objc_getClass ("MLDictionaryConstraint");
	__xamarin_class_map [960].handle = objc_getClass ("MPSImageConvolution");
	__xamarin_class_map [961].handle = objc_getClass ("MLDictionaryFeatureProvider");
	__xamarin_class_map [962].handle = objc_getClass ("MPSImageCopyToMatrix");
	__xamarin_class_map [963].handle = objc_getClass ("MLFeatureDescription");
	__xamarin_class_map [964].handle = objc_getClass ("NSGridView");
	__xamarin_class_map [965].handle = objc_getClass ("PDFAnnotationText");
	__xamarin_class_map [966].handle = objc_getClass ("AVFoundation_InternalAVAudioPlayerDelegate");
	__xamarin_class_map [967].handle = objc_getClass ("AVFoundation_InternalAVAudioRecorderDelegate");
	__xamarin_class_map [968].handle = objc_getClass ("NSGroupTouchBarItem");
	__xamarin_class_map [969].handle = objc_getClass ("NSImageView");
	__xamarin_class_map [970].handle = objc_getClass ("MPSImageDescriptor");
	__xamarin_class_map [971].handle = objc_getClass ("NSHapticFeedbackManager");
	__xamarin_class_map [972].handle = objc_getClass ("GKCloudPlayer");
	__xamarin_class_map [973].handle = objc_getClass ("PDFAnnotationTextWidget");
	__xamarin_class_map [974].handle = objc_getClass ("MLFeatureValue");
	__xamarin_class_map [975].handle = objc_getClass ("MPSImageDilate");
	__xamarin_class_map [976].handle = objc_getClass ("MLImageConstraint");
	__xamarin_class_map [977].handle = objc_getClass ("GKDialogController");
	__xamarin_class_map [978].handle = objc_getClass ("MPSImageDivide");
	__xamarin_class_map [979].handle = objc_getClass ("CBUUID");
	__xamarin_class_map [980].handle = objc_getClass ("MLModel");
	__xamarin_class_map [981].handle = objc_getClass ("MPSImageErode");
	__xamarin_class_map [982].handle = objc_getClass ("NSLayoutAnchor");
	__xamarin_class_map [983].handle = objc_getClass ("PDFAppearanceCharacteristics");
	__xamarin_class_map [984].handle = objc_getClass ("MLModelDescription");
	__xamarin_class_map [985].handle = objc_getClass ("MPSImageFindKeypoints");
	__xamarin_class_map [986].handle = objc_getClass ("MPSImageGaussianBlur");
	__xamarin_class_map [987].handle = objc_getClass ("PDFBorder");
	__xamarin_class_map [988].handle = objc_getClass ("MPSImagePyramid");
	__xamarin_class_map [989].handle = objc_getClass ("MPSImageGaussianPyramid");
	__xamarin_class_map [990].handle = objc_getClass ("NSLayoutConstraint");
	__xamarin_class_map [991].handle = objc_getClass ("MPSImageHistogram");
	__xamarin_class_map [992].handle = objc_getClass ("MLMultiArray");
	__xamarin_class_map [993].handle = objc_getClass ("PDFDestination");
	__xamarin_class_map [994].handle = objc_getClass ("MLMultiArrayConstraint");
	__xamarin_class_map [995].handle = objc_getClass ("MPSImageHistogramEqualization");
	__xamarin_class_map [996].handle = objc_getClass ("NSLayoutDimension");
	__xamarin_class_map [997].handle = objc_getClass ("MPSImageHistogramSpecification");
	__xamarin_class_map [998].handle = objc_getClass ("MLPredictionOptions");
	__xamarin_class_map [999].handle = objc_getClass ("MPSImageIntegral");
	__xamarin_class_map [1000].handle = objc_getClass ("NSLayoutGuide");
	__xamarin_class_map [1001].handle = objc_getClass ("MPSImageIntegralOfSquares");
	__xamarin_class_map [1002].handle = objc_getClass ("NSLevelIndicatorCell");
	__xamarin_class_map [1003].handle = objc_getClass ("MPSImageLaplacian");
	__xamarin_class_map [1004].handle = objc_getClass ("MPSImageMedian");
	__xamarin_class_map [1005].handle = objc_getClass ("GKInvite");
	__xamarin_class_map [1006].handle = objc_getClass ("MPSImageMultiply");
	__xamarin_class_map [1007].handle = objc_getClass ("AVCaptureView");
	__xamarin_class_map [1008].handle = objc_getClass ("MPSImageSobel");
	__xamarin_class_map [1009].handle = objc_getClass ("NSLayoutManager");
	__xamarin_class_map [1010].handle = objc_getClass ("MPSImageStatisticsMean");
	__xamarin_class_map [1011].handle = objc_getClass ("MPSImageStatisticsMeanAndVariance");
	__xamarin_class_map [1012].handle = objc_getClass ("AVPlayerView");
	__xamarin_class_map [1013].handle = objc_getClass ("MPSImageStatisticsMinAndMax");
	__xamarin_class_map [1014].handle = objc_getClass ("MPSImageSubtract");
	__xamarin_class_map [1015].handle = objc_getClass ("PDFOutline");
	__xamarin_class_map [1016].handle = objc_getClass ("NSLayoutXAxisAnchor");
	__xamarin_class_map [1017].handle = objc_getClass ("MPSImageTent");
	__xamarin_class_map [1018].handle = objc_getClass ("CKOperation");
	__xamarin_class_map [1019].handle = objc_getClass ("CKAcceptSharesOperation");
	__xamarin_class_map [1020].handle = objc_getClass ("NSLayoutYAxisAnchor");
	__xamarin_class_map [1021].handle = objc_getClass ("MPSImageThresholdBinary");
	__xamarin_class_map [1022].handle = objc_getClass ("PDFPage");
	__xamarin_class_map [1023].handle = objc_getClass ("MPSImageThresholdBinaryInverse");
	__xamarin_class_map [1024].handle = objc_getClass ("MPSImageThresholdToZero");
	__xamarin_class_map [1025].handle = objc_getClass ("CKAsset");
	__xamarin_class_map [1026].handle = objc_getClass ("NSLevelIndicator");
	__xamarin_class_map [1027].handle = objc_getClass ("CW8021XProfile");
	__xamarin_class_map [1028].handle = objc_getClass ("MPSImageThresholdToZeroInverse");
	__xamarin_class_map [1029].handle = objc_getClass ("CWChannel");
	__xamarin_class_map [1030].handle = objc_getClass ("MPSImageThresholdTruncate");
	__xamarin_class_map [1031].handle = objc_getClass ("PDFSelection");
	__xamarin_class_map [1032].handle = objc_getClass ("MPSImageTranspose");
	__xamarin_class_map [1033].handle = objc_getClass ("NSOpenGLContext");
	__xamarin_class_map [1034].handle = objc_getClass ("CAOpenGLLayer");
	__xamarin_class_map [1035].handle = objc_getClass ("NSOpenGLLayer");
	__xamarin_class_map [1036].handle = objc_getClass ("NSOpenGLPixelBuffer");
	__xamarin_class_map [1037].handle = objc_getClass ("NSOpenGLPixelFormat");
	__xamarin_class_map [1038].handle = objc_getClass ("MPSLSTMDescriptor");
	__xamarin_class_map [1039].handle = objc_getClass ("NSOpenGLView");
	__xamarin_class_map [1040].handle = objc_getClass ("CKNotification");
	__xamarin_class_map [1041].handle = objc_getClass ("CKDatabaseNotification");
	__xamarin_class_map [1042].handle = objc_getClass ("MPSMatrix");
	__xamarin_class_map [1043].handle = objc_getClass ("CKDatabaseOperation");
	__xamarin_class_map [1044].handle = objc_getClass ("NSSavePanel");
	__xamarin_class_map [1045].handle = objc_getClass ("NSOpenPanel");
	__xamarin_class_map [1046].handle = objc_getClass ("MPSMatrixBinaryKernel");
	__xamarin_class_map [1047].handle = objc_getClass ("CWMutableConfiguration");
	__xamarin_class_map [1048].handle = objc_getClass ("CKSubscription");
	__xamarin_class_map [1049].handle = objc_getClass ("CKDatabaseSubscription");
	__xamarin_class_map [1050].handle = objc_getClass ("MPSMatrixCopy");
	__xamarin_class_map [1051].handle = objc_getClass ("CWNetworkProfile");
	__xamarin_class_map [1052].handle = objc_getClass ("CWMutableNetworkProfile");
	__xamarin_class_map [1053].handle = objc_getClass ("CKDiscoverAllContactsOperation");
	__xamarin_class_map [1054].handle = objc_getClass ("MPSMatrixCopyDescriptor");
	__xamarin_class_map [1055].handle = objc_getClass ("MPSMatrixUnaryKernel");
	__xamarin_class_map [1056].handle = objc_getClass ("MPSMatrixDecompositionCholesky");
	__xamarin_class_map [1057].handle = objc_getClass ("CKDiscoverAllUserIdentitiesOperation");
	__xamarin_class_map [1058].handle = objc_getClass ("CWNetwork");
	__xamarin_class_map [1059].handle = objc_getClass ("GKMatchRequest");
	__xamarin_class_map [1060].handle = objc_getClass ("MPSMatrixDecompositionLU");
	__xamarin_class_map [1061].handle = objc_getClass ("CKDiscoveredUserInfo");
	__xamarin_class_map [1062].handle = objc_getClass ("MPSMatrixDescriptor");
	__xamarin_class_map [1063].handle = objc_getClass ("CKDiscoverUserIdentitiesOperation");
	__xamarin_class_map [1064].handle = objc_getClass ("CWWiFiClient");
	__xamarin_class_map [1065].handle = objc_getClass ("CKDiscoverUserInfosOperation");
	__xamarin_class_map [1066].handle = objc_getClass ("NSAppleEventDescriptor");
	__xamarin_class_map [1067].handle = objc_getClass ("MPSMatrixFindTopK");
	__xamarin_class_map [1068].handle = objc_getClass ("CWWirelessProfile");
	__xamarin_class_map [1069].handle = objc_getClass ("MPSMatrixFullyConnected");
	__xamarin_class_map [1070].handle = objc_getClass ("NSArray");
	__xamarin_class_map [1071].handle = objc_getClass ("MPSMatrixSoftMax");
	__xamarin_class_map [1072].handle = objc_getClass ("MPSMatrixLogSoftMax");
	__xamarin_class_map [1073].handle = objc_getClass ("CKFetchDatabaseChangesOperation");
	__xamarin_class_map [1074].handle = objc_getClass ("NSAttributedString");
	__xamarin_class_map [1075].handle = objc_getClass ("CKFetchNotificationChangesOperation");
	__xamarin_class_map [1076].handle = objc_getClass ("EKCalendar");
	__xamarin_class_map [1077].handle = objc_getClass ("MPSMatrixMultiplication");
	__xamarin_class_map [1078].handle = objc_getClass ("CKFetchRecordChangesOperation");
	__xamarin_class_map [1079].handle = objc_getClass ("NSBundle");
	__xamarin_class_map [1080].handle = objc_getClass ("MPSMatrixNeuron");
	__xamarin_class_map [1081].handle = objc_getClass ("CKFetchRecordsOperation");
	__xamarin_class_map [1082].handle = objc_getClass ("GKScoreChallenge");
	__xamarin_class_map [1083].handle = objc_getClass ("CKFetchRecordZoneChangesOperation");
	__xamarin_class_map [1084].handle = objc_getClass ("NSCoder");
	__xamarin_class_map [1085].handle = objc_getClass ("MPSMatrixSolveCholesky");
	__xamarin_class_map [1086].handle = objc_getClass ("NSConnection");
	__xamarin_class_map [1087].handle = objc_getClass ("CKFetchRecordZoneChangesOptions");
	__xamarin_class_map [1088].handle = objc_getClass ("MPSMatrixSolveLU");
	__xamarin_class_map [1089].handle = objc_getClass ("GKTurnBasedEventHandler");
	__xamarin_class_map [1090].handle = objc_getClass ("CKFetchRecordZonesOperation");
	__xamarin_class_map [1091].handle = objc_getClass ("MPSMatrixSolveTriangular");
	__xamarin_class_map [1092].handle = objc_getClass ("NSDate");
	__xamarin_class_map [1093].handle = objc_getClass ("CKFetchShareMetadataOperation");
	__xamarin_class_map [1094].handle = objc_getClass ("MPSMatrixSum");
	__xamarin_class_map [1095].handle = objc_getClass ("NSPageLayout");
	__xamarin_class_map [1096].handle = objc_getClass ("CKFetchShareParticipantsOperation");
	__xamarin_class_map [1097].handle = objc_getClass ("NSEnumerator");
	__xamarin_class_map [1098].handle = objc_getClass ("NSDirectoryEnumerator");
	__xamarin_class_map [1099].handle = objc_getClass ("CKFetchSubscriptionsOperation");
	__xamarin_class_map [1100].handle = objc_getClass ("MPSMatrixVectorMultiplication");
	__xamarin_class_map [1101].handle = objc_getClass ("CKFetchWebAuthTokenOperation");
	__xamarin_class_map [1102].handle = objc_getClass ("MPSNNBinaryArithmeticNode");
	__xamarin_class_map [1103].handle = objc_getClass ("MPSNNAdditionNode");
	__xamarin_class_map [1104].handle = objc_getClass ("CKLocationSortDescriptor");
	__xamarin_class_map [1105].handle = objc_getClass ("NSExpression");
	__xamarin_class_map [1106].handle = objc_getClass ("GKTurnBasedExchangeReply");
	__xamarin_class_map [1107].handle = objc_getClass ("MPSNNScaleNode");
	__xamarin_class_map [1108].handle = objc_getClass ("MPSNNBilinearScaleNode");
	__xamarin_class_map [1109].handle = objc_getClass ("NSParagraphStyle");
	__xamarin_class_map [1110].handle = objc_getClass ("CKMarkNotificationsReadOperation");
	__xamarin_class_map [1111].handle = objc_getClass ("MPSNNConcatenationNode");
	__xamarin_class_map [1112].handle = objc_getClass ("CKModifyBadgeOperation");
	__xamarin_class_map [1113].handle = objc_getClass ("EKParticipant");
	__xamarin_class_map [1114].handle = objc_getClass ("MPSNNDefaultPadding");
	__xamarin_class_map [1115].handle = objc_getClass ("MPSNNDivisionNode");
	__xamarin_class_map [1116].handle = objc_getClass ("CKModifyRecordsOperation");
	__xamarin_class_map [1117].handle = objc_getClass ("EKRecurrenceEnd");
	__xamarin_class_map [1118].handle = objc_getClass ("CKModifyRecordZonesOperation");
	__xamarin_class_map [1119].handle = objc_getClass ("NSHTTPCookie");
	__xamarin_class_map [1120].handle = objc_getClass ("NSPasteboard");
	__xamarin_class_map [1121].handle = objc_getClass ("CKModifySubscriptionsOperation");
	__xamarin_class_map [1122].handle = objc_getClass ("GKTurnBasedMatchmakerViewController");
	__xamarin_class_map [1123].handle = objc_getClass ("NSIndexPath");
	__xamarin_class_map [1124].handle = objc_getClass ("MPSNNImageNode");
	__xamarin_class_map [1125].handle = objc_getClass ("NSPasteboardItem");
	__xamarin_class_map [1126].handle = objc_getClass ("MPSNNLanczosScaleNode");
	__xamarin_class_map [1127].handle = objc_getClass ("EKReminder");
	__xamarin_class_map [1128].handle = objc_getClass ("NSInputStream");
	__xamarin_class_map [1129].handle = objc_getClass ("MPSNNMultiplicationNode");
	__xamarin_class_map [1130].handle = objc_getClass ("CKNotificationID");
	__xamarin_class_map [1131].handle = objc_getClass ("NSJSONSerialization");
	__xamarin_class_map [1132].handle = objc_getClass ("EKSource");
	__xamarin_class_map [1133].handle = objc_getClass ("NSMenuItemCell");
	__xamarin_class_map [1134].handle = objc_getClass ("GKTurnBasedParticipant");
	__xamarin_class_map [1135].handle = objc_getClass ("MPSNNSubtractionNode");
	__xamarin_class_map [1136].handle = objc_getClass ("CKNotificationInfo");
	__xamarin_class_map [1137].handle = objc_getClass ("EKStructuredLocation");
	__xamarin_class_map [1138].handle = objc_getClass ("NSMenuView");
	__xamarin_class_map [1139].handle = objc_getClass ("GKVoiceChat");
	__xamarin_class_map [1140].handle = objc_getClass ("GKComponent");
	__xamarin_class_map [1141].handle = objc_getClass ("GKAgent");
	__xamarin_class_map [1142].handle = objc_getClass ("GKAgent2D");
	__xamarin_class_map [1143].handle = objc_getClass ("NSFontCollection");
	__xamarin_class_map [1144].handle = objc_getClass ("NSMutableFontCollection");
	__xamarin_class_map [1145].handle = objc_getClass ("NSMetadataItem");
	__xamarin_class_map [1146].handle = objc_getClass ("MPSRNNImageInferenceLayer");
	__xamarin_class_map [1147].handle = objc_getClass ("NSMutableArray");
	__xamarin_class_map [1148].handle = objc_getClass ("CKOperationConfiguration");
	__xamarin_class_map [1149].handle = objc_getClass ("GKAgent3D");
	__xamarin_class_map [1150].handle = objc_getClass ("MPSRNNMatrixInferenceLayer");
	__xamarin_class_map [1151].handle = objc_getClass ("CKOperationGroup");
	__xamarin_class_map [1152].handle = objc_getClass ("NSMutableAttributedString");
	__xamarin_class_map [1153].handle = objc_getClass ("MPSRNNRecurrentImageState");
	__xamarin_class_map [1154].handle = objc_getClass ("NSMutableParagraphStyle");
	__xamarin_class_map [1155].handle = objc_getClass ("GKRandomSource");
	__xamarin_class_map [1156].handle = objc_getClass ("GKARC4RandomSource");
	__xamarin_class_map [1157].handle = objc_getClass ("MPSRNNRecurrentMatrixState");
	__xamarin_class_map [1158].handle = objc_getClass ("NSNib");
	__xamarin_class_map [1159].handle = objc_getClass ("NSPathControlItem");
	__xamarin_class_map [1160].handle = objc_getClass ("CKQuery");
	__xamarin_class_map [1161].handle = objc_getClass ("MPSRNNSingleGateDescriptor");
	__xamarin_class_map [1162].handle = objc_getClass ("NSPDFImageRep");
	__xamarin_class_map [1163].handle = objc_getClass ("GKNoiseSource");
	__xamarin_class_map [1164].handle = objc_getClass ("GKCoherentNoiseSource");
	__xamarin_class_map [1165].handle = objc_getClass ("GKBillowNoiseSource");
	__xamarin_class_map [1166].handle = objc_getClass ("CKQueryCursor");
	__xamarin_class_map [1167].handle = objc_getClass ("GKCheckerboardNoiseSource");
	__xamarin_class_map [1168].handle = objc_getClass ("CKQueryNotification");
	__xamarin_class_map [1169].handle = objc_getClass ("MPSTemporaryImage");
	__xamarin_class_map [1170].handle = objc_getClass ("GKCircleObstacle");
	__xamarin_class_map [1171].handle = objc_getClass ("MPSTemporaryMatrix");
	__xamarin_class_map [1172].handle = objc_getClass ("MPSVector");
	__xamarin_class_map [1173].handle = objc_getClass ("MPSTemporaryVector");
	__xamarin_class_map [1174].handle = objc_getClass ("CKQueryOperation");
	__xamarin_class_map [1175].handle = objc_getClass ("NSAffineTransform");
	__xamarin_class_map [1176].handle = objc_getClass ("CKQuerySubscription");
	__xamarin_class_map [1177].handle = objc_getClass ("NSRuleEditor");
	__xamarin_class_map [1178].handle = objc_getClass ("NSPredicateEditor");
	__xamarin_class_map [1179].handle = objc_getClass ("Foundation_InternalNSNotificationHandler");
	__xamarin_class_map [1180].handle = objc_getClass ("MPSVectorDescriptor");
	__xamarin_class_map [1181].handle = objc_getClass ("CKRecord");
	__xamarin_class_map [1182].handle = objc_getClass ("GKConstantNoiseSource");
	__xamarin_class_map [1183].handle = objc_getClass ("NSPredicateEditorRowTemplate");
	__xamarin_class_map [1184].handle = objc_getClass ("NSAppleEventManager");
	__xamarin_class_map [1185].handle = objc_getClass ("GKCylindersNoiseSource");
	__xamarin_class_map [1186].handle = objc_getClass ("NSExtensionContext");
	__xamarin_class_map [1187].handle = objc_getClass ("CKRecordID");
	__xamarin_class_map [1188].handle = objc_getClass ("GKDecisionNode");
	__xamarin_class_map [1189].handle = objc_getClass ("NSAppleScript");
	__xamarin_class_map [1190].handle = objc_getClass ("NSPressureConfiguration");
	__xamarin_class_map [1191].handle = objc_getClass ("CKRecordZone");
	__xamarin_class_map [1192].handle = objc_getClass ("NSProxy");
	__xamarin_class_map [1193].handle = objc_getClass ("GKDecisionTree");
	__xamarin_class_map [1194].handle = objc_getClass ("NSPrinter");
	__xamarin_class_map [1195].handle = objc_getClass ("CKRecordZoneNotification");
	__xamarin_class_map [1196].handle = objc_getClass ("CKRecordZoneSubscription");
	__xamarin_class_map [1197].handle = objc_getClass ("NSPrintInfo");
	__xamarin_class_map [1198].handle = objc_getClass ("CKReference");
	__xamarin_class_map [1199].handle = objc_getClass ("CKServerChangeToken");
	__xamarin_class_map [1200].handle = objc_getClass ("GKRandomDistribution");
	__xamarin_class_map [1201].handle = objc_getClass ("GKGaussianDistribution");
	__xamarin_class_map [1202].handle = objc_getClass ("NSPrintOperation");
	__xamarin_class_map [1203].handle = objc_getClass ("NSBlockOperation");
	__xamarin_class_map [1204].handle = objc_getClass ("CKShare");
	__xamarin_class_map [1205].handle = objc_getClass ("NSPrintPanel");
	__xamarin_class_map [1206].handle = objc_getClass ("GKGoal");
	__xamarin_class_map [1207].handle = objc_getClass ("NSPrintPreviewGraphicsContext");
	__xamarin_class_map [1208].handle = objc_getClass ("CKShareMetadata");
	__xamarin_class_map [1209].handle = objc_getClass ("GKGraphNode");
	__xamarin_class_map [1210].handle = objc_getClass ("CKShareParticipant");
	__xamarin_class_map [1211].handle = objc_getClass ("GKGraphNode2D");
	__xamarin_class_map [1212].handle = objc_getClass ("NSProgressIndicator");
	__xamarin_class_map [1213].handle = objc_getClass ("GKGraphNode3D");
	__xamarin_class_map [1214].handle = objc_getClass ("NSRemoteOpenPanel");
	__xamarin_class_map [1215].handle = objc_getClass ("NSRemoteSavePanel");
	__xamarin_class_map [1216].handle = objc_getClass ("NSByteCountFormatter");
	__xamarin_class_map [1217].handle = objc_getClass ("GKGridGraphNode");
	__xamarin_class_map [1218].handle = objc_getClass ("GKLinearCongruentialRandomSource");
	__xamarin_class_map [1219].handle = objc_getClass ("GKMersenneTwisterRandomSource");
	__xamarin_class_map [1220].handle = objc_getClass ("CKUserIdentity");
	__xamarin_class_map [1221].handle = objc_getClass ("GKMeshGraph");
	__xamarin_class_map [1222].handle = objc_getClass ("NSCachedURLResponse");
	__xamarin_class_map [1223].handle = objc_getClass ("NSPopoverTouchBarItem");
	__xamarin_class_map [1224].handle = objc_getClass ("Foundation_NSUrlProtocolClient");
	__xamarin_class_map [1225].handle = objc_getClass ("MDLAnimationBindComponent");
	__xamarin_class_map [1226].handle = objc_getClass ("GKMinmaxStrategist");
	__xamarin_class_map [1227].handle = objc_getClass ("MDLObject");
	__xamarin_class_map [1228].handle = objc_getClass ("MDLLight");
	__xamarin_class_map [1229].handle = objc_getClass ("MDLPhysicallyPlausibleLight");
	__xamarin_class_map [1230].handle = objc_getClass ("MDLAreaLight");
	__xamarin_class_map [1231].handle = objc_getClass ("GKMonteCarloStrategist");
	__xamarin_class_map [1232].handle = objc_getClass ("GKNoise");
	__xamarin_class_map [1233].handle = objc_getClass ("NSScrubberLayout");
	__xamarin_class_map [1234].handle = objc_getClass ("NSScrubberFlowLayout");
	__xamarin_class_map [1235].handle = objc_getClass ("GKNoiseMap");
	__xamarin_class_map [1236].handle = objc_getClass ("CNContactFormatter");
	__xamarin_class_map [1237].handle = objc_getClass ("SCNGeometry");
	__xamarin_class_map [1238].handle = objc_getClass ("SCNText");
	__xamarin_class_map [1239].handle = objc_getClass ("MDLBundleAssetResolver");
	__xamarin_class_map [1240].handle = objc_getClass ("NSScrubberArrangedView");
	__xamarin_class_map [1241].handle = objc_getClass ("NSScrubberItemView");
	__xamarin_class_map [1242].handle = objc_getClass ("NSScrubberImageItemView");
	__xamarin_class_map [1243].handle = objc_getClass ("NSRulerMarker");
	__xamarin_class_map [1244].handle = objc_getClass ("SCNAction");
	__xamarin_class_map [1245].handle = objc_getClass ("SCNScene");
	__xamarin_class_map [1246].handle = objc_getClass ("GKRule");
	__xamarin_class_map [1247].handle = objc_getClass ("GKNSPredicateRule");
	__xamarin_class_map [1248].handle = objc_getClass ("NSCalendarDate");
	__xamarin_class_map [1249].handle = objc_getClass ("SCNGeometrySource");
	__xamarin_class_map [1250].handle = objc_getClass ("CNContactProperty");
	__xamarin_class_map [1251].handle = objc_getClass ("MDLCamera");
	__xamarin_class_map [1252].handle = objc_getClass ("NSCharacterSet");
	__xamarin_class_map [1253].handle = objc_getClass ("CNContactRelation");
	__xamarin_class_map [1254].handle = objc_getClass ("NSScrubberLayoutAttributes");
	__xamarin_class_map [1255].handle = objc_getClass ("MDLCheckerboardTexture");
	__xamarin_class_map [1256].handle = objc_getClass ("SCNParticleSystem");
	__xamarin_class_map [1257].handle = objc_getClass ("NSRulerView");
	__xamarin_class_map [1258].handle = objc_getClass ("NSScrubberProportionalLayout");
	__xamarin_class_map [1259].handle = objc_getClass ("SCNPhysicsShape");
	__xamarin_class_map [1260].handle = objc_getClass ("GKOctree");
	__xamarin_class_map [1261].handle = objc_getClass ("MDLColorSwatchTexture");
	__xamarin_class_map [1262].handle = objc_getClass ("NSScrubberSelectionStyle");
	__xamarin_class_map [1263].handle = objc_getClass ("GKOctreeNode");
	__xamarin_class_map [1264].handle = objc_getClass ("NSScrubberSelectionView");
	__xamarin_class_map [1265].handle = objc_getClass ("CNContactsUserDefaults");
	__xamarin_class_map [1266].handle = objc_getClass ("NSRunningApplication");
	__xamarin_class_map [1267].handle = objc_getClass ("NSScrubberTextItemView");
	__xamarin_class_map [1268].handle = objc_getClass ("CNContactVCardSerialization");
	__xamarin_class_map [1269].handle = objc_getClass ("GKPerlinNoiseSource");
	__xamarin_class_map [1270].handle = objc_getClass ("SCNSceneSource");
	__xamarin_class_map [1271].handle = objc_getClass ("NSComparisonPredicate");
	__xamarin_class_map [1272].handle = objc_getClass ("CNContainer");
	__xamarin_class_map [1273].handle = objc_getClass ("SCNSkinner");
	__xamarin_class_map [1274].handle = objc_getClass ("SCNTechnique");
	__xamarin_class_map [1275].handle = objc_getClass ("MDLLightProbe");
	__xamarin_class_map [1276].handle = objc_getClass ("GKQuadtree");
	__xamarin_class_map [1277].handle = objc_getClass ("NSCompoundPredicate");
	__xamarin_class_map [1278].handle = objc_getClass ("SKAction");
	__xamarin_class_map [1279].handle = objc_getClass ("GKQuadtreeNode");
	__xamarin_class_map [1280].handle = objc_getClass ("SKKeyframeSequence");
	__xamarin_class_map [1281].handle = objc_getClass ("NSCondition");
	__xamarin_class_map [1282].handle = objc_getClass ("NSConditionLock");
	__xamarin_class_map [1283].handle = objc_getClass ("NSSecureTextField");
	__xamarin_class_map [1284].handle = objc_getClass ("SKNode");
	__xamarin_class_map [1285].handle = objc_getClass ("SKShapeNode");
	__xamarin_class_map [1286].handle = objc_getClass ("MDLMaterial");
	__xamarin_class_map [1287].handle = objc_getClass ("CNGroup");
	__xamarin_class_map [1288].handle = objc_getClass ("NSSecureTextFieldCell");
	__xamarin_class_map [1289].handle = objc_getClass ("SKUniform");
	__xamarin_class_map [1290].handle = objc_getClass ("GKRidgedNoiseSource");
	__xamarin_class_map [1291].handle = objc_getClass ("SKVideoNode");
	__xamarin_class_map [1292].handle = objc_getClass ("GKRTree");
	__xamarin_class_map [1293].handle = objc_getClass ("SKWarpGeometry");
	__xamarin_class_map [1294].handle = objc_getClass ("SKWarpGeometryGrid");
	__xamarin_class_map [1295].handle = objc_getClass ("MDLMaterialProperty");
	__xamarin_class_map [1296].handle = objc_getClass ("MDLMaterialPropertyConnection");
	__xamarin_class_map [1297].handle = objc_getClass ("GKRuleSystem");
	__xamarin_class_map [1298].handle = objc_getClass ("NSDataDetector");
	__xamarin_class_map [1299].handle = objc_getClass ("__monomac_internal_ActionDispatcher");
	__xamarin_class_map [1300].handle = objc_getClass ("MDLMaterialPropertyNode");
	__xamarin_class_map [1301].handle = objc_getClass ("MDLMaterialPropertyGraph");
	__xamarin_class_map [1302].handle = objc_getClass ("CNLabeledValue");
	__xamarin_class_map [1303].handle = objc_getClass ("GKScene");
	__xamarin_class_map [1304].handle = objc_getClass ("NSStatusItem");
	__xamarin_class_map [1305].handle = objc_getClass ("GKSCNNodeComponent");
	__xamarin_class_map [1306].handle = objc_getClass ("NSScrubber");
	__xamarin_class_map [1307].handle = objc_getClass ("GKShuffledDistribution");
	__xamarin_class_map [1308].handle = objc_getClass ("NSDateComponents");
	__xamarin_class_map [1309].handle = objc_getClass ("GKSKNodeComponent");
	__xamarin_class_map [1310].handle = objc_getClass ("NSShadow");
	__xamarin_class_map [1311].handle = objc_getClass ("GKSphereObstacle");
	__xamarin_class_map [1312].handle = objc_getClass ("__MonoMac_NSAlertDidEndDispatcher");
	__xamarin_class_map [1313].handle = objc_getClass ("CNContact");
	__xamarin_class_map [1314].handle = objc_getClass ("CNMutableContact");
	__xamarin_class_map [1315].handle = objc_getClass ("GKSpheresNoiseSource");
	__xamarin_class_map [1316].handle = objc_getClass ("CNMutableGroup");
	__xamarin_class_map [1317].handle = objc_getClass ("NSDateComponentsFormatter");
	__xamarin_class_map [1318].handle = objc_getClass ("NSSliderTouchBarItem");
	__xamarin_class_map [1319].handle = objc_getClass ("QCComposition");
	__xamarin_class_map [1320].handle = objc_getClass ("CNPostalAddress");
	__xamarin_class_map [1321].handle = objc_getClass ("CNMutablePostalAddress");
	__xamarin_class_map [1322].handle = objc_getClass ("CNPhoneNumber");
	__xamarin_class_map [1323].handle = objc_getClass ("QCCompositionLayer");
	__xamarin_class_map [1324].handle = objc_getClass ("QCCompositionRepository");
	__xamarin_class_map [1325].handle = objc_getClass ("GKVoronoiNoiseSource");
	__xamarin_class_map [1326].handle = objc_getClass ("CNPostalAddressFormatter");
	__xamarin_class_map [1327].handle = objc_getClass ("NSSpeechRecognizer");
	__xamarin_class_map [1328].handle = objc_getClass ("NSDateFormatter");
	__xamarin_class_map [1329].handle = objc_getClass ("QLPreviewPanel");
	__xamarin_class_map [1330].handle = objc_getClass ("GLKBaseEffect");
	__xamarin_class_map [1331].handle = objc_getClass ("NSDateInterval");
	__xamarin_class_map [1332].handle = objc_getClass ("MDLMeshBufferData");
	__xamarin_class_map [1333].handle = objc_getClass ("NSSharingServicePickerTouchBarItem");
	__xamarin_class_map [1334].handle = objc_getClass ("GLKEffectProperty");
	__xamarin_class_map [1335].handle = objc_getClass ("CNSaveRequest");
	__xamarin_class_map [1336].handle = objc_getClass ("NSSpeechSynthesizer");
	__xamarin_class_map [1337].handle = objc_getClass ("MDLMeshBufferDataAllocator");
	__xamarin_class_map [1338].handle = objc_getClass ("GLKEffectPropertyFog");
	__xamarin_class_map [1339].handle = objc_getClass ("NSDateIntervalFormatter");
	__xamarin_class_map [1340].handle = objc_getClass ("MDLMeshBufferMap");
	__xamarin_class_map [1341].handle = objc_getClass ("GLKEffectPropertyLight");
	__xamarin_class_map [1342].handle = objc_getClass ("GLKEffectPropertyMaterial");
	__xamarin_class_map [1343].handle = objc_getClass ("MDLMeshBufferZoneDefault");
	__xamarin_class_map [1344].handle = objc_getClass ("NSSlider");
	__xamarin_class_map [1345].handle = objc_getClass ("NSDecimalNumber");
	__xamarin_class_map [1346].handle = objc_getClass ("SFContentBlockerState");
	__xamarin_class_map [1347].handle = objc_getClass ("GLKEffectPropertyTexture");
	__xamarin_class_map [1348].handle = objc_getClass ("GLKEffectPropertyTransform");
	__xamarin_class_map [1349].handle = objc_getClass ("MDLNormalMapTexture");
	__xamarin_class_map [1350].handle = objc_getClass ("GLKMeshBuffer");
	__xamarin_class_map [1351].handle = objc_getClass ("GLKMeshBufferAllocator");
	__xamarin_class_map [1352].handle = objc_getClass ("MDLObjectContainer");
	__xamarin_class_map [1353].handle = objc_getClass ("NSDistantObjectRequest");
	__xamarin_class_map [1354].handle = objc_getClass ("SFSafariExtensionViewController");
	__xamarin_class_map [1355].handle = objc_getClass ("CAAnimationGroup");
	__xamarin_class_map [1356].handle = objc_getClass ("MDLPackedJointAnimation");
	__xamarin_class_map [1357].handle = objc_getClass ("GLKReflectionMapEffect");
	__xamarin_class_map [1358].handle = objc_getClass ("NSDistributedLock");
	__xamarin_class_map [1359].handle = objc_getClass ("MDLPathAssetResolver");
	__xamarin_class_map [1360].handle = objc_getClass ("SFSafariPageProperties");
	__xamarin_class_map [1361].handle = objc_getClass ("GLKSkyboxEffect");
	__xamarin_class_map [1362].handle = objc_getClass ("MDLPhotometricLight");
	__xamarin_class_map [1363].handle = objc_getClass ("NSSplitViewController");
	__xamarin_class_map [1364].handle = objc_getClass ("NSNotificationCenter");
	__xamarin_class_map [1365].handle = objc_getClass ("NSDistributedNotificationCenter");
	__xamarin_class_map [1366].handle = objc_getClass ("GLKSubmesh");
	__xamarin_class_map [1367].handle = objc_getClass ("CAConstraint");
	__xamarin_class_map [1368].handle = objc_getClass ("CAConstraintLayoutManager");
	__xamarin_class_map [1369].handle = objc_getClass ("NSEnergyFormatter");
	__xamarin_class_map [1370].handle = objc_getClass ("GLKTextureInfo");
	__xamarin_class_map [1371].handle = objc_getClass ("SFSafariToolbarItem");
	__xamarin_class_map [1372].handle = objc_getClass ("MDLScatteringFunction");
	__xamarin_class_map [1373].handle = objc_getClass ("MDLPhysicallyPlausibleScatteringFunction");
	__xamarin_class_map [1374].handle = objc_getClass ("MDLRelativeAssetResolver");
	__xamarin_class_map [1375].handle = objc_getClass ("CAEmitterBehavior");
	__xamarin_class_map [1376].handle = objc_getClass ("NSSplitViewItem");
	__xamarin_class_map [1377].handle = objc_getClass ("SCNConstraint");
	__xamarin_class_map [1378].handle = objc_getClass ("SCNAccelerationConstraint");
	__xamarin_class_map [1379].handle = objc_getClass ("NSError");
	__xamarin_class_map [1380].handle = objc_getClass ("MDLSkeleton");
	__xamarin_class_map [1381].handle = objc_getClass ("NSException");
	__xamarin_class_map [1382].handle = objc_getClass ("NSStatusBar");
	__xamarin_class_map [1383].handle = objc_getClass ("MDLSkyCubeTexture");
	__xamarin_class_map [1384].handle = objc_getClass ("CAEmitterCell");
	__xamarin_class_map [1385].handle = objc_getClass ("NSStackView");
	__xamarin_class_map [1386].handle = objc_getClass ("MDLStereoscopicCamera");
	__xamarin_class_map [1387].handle = objc_getClass ("CAEmitterLayer");
	__xamarin_class_map [1388].handle = objc_getClass ("NSTextContainer");
	__xamarin_class_map [1389].handle = objc_getClass ("NSExtensionItem");
	__xamarin_class_map [1390].handle = objc_getClass ("MDLSubmesh");
	__xamarin_class_map [1391].handle = objc_getClass ("NSStatusBarButton");
	__xamarin_class_map [1392].handle = objc_getClass ("NSToolbarItem");
	__xamarin_class_map [1393].handle = objc_getClass ("NSFileAccessIntent");
	__xamarin_class_map [1394].handle = objc_getClass ("NSTouch");
	__xamarin_class_map [1395].handle = objc_getClass ("MDLSubmeshTopology");
	__xamarin_class_map [1396].handle = objc_getClass ("NSTreeController");
	__xamarin_class_map [1397].handle = objc_getClass ("NSFileCoordinator");
	__xamarin_class_map [1398].handle = objc_getClass ("NSTextBlock");
	__xamarin_class_map [1399].handle = objc_getClass ("NSTextTableBlock");
	__xamarin_class_map [1400].handle = objc_getClass ("SCNAnimation");
	__xamarin_class_map [1401].handle = objc_getClass ("SCNAnimationEvent");
	__xamarin_class_map [1402].handle = objc_getClass ("NSStepper");
	__xamarin_class_map [1403].handle = objc_getClass ("NSStepperCell");
	__xamarin_class_map [1404].handle = objc_getClass ("MDLTextureFilter");
	__xamarin_class_map [1405].handle = objc_getClass ("NSStoryboard");
	__xamarin_class_map [1406].handle = objc_getClass ("MDLTextureSampler");
	__xamarin_class_map [1407].handle = objc_getClass ("NSSliderAccessoryBehavior");
	__xamarin_class_map [1408].handle = objc_getClass ("NSStoryboardSegue");
	__xamarin_class_map [1409].handle = objc_getClass ("SCNAnimationPlayer");
	__xamarin_class_map [1410].handle = objc_getClass ("SCNAudioPlayer");
	__xamarin_class_map [1411].handle = objc_getClass ("NSSliderCell");
	__xamarin_class_map [1412].handle = objc_getClass ("SCNAudioSource");
	__xamarin_class_map [1413].handle = objc_getClass ("SCNAvoidOccluderConstraint");
	__xamarin_class_map [1414].handle = objc_getClass ("NSStringDrawingContext");
	__xamarin_class_map [1415].handle = objc_getClass ("SCNBillboardConstraint");
	__xamarin_class_map [1416].handle = objc_getClass ("MDLTransformMatrixOp");
	__xamarin_class_map [1417].handle = objc_getClass ("SCNBox");
	__xamarin_class_map [1418].handle = objc_getClass ("MDLTransformRotateOp");
	__xamarin_class_map [1419].handle = objc_getClass ("NSTableCellView");
	__xamarin_class_map [1420].handle = objc_getClass ("MDLTransformRotateXOp");
	__xamarin_class_map [1421].handle = objc_getClass ("MDLTransformRotateYOp");
	__xamarin_class_map [1422].handle = objc_getClass ("NSTableColumn");
	__xamarin_class_map [1423].handle = objc_getClass ("MDLTransformRotateZOp");
	__xamarin_class_map [1424].handle = objc_getClass ("CAMetalLayer");
	__xamarin_class_map [1425].handle = objc_getClass ("NSFileProviderService");
	__xamarin_class_map [1426].handle = objc_getClass ("NSTableHeaderCell");
	__xamarin_class_map [1427].handle = objc_getClass ("MDLTransformScaleOp");
	__xamarin_class_map [1428].handle = objc_getClass ("NSTableHeaderView");
	__xamarin_class_map [1429].handle = objc_getClass ("MDLTransformStack");
	__xamarin_class_map [1430].handle = objc_getClass ("CAReplicatorLayer");
	__xamarin_class_map [1431].handle = objc_getClass ("MDLTransformTranslateOp");
	__xamarin_class_map [1432].handle = objc_getClass ("NSTableRowView");
	__xamarin_class_map [1433].handle = objc_getClass ("NSFileWrapper");
	__xamarin_class_map [1434].handle = objc_getClass ("MDLURLTexture");
	__xamarin_class_map [1435].handle = objc_getClass ("IKFilterBrowserView");
	__xamarin_class_map [1436].handle = objc_getClass ("MDLVertexAttribute");
	__xamarin_class_map [1437].handle = objc_getClass ("IKFilterUIView");
	__xamarin_class_map [1438].handle = objc_getClass ("CAShapeLayer");
	__xamarin_class_map [1439].handle = objc_getClass ("MDLVertexAttributeData");
	__xamarin_class_map [1440].handle = objc_getClass ("SCNCamera");
	__xamarin_class_map [1441].handle = objc_getClass ("CASpringAnimation");
	__xamarin_class_map [1442].handle = objc_getClass ("IKImageBrowserCell");
	__xamarin_class_map [1443].handle = objc_getClass ("MDLVertexBufferLayout");
	__xamarin_class_map [1444].handle = objc_getClass ("SCNCameraController");
	__xamarin_class_map [1445].handle = objc_getClass ("NSHTTPURLResponse");
	__xamarin_class_map [1446].handle = objc_getClass ("NSTableViewRowAction");
	__xamarin_class_map [1447].handle = objc_getClass ("CATiledLayer");
	__xamarin_class_map [1448].handle = objc_getClass ("MDLVoxelArray");
	__xamarin_class_map [1449].handle = objc_getClass ("SCNCapsule");
	__xamarin_class_map [1450].handle = objc_getClass ("CATransaction");
	__xamarin_class_map [1451].handle = objc_getClass ("CATransformLayer");
	__xamarin_class_map [1452].handle = objc_getClass ("CATransition");
	__xamarin_class_map [1453].handle = objc_getClass ("SCNCone");
	__xamarin_class_map [1454].handle = objc_getClass ("CAValueFunction");
	__xamarin_class_map [1455].handle = objc_getClass ("NSInvocation");
	__xamarin_class_map [1456].handle = objc_getClass ("MCBrowserViewController");
	__xamarin_class_map [1457].handle = objc_getClass ("IKImageEditPanel");
	__xamarin_class_map [1458].handle = objc_getClass ("NSISO8601DateFormatter");
	__xamarin_class_map [1459].handle = objc_getClass ("NSTabViewController");
	__xamarin_class_map [1460].handle = objc_getClass ("NSTextFinder");
	__xamarin_class_map [1461].handle = objc_getClass ("AUParameterNode");
	__xamarin_class_map [1462].handle = objc_getClass ("AUParameter");
	__xamarin_class_map [1463].handle = objc_getClass ("SCNCylinder");
	__xamarin_class_map [1464].handle = objc_getClass ("MCNearbyServiceAdvertiser");
	__xamarin_class_map [1465].handle = objc_getClass ("SCNDistanceConstraint");
	__xamarin_class_map [1466].handle = objc_getClass ("NSTabViewItem");
	__xamarin_class_map [1467].handle = objc_getClass ("IKImageView");
	__xamarin_class_map [1468].handle = objc_getClass ("CBATTRequest");
	__xamarin_class_map [1469].handle = objc_getClass ("MCNearbyServiceBrowser");
	__xamarin_class_map [1470].handle = objc_getClass ("CBAttribute");
	__xamarin_class_map [1471].handle = objc_getClass ("IKPictureTaker");
	__xamarin_class_map [1472].handle = objc_getClass ("CBPeer");
	__xamarin_class_map [1473].handle = objc_getClass ("CBCentral");
	__xamarin_class_map [1474].handle = objc_getClass ("SCNFloor");
	__xamarin_class_map [1475].handle = objc_getClass ("NSTextList");
	__xamarin_class_map [1476].handle = objc_getClass ("NSTextAttachment");
	__xamarin_class_map [1477].handle = objc_getClass ("IKSlideshow");
	__xamarin_class_map [1478].handle = objc_getClass ("NSTextAttachmentCell");
	__xamarin_class_map [1479].handle = objc_getClass ("CBCharacteristic");
	__xamarin_class_map [1480].handle = objc_getClass ("SCNGeometryElement");
	__xamarin_class_map [1481].handle = objc_getClass ("CBDescriptor");
	__xamarin_class_map [1482].handle = objc_getClass ("INCallDestinationTypeResolutionResult");
	__xamarin_class_map [1483].handle = objc_getClass ("NSTextTab");
	__xamarin_class_map [1484].handle = objc_getClass ("CBL2CAPChannel");
	__xamarin_class_map [1485].handle = objc_getClass ("CBManager");
	__xamarin_class_map [1486].handle = objc_getClass ("NSLengthFormatter");
	__xamarin_class_map [1487].handle = objc_getClass ("NSTextTable");
	__xamarin_class_map [1488].handle = objc_getClass ("SCNGeometryTessellator");
	__xamarin_class_map [1489].handle = objc_getClass ("INCallRecordTypeOptionsResolutionResult");
	__xamarin_class_map [1490].handle = objc_getClass ("CBMutableCharacteristic");
	__xamarin_class_map [1491].handle = objc_getClass ("CBMutableDescriptor");
	__xamarin_class_map [1492].handle = objc_getClass ("CBService");
	__xamarin_class_map [1493].handle = objc_getClass ("CBMutableService");
	__xamarin_class_map [1494].handle = objc_getClass ("SCNHitTestResult");
	__xamarin_class_map [1495].handle = objc_getClass ("NSLinguisticTagger");
	__xamarin_class_map [1496].handle = objc_getClass ("INDateComponentsRange");
	__xamarin_class_map [1497].handle = objc_getClass ("SCNIKConstraint");
	__xamarin_class_map [1498].handle = objc_getClass ("INDateComponentsRangeResolutionResult");
	__xamarin_class_map [1499].handle = objc_getClass ("NSTrackingArea");
	__xamarin_class_map [1500].handle = objc_getClass ("INImage");
	__xamarin_class_map [1501].handle = objc_getClass ("NSLock");
	__xamarin_class_map [1502].handle = objc_getClass ("NSMachPort");
	__xamarin_class_map [1503].handle = objc_getClass ("NSTreeNode");
	__xamarin_class_map [1504].handle = objc_getClass ("INIntentResponse");
	__xamarin_class_map [1505].handle = objc_getClass ("NSMassFormatter");
	__xamarin_class_map [1506].handle = objc_getClass ("SCNLevelOfDetail");
	__xamarin_class_map [1507].handle = objc_getClass ("NSMeasurement");
	__xamarin_class_map [1508].handle = objc_getClass ("NSMeasurementFormatter");
	__xamarin_class_map [1509].handle = objc_getClass ("NSUserDefaultsController");
	__xamarin_class_map [1510].handle = objc_getClass ("INMessage");
	__xamarin_class_map [1511].handle = objc_getClass ("SKRequest");
	__xamarin_class_map [1512].handle = objc_getClass ("SKReceiptRefreshRequest");
	__xamarin_class_map [1513].handle = objc_getClass ("SKPayment");
	__xamarin_class_map [1514].handle = objc_getClass ("NSUserInterfaceCompressionOptions");
	__xamarin_class_map [1515].handle = objc_getClass ("SCNLight");
	__xamarin_class_map [1516].handle = objc_getClass ("INPerson");
	__xamarin_class_map [1517].handle = objc_getClass ("SCNLookAtConstraint");
	__xamarin_class_map [1518].handle = objc_getClass ("INPersonHandle");
	__xamarin_class_map [1519].handle = objc_getClass ("NSAsynchronousFetchRequest");
	__xamarin_class_map [1520].handle = objc_getClass ("NSPersistentStoreAsynchronousResult");
	__xamarin_class_map [1521].handle = objc_getClass ("NSAsynchronousFetchResult");
	__xamarin_class_map [1522].handle = objc_getClass ("NSAtomicStore");
	__xamarin_class_map [1523].handle = objc_getClass ("NSTitlebarAccessoryViewController");
	__xamarin_class_map [1524].handle = objc_getClass ("INPersonResolutionResult");
	__xamarin_class_map [1525].handle = objc_getClass ("NSAtomicStoreCacheNode");
	__xamarin_class_map [1526].handle = objc_getClass ("INPlacemarkResolutionResult");
	__xamarin_class_map [1527].handle = objc_getClass ("NSTokenField");
	__xamarin_class_map [1528].handle = objc_getClass ("SCNMaterial");
	__xamarin_class_map [1529].handle = objc_getClass ("INRecurrenceRule");
	__xamarin_class_map [1530].handle = objc_getClass ("NSBatchDeleteRequest");
	__xamarin_class_map [1531].handle = objc_getClass ("NSBatchDeleteResult");
	__xamarin_class_map [1532].handle = objc_getClass ("VNDetectBarcodesRequest");
	__xamarin_class_map [1533].handle = objc_getClass ("NSBatchUpdateRequest");
	__xamarin_class_map [1534].handle = objc_getClass ("VNFaceLandmarkRegion");
	__xamarin_class_map [1535].handle = objc_getClass ("VNFaceLandmarkRegion2D");
	__xamarin_class_map [1536].handle = objc_getClass ("NSBatchUpdateResult");
	__xamarin_class_map [1537].handle = objc_getClass ("SCNMaterialProperty");
	__xamarin_class_map [1538].handle = objc_getClass ("INSearchCallHistoryIntentResponse");
	__xamarin_class_map [1539].handle = objc_getClass ("NSConstraintConflict");
	__xamarin_class_map [1540].handle = objc_getClass ("NSMetadataQueryAttributeValueTuple");
	__xamarin_class_map [1541].handle = objc_getClass ("NSMetadataQueryResultGroup");
	__xamarin_class_map [1542].handle = objc_getClass ("NSMethodSignature");
	__xamarin_class_map [1543].handle = objc_getClass ("INSearchForMessagesIntent");
	__xamarin_class_map [1544].handle = objc_getClass ("SCNMorpher");
	__xamarin_class_map [1545].handle = objc_getClass ("NSToolbarItemGroup");
	__xamarin_class_map [1546].handle = objc_getClass ("NSEntityMapping");
	__xamarin_class_map [1547].handle = objc_getClass ("INSearchForMessagesIntentResponse");
	__xamarin_class_map [1548].handle = objc_getClass ("NSMutableCharacterSet");
	__xamarin_class_map [1549].handle = objc_getClass ("NSEntityMigrationPolicy");
	__xamarin_class_map [1550].handle = objc_getClass ("INSendMessageIntent");
	__xamarin_class_map [1551].handle = objc_getClass ("NSExpressionDescription");
	__xamarin_class_map [1552].handle = objc_getClass ("NSFetchedPropertyDescription");
	__xamarin_class_map [1553].handle = objc_getClass ("NSFetchIndexDescription");
	__xamarin_class_map [1554].handle = objc_getClass ("INSendMessageIntentResponse");
	__xamarin_class_map [1555].handle = objc_getClass ("NSFetchIndexElementDescription");
	__xamarin_class_map [1556].handle = objc_getClass ("INSpeakableStringResolutionResult");
	__xamarin_class_map [1557].handle = objc_getClass ("INSendMessageRecipientResolutionResult");
	__xamarin_class_map [1558].handle = objc_getClass ("INStartAudioCallIntent");
	__xamarin_class_map [1559].handle = objc_getClass ("AUAudioUnitBus");
	__xamarin_class_map [1560].handle = objc_getClass ("AUAudioUnitBusArray");
	__xamarin_class_map [1561].handle = objc_getClass ("NSFetchRequest");
	__xamarin_class_map [1562].handle = objc_getClass ("INStartAudioCallIntentResponse");
	__xamarin_class_map [1563].handle = objc_getClass ("AUAudioUnitPreset");
	__xamarin_class_map [1564].handle = objc_getClass ("NSFetchRequestExpression");
	__xamarin_class_map [1565].handle = objc_getClass ("JSManagedValue");
	__xamarin_class_map [1566].handle = objc_getClass ("INStartVideoCallIntent");
	__xamarin_class_map [1567].handle = objc_getClass ("AUParameterGroup");
	__xamarin_class_map [1568].handle = objc_getClass ("INStartVideoCallIntentResponse");
	__xamarin_class_map [1569].handle = objc_getClass ("NSIncrementalStore");
	__xamarin_class_map [1570].handle = objc_getClass ("NSIncrementalStoreNode");
	__xamarin_class_map [1571].handle = objc_getClass ("INStringResolutionResult");
	__xamarin_class_map [1572].handle = objc_getClass ("JSVirtualMachine");
	__xamarin_class_map [1573].handle = objc_getClass ("NSManagedObject");
	__xamarin_class_map [1574].handle = objc_getClass ("AUParameterTree");
	__xamarin_class_map [1575].handle = objc_getClass ("SCNParticlePropertyController");
	__xamarin_class_map [1576].handle = objc_getClass ("NCWidgetController");
	__xamarin_class_map [1577].handle = objc_getClass ("MKOverlayRenderer");
	__xamarin_class_map [1578].handle = objc_getClass ("MKOverlayPathRenderer");
	__xamarin_class_map [1579].handle = objc_getClass ("MKCircleRenderer");
	__xamarin_class_map [1580].handle = objc_getClass ("MKClusterAnnotation");
	__xamarin_class_map [1581].handle = objc_getClass ("SCNPhysicsBehavior");
	__xamarin_class_map [1582].handle = objc_getClass ("SCNPhysicsSliderJoint");
	__xamarin_class_map [1583].handle = objc_getClass ("NSManagedObjectID");
	__xamarin_class_map [1584].handle = objc_getClass ("MKDirectionsRequest");
	__xamarin_class_map [1585].handle = objc_getClass ("AVAssetCache");
	__xamarin_class_map [1586].handle = objc_getClass ("NSManagedObjectModel");
	__xamarin_class_map [1587].handle = objc_getClass ("MKDirectionsResponse");
	__xamarin_class_map [1588].handle = objc_getClass ("MKAnnotationView");
	__xamarin_class_map [1589].handle = objc_getClass ("NSMappingModel");
	__xamarin_class_map [1590].handle = objc_getClass ("MKCircle");
	__xamarin_class_map [1591].handle = objc_getClass ("MKDistanceFormatter");
	__xamarin_class_map [1592].handle = objc_getClass ("SCNPhysicsVehicle");
	__xamarin_class_map [1593].handle = objc_getClass ("MKLocalSearchCompletion");
	__xamarin_class_map [1594].handle = objc_getClass ("NSMigrationManager");
	__xamarin_class_map [1595].handle = objc_getClass ("MKLocalSearchRequest");
	__xamarin_class_map [1596].handle = objc_getClass ("MKLocalSearchResponse");
	__xamarin_class_map [1597].handle = objc_getClass ("MKETAResponse");
	__xamarin_class_map [1598].handle = objc_getClass ("SCNPhysicsBallSocketJoint");
	__xamarin_class_map [1599].handle = objc_getClass ("MKMapCamera");
	__xamarin_class_map [1600].handle = objc_getClass ("SCNPhysicsVehicleWheel");
	__xamarin_class_map [1601].handle = objc_getClass ("NSPersistentHistoryChange");
	__xamarin_class_map [1602].handle = objc_getClass ("NSPersistentHistoryChangeRequest");
	__xamarin_class_map [1603].handle = objc_getClass ("AVAssetReader");
	__xamarin_class_map [1604].handle = objc_getClass ("MKLocalSearchCompleter");
	__xamarin_class_map [1605].handle = objc_getClass ("NSPersistentHistoryResult");
	__xamarin_class_map [1606].handle = objc_getClass ("MKMapSnapshot");
	__xamarin_class_map [1607].handle = objc_getClass ("AVAssetReaderAudioMixOutput");
	__xamarin_class_map [1608].handle = objc_getClass ("SCNPhysicsBody");
	__xamarin_class_map [1609].handle = objc_getClass ("NSPersistentHistoryToken");
	__xamarin_class_map [1610].handle = objc_getClass ("MKMapSnapshotOptions");
	__xamarin_class_map [1611].handle = objc_getClass ("NSPersistentHistoryTransaction");
	__xamarin_class_map [1612].handle = objc_getClass ("SCNPlane");
	__xamarin_class_map [1613].handle = objc_getClass ("AVAssetReaderOutputMetadataAdaptor");
	__xamarin_class_map [1614].handle = objc_getClass ("SCNPhysicsConeTwistJoint");
	__xamarin_class_map [1615].handle = objc_getClass ("MKPinAnnotationView");
	__xamarin_class_map [1616].handle = objc_getClass ("AVAssetReaderSampleReferenceOutput");
	__xamarin_class_map [1617].handle = objc_getClass ("SCNPhysicsContact");
	__xamarin_class_map [1618].handle = objc_getClass ("MKPlacemark");
	__xamarin_class_map [1619].handle = objc_getClass ("SCNProgram");
	__xamarin_class_map [1620].handle = objc_getClass ("MKPointAnnotation");
	__xamarin_class_map [1621].handle = objc_getClass ("AVAssetReaderTrackOutput");
	__xamarin_class_map [1622].handle = objc_getClass ("MKPolygonRenderer");
	__xamarin_class_map [1623].handle = objc_getClass ("SCNPhysicsField");
	__xamarin_class_map [1624].handle = objc_getClass ("MKPolylineRenderer");
	__xamarin_class_map [1625].handle = objc_getClass ("SCNPyramid");
	__xamarin_class_map [1626].handle = objc_getClass ("AVAssetResourceLoader");
	__xamarin_class_map [1627].handle = objc_getClass ("MKRoute");
	__xamarin_class_map [1628].handle = objc_getClass ("SCNPhysicsHingeJoint");
	__xamarin_class_map [1629].handle = objc_getClass ("NSAnimation");
	__xamarin_class_map [1630].handle = objc_getClass ("NSViewAnimation");
	__xamarin_class_map [1631].handle = objc_getClass ("MKRouteStep");
	__xamarin_class_map [1632].handle = objc_getClass ("SCNNode");
	__xamarin_class_map [1633].handle = objc_getClass ("SCNReferenceNode");
	__xamarin_class_map [1634].handle = objc_getClass ("AVAssetResourceLoadingContentInformationRequest");
	__xamarin_class_map [1635].handle = objc_getClass ("MLMediaGroup");
	__xamarin_class_map [1636].handle = objc_getClass ("AVAssetResourceLoadingRequest");
	__xamarin_class_map [1637].handle = objc_getClass ("MLMediaLibrary");
	__xamarin_class_map [1638].handle = objc_getClass ("AVAssetResourceRenewalRequest");
	__xamarin_class_map [1639].handle = objc_getClass ("MKTileOverlay");
	__xamarin_class_map [1640].handle = objc_getClass ("MLMediaObject");
	__xamarin_class_map [1641].handle = objc_getClass ("SCNReplicatorConstraint");
	__xamarin_class_map [1642].handle = objc_getClass ("NSVisualEffectView");
	__xamarin_class_map [1643].handle = objc_getClass ("MLMediaSource");
	__xamarin_class_map [1644].handle = objc_getClass ("MPChangeLanguageOptionCommandEvent");
	__xamarin_class_map [1645].handle = objc_getClass ("MPChangePlaybackPositionCommand");
	__xamarin_class_map [1646].handle = objc_getClass ("MKTileOverlayRenderer");
	__xamarin_class_map [1647].handle = objc_getClass ("MPChangePlaybackPositionCommandEvent");
	__xamarin_class_map [1648].handle = objc_getClass ("AVAssetTrackGroup");
	__xamarin_class_map [1649].handle = objc_getClass ("SCNShape");
	__xamarin_class_map [1650].handle = objc_getClass ("MKUserLocation");
	__xamarin_class_map [1651].handle = objc_getClass ("SCNSliderConstraint");
	__xamarin_class_map [1652].handle = objc_getClass ("SBElementArray");
	__xamarin_class_map [1653].handle = objc_getClass ("SCNSphere");
	__xamarin_class_map [1654].handle = objc_getClass ("SBObject");
	__xamarin_class_map [1655].handle = objc_getClass ("SK3DNode");
	__xamarin_class_map [1656].handle = objc_getClass ("AVAssetWriterInput");
	__xamarin_class_map [1657].handle = objc_getClass ("AVAssetWriterInputGroup");
	__xamarin_class_map [1658].handle = objc_getClass ("__MonoMac_NSActionDispatcher");
	__xamarin_class_map [1659].handle = objc_getClass ("__MonoMac_ActionDispatcher");
	__xamarin_class_map [1660].handle = objc_getClass ("__Xamarin_NSTimerActionDispatcher");
	__xamarin_class_map [1661].handle = objc_getClass ("__MonoMac_NSAsyncActionDispatcher");
	__xamarin_class_map [1662].handle = objc_getClass ("NSAutoreleasePool");
	__xamarin_class_map [1663].handle = objc_getClass ("AVAssetWriterInputMetadataAdaptor");
	__xamarin_class_map [1664].handle = objc_getClass ("SCNTimingFunction");
	__xamarin_class_map [1665].handle = objc_getClass ("AVAssetWriterInputPassDescription");
	__xamarin_class_map [1666].handle = objc_getClass ("SCNTorus");
	__xamarin_class_map [1667].handle = objc_getClass ("AVAssetWriterInputPixelBufferAdaptor");
	__xamarin_class_map [1668].handle = objc_getClass ("SCNTransaction");
	__xamarin_class_map [1669].handle = objc_getClass ("SKPhysicsJoint");
	__xamarin_class_map [1670].handle = objc_getClass ("SKPhysicsJointPin");
	__xamarin_class_map [1671].handle = objc_getClass ("AVAsynchronousCIImageFilteringRequest");
	__xamarin_class_map [1672].handle = objc_getClass ("SCNTransformConstraint");
	__xamarin_class_map [1673].handle = objc_getClass ("SKPhysicsJointSliding");
	__xamarin_class_map [1674].handle = objc_getClass ("SKPhysicsJointSpring");
	__xamarin_class_map [1675].handle = objc_getClass ("AVAsynchronousVideoCompositionRequest");
	__xamarin_class_map [1676].handle = objc_getClass ("SCNTube");
	__xamarin_class_map [1677].handle = objc_getClass ("SKLabelNode");
	__xamarin_class_map [1678].handle = objc_getClass ("SKRange");
	__xamarin_class_map [1679].handle = objc_getClass ("SKReachConstraints");
	__xamarin_class_map [1680].handle = objc_getClass ("SKLightNode");
	__xamarin_class_map [1681].handle = objc_getClass ("SKReferenceNode");
	__xamarin_class_map [1682].handle = objc_getClass ("SKTexture");
	__xamarin_class_map [1683].handle = objc_getClass ("SKMutableTexture");
	__xamarin_class_map [1684].handle = objc_getClass ("SKRegion");
	__xamarin_class_map [1685].handle = objc_getClass ("AVAudioCompressedBuffer");
	__xamarin_class_map [1686].handle = objc_getClass ("SKRenderer");
	__xamarin_class_map [1687].handle = objc_getClass ("SKAttribute");
	__xamarin_class_map [1688].handle = objc_getClass ("SKTileDefinition");
	__xamarin_class_map [1689].handle = objc_getClass ("SKTileGroup");
	__xamarin_class_map [1690].handle = objc_getClass ("SKEffectNode");
	__xamarin_class_map [1691].handle = objc_getClass ("SKScene");
	__xamarin_class_map [1692].handle = objc_getClass ("AVAudioConverter");
	__xamarin_class_map [1693].handle = objc_getClass ("SKTileGroupRule");
	__xamarin_class_map [1694].handle = objc_getClass ("SKView");
	__xamarin_class_map [1695].handle = objc_getClass ("SKAttributeValue");
	__xamarin_class_map [1696].handle = objc_getClass ("SKShader");
	__xamarin_class_map [1697].handle = objc_getClass ("SKPhysicsBody");
	__xamarin_class_map [1698].handle = objc_getClass ("SKTileMapNode");
	__xamarin_class_map [1699].handle = objc_getClass ("SKPhysicsContact");
	__xamarin_class_map [1700].handle = objc_getClass ("SKTileSet");
	__xamarin_class_map [1701].handle = objc_getClass ("SKAudioNode");
	__xamarin_class_map [1702].handle = objc_getClass ("SKPhysicsJointFixed");
	__xamarin_class_map [1703].handle = objc_getClass ("SKTransformNode");
	__xamarin_class_map [1704].handle = objc_getClass ("SKPhysicsJointLimit");
	__xamarin_class_map [1705].handle = objc_getClass ("SKCameraNode");
	__xamarin_class_map [1706].handle = objc_getClass ("SKDownload");
	__xamarin_class_map [1707].handle = objc_getClass ("SKTransition");
	__xamarin_class_map [1708].handle = objc_getClass ("SKConstraint");
	__xamarin_class_map [1709].handle = objc_getClass ("AVAudioEnvironmentDistanceAttenuationParameters");
	__xamarin_class_map [1710].handle = objc_getClass ("SKCropNode");
	__xamarin_class_map [1711].handle = objc_getClass ("SKMutablePayment");
	__xamarin_class_map [1712].handle = objc_getClass ("SKSpriteNode");
	__xamarin_class_map [1713].handle = objc_getClass ("SKPaymentQueue");
	__xamarin_class_map [1714].handle = objc_getClass ("AVAudioEnvironmentNode");
	__xamarin_class_map [1715].handle = objc_getClass ("SKProduct");
	__xamarin_class_map [1716].handle = objc_getClass ("SKPaymentTransaction");
	__xamarin_class_map [1717].handle = objc_getClass ("AVAudioEnvironmentReverbParameters");
	__xamarin_class_map [1718].handle = objc_getClass ("SKProductDiscount");
	__xamarin_class_map [1719].handle = objc_getClass ("AVAudioFile");
	__xamarin_class_map [1720].handle = objc_getClass ("NSWindowController");
	__xamarin_class_map [1721].handle = objc_getClass ("SKProductsResponse");
	__xamarin_class_map [1722].handle = objc_getClass ("VNDetectHorizonRequest");
	__xamarin_class_map [1723].handle = objc_getClass ("SKProductSubscriptionPeriod");
	__xamarin_class_map [1724].handle = objc_getClass ("VNBarcodeObservation");
	__xamarin_class_map [1725].handle = objc_getClass ("AVAudioIONode");
	__xamarin_class_map [1726].handle = objc_getClass ("AVAudioInputNode");
	__xamarin_class_map [1727].handle = objc_getClass ("VNDetectRectanglesRequest");
	__xamarin_class_map [1728].handle = objc_getClass ("VNDetectTextRectanglesRequest");
	__xamarin_class_map [1729].handle = objc_getClass ("VNClassificationObservation");
	__xamarin_class_map [1730].handle = objc_getClass ("VNCoreMLFeatureValueObservation");
	__xamarin_class_map [1731].handle = objc_getClass ("SKEmitterNode");
	__xamarin_class_map [1732].handle = objc_getClass ("VNCoreMLModel");
	__xamarin_class_map [1733].handle = objc_getClass ("AVAudioMixerNode");
	__xamarin_class_map [1734].handle = objc_getClass ("VNCoreMLRequest");
	__xamarin_class_map [1735].handle = objc_getClass ("VNFaceLandmarks");
	__xamarin_class_map [1736].handle = objc_getClass ("VNFaceLandmarks2D");
	__xamarin_class_map [1737].handle = objc_getClass ("SKFieldNode");
	__xamarin_class_map [1738].handle = objc_getClass ("VNFaceObservation");
	__xamarin_class_map [1739].handle = objc_getClass ("NSWindowTab");
	__xamarin_class_map [1740].handle = objc_getClass ("VNDetectFaceLandmarksRequest");
	__xamarin_class_map [1741].handle = objc_getClass ("AVAudioMixingDestination");
	__xamarin_class_map [1742].handle = objc_getClass ("VNDetectFaceRectanglesRequest");
	__xamarin_class_map [1743].handle = objc_getClass ("NSWindowTabGroup");
	__xamarin_class_map [1744].handle = objc_getClass ("AVAudioOutputNode");
	__xamarin_class_map [1745].handle = objc_getClass ("VNHomographicImageRegistrationRequest");
	__xamarin_class_map [1746].handle = objc_getClass ("VNHorizonObservation");
	__xamarin_class_map [1747].handle = objc_getClass ("AVAudioPCMBuffer");
	__xamarin_class_map [1748].handle = objc_getClass ("NSDictionary");
	__xamarin_class_map [1749].handle = objc_getClass ("NSMutableDictionary");
	__xamarin_class_map [1750].handle = objc_getClass ("NCWidgetListViewController");
	__xamarin_class_map [1751].handle = objc_getClass ("ACAccountStore");
	__xamarin_class_map [1752].handle = objc_getClass ("NSPersistentStoreCoordinator");
	__xamarin_class_map [1753].handle = objc_getClass ("CNContactStore");
	__xamarin_class_map [1754].handle = objc_getClass ("NCWidgetSearchViewController");
	__xamarin_class_map [1755].handle = objc_getClass ("NSNetService");
	__xamarin_class_map [1756].handle = objc_getClass ("NSNetServiceBrowser");
	__xamarin_class_map [1757].handle = objc_getClass ("AVAudioUnitComponent");
	__xamarin_class_map [1758].handle = objc_getClass ("CLLocationManager");
	__xamarin_class_map [1759].handle = objc_getClass ("AVCaptureDevice");
	__xamarin_class_map [1760].handle = objc_getClass ("NSProcessInfo");
	__xamarin_class_map [1761].handle = objc_getClass ("NSProgress");
	__xamarin_class_map [1762].handle = objc_getClass ("AVCaptureSession");
	__xamarin_class_map [1763].handle = objc_getClass ("AVCaptureStillImageOutput");
	__xamarin_class_map [1764].handle = objc_getClass ("AVCaptureVideoPreviewLayer");
	__xamarin_class_map [1765].handle = objc_getClass ("EKEventStore");
	__xamarin_class_map [1766].handle = objc_getClass ("GLKTextureLoader");
	__xamarin_class_map [1767].handle = objc_getClass ("NSTask");
	__xamarin_class_map [1768].handle = objc_getClass ("NSApplication");
	__xamarin_class_map [1769].handle = objc_getClass ("NSThread");
	__xamarin_class_map [1770].handle = objc_getClass ("AVFragmentedMovie");
	__xamarin_class_map [1771].handle = objc_getClass ("AVFragmentedMovieTrack");
	__xamarin_class_map [1772].handle = objc_getClass ("NSUbiquitousKeyValueStore");
	__xamarin_class_map [1773].handle = objc_getClass ("NSUndoManager");
	__xamarin_class_map [1774].handle = objc_getClass ("MKDirections");
	__xamarin_class_map [1775].handle = objc_getClass ("MKLocalSearch");
	__xamarin_class_map [1776].handle = objc_getClass ("NSBrowser");
	__xamarin_class_map [1777].handle = objc_getClass ("NSGestureRecognizer");
	__xamarin_class_map [1778].handle = objc_getClass ("NSClickGestureRecognizer");
	__xamarin_class_map [1779].handle = objc_getClass ("AVMIDIPlayer");
	__xamarin_class_map [1780].handle = objc_getClass ("WebHistoryItem");
	__xamarin_class_map [1781].handle = objc_getClass ("MDLMesh");
	__xamarin_class_map [1782].handle = objc_getClass ("NSURL");
	__xamarin_class_map [1783].handle = objc_getClass ("MCSession");
	__xamarin_class_map [1784].handle = objc_getClass ("NSURLCache");
	__xamarin_class_map [1785].handle = objc_getClass ("MTKTextureLoader");
	__xamarin_class_map [1786].handle = objc_getClass ("NSComboBox");
	__xamarin_class_map [1787].handle = objc_getClass ("NSURLConnection");
	__xamarin_class_map [1788].handle = objc_getClass ("NSColor");
	__xamarin_class_map [1789].handle = objc_getClass ("NSColorPanel");
	__xamarin_class_map [1790].handle = objc_getClass ("NSURLCredentialStorage");
	__xamarin_class_map [1791].handle = objc_getClass ("NSDatePicker");
	__xamarin_class_map [1792].handle = objc_getClass ("NSDatePickerCell");
	__xamarin_class_map [1793].handle = objc_getClass ("AVPlayerItem");
	__xamarin_class_map [1794].handle = objc_getClass ("WebView");
	__xamarin_class_map [1795].handle = objc_getClass ("NSURLSession");
	__xamarin_class_map [1796].handle = objc_getClass ("WKContentRuleListStore");
	__xamarin_class_map [1797].handle = objc_getClass ("WKHTTPCookieStore");
	__xamarin_class_map [1798].handle = objc_getClass ("NSDocument");
	__xamarin_class_map [1799].handle = objc_getClass ("NSURLSessionStreamTask");
	__xamarin_class_map [1800].handle = objc_getClass ("AVPlayerItemVideoOutput");
	__xamarin_class_map [1801].handle = objc_getClass ("NSEvent");
	__xamarin_class_map [1802].handle = objc_getClass ("NSUserActivity");
	__xamarin_class_map [1803].handle = objc_getClass ("AVRouteDetector");
	__xamarin_class_map [1804].handle = objc_getClass ("AVSampleBufferAudioRenderer");
	__xamarin_class_map [1805].handle = objc_getClass ("NSFont");
	__xamarin_class_map [1806].handle = objc_getClass ("AVSampleBufferDisplayLayer");
	__xamarin_class_map [1807].handle = objc_getClass ("NSUserDefaults");
	__xamarin_class_map [1808].handle = objc_getClass ("AVSampleBufferGenerator");
	__xamarin_class_map [1809].handle = objc_getClass ("WKWebsiteDataStore");
	__xamarin_class_map [1810].handle = objc_getClass ("AVSampleBufferRenderSynchronizer");
	__xamarin_class_map [1811].handle = objc_getClass ("WKWebView");
	__xamarin_class_map [1812].handle = objc_getClass ("NSUserNotificationCenter");
	__xamarin_class_map [1813].handle = objc_getClass ("CLGeocoder");
	__xamarin_class_map [1814].handle = objc_getClass ("GCController");
	__xamarin_class_map [1815].handle = objc_getClass ("NSDrawer");
	__xamarin_class_map [1816].handle = objc_getClass ("GKAchievement");
	__xamarin_class_map [1817].handle = objc_getClass ("GKAchievementDescription");
	__xamarin_class_map [1818].handle = objc_getClass ("GKGameCenterViewController");
	__xamarin_class_map [1819].handle = objc_getClass ("GKAchievementViewController");
	__xamarin_class_map [1820].handle = objc_getClass ("NSHelpManager");
	__xamarin_class_map [1821].handle = objc_getClass ("CBCentralManager");
	__xamarin_class_map [1822].handle = objc_getClass ("CBPeripheralManager");
	__xamarin_class_map [1823].handle = objc_getClass ("GKFriendRequestComposeViewController");
	__xamarin_class_map [1824].handle = objc_getClass ("CBPeripheral");
	__xamarin_class_map [1825].handle = objc_getClass ("NSImage");
	__xamarin_class_map [1826].handle = objc_getClass ("GKGameSession");
	__xamarin_class_map [1827].handle = objc_getClass ("PDFDocument");
	__xamarin_class_map [1828].handle = objc_getClass ("NSMagnificationGestureRecognizer");
	__xamarin_class_map [1829].handle = objc_getClass ("GKLeaderboard");
	__xamarin_class_map [1830].handle = objc_getClass ("GKLeaderboardSet");
	__xamarin_class_map [1831].handle = objc_getClass ("GKLeaderboardViewController");
	__xamarin_class_map [1832].handle = objc_getClass ("GKPlayer");
	__xamarin_class_map [1833].handle = objc_getClass ("GKLocalPlayer");
	__xamarin_class_map [1834].handle = objc_getClass ("GKMatch");
	__xamarin_class_map [1835].handle = objc_getClass ("PDFThumbnailView");
	__xamarin_class_map [1836].handle = objc_getClass ("CKContainer");
	__xamarin_class_map [1837].handle = objc_getClass ("CKDatabase");
	__xamarin_class_map [1838].handle = objc_getClass ("GKMatchmaker");
	__xamarin_class_map [1839].handle = objc_getClass ("GKMatchmakerViewController");
	__xamarin_class_map [1840].handle = objc_getClass ("PDFView");
	__xamarin_class_map [1841].handle = objc_getClass ("NSTableView");
	__xamarin_class_map [1842].handle = objc_getClass ("NSOutlineView");
	__xamarin_class_map [1843].handle = objc_getClass ("GKNotificationBanner");
	__xamarin_class_map [1844].handle = objc_getClass ("GKSavedGame");
	__xamarin_class_map [1845].handle = objc_getClass ("GKScore");
	__xamarin_class_map [1846].handle = objc_getClass ("NSCalendar");
	__xamarin_class_map [1847].handle = objc_getClass ("NSPageController");
	__xamarin_class_map [1848].handle = objc_getClass ("NSPanGestureRecognizer");
	__xamarin_class_map [1849].handle = objc_getClass ("GKTurnBasedExchange");
	__xamarin_class_map [1850].handle = objc_getClass ("NSFileManager");
	__xamarin_class_map [1851].handle = objc_getClass ("NSHost");
	__xamarin_class_map [1852].handle = objc_getClass ("GKTurnBasedMatch");
	__xamarin_class_map [1853].handle = objc_getClass ("MPSNNGraph");
	__xamarin_class_map [1854].handle = objc_getClass ("NSHTTPCookieStorage");
	__xamarin_class_map [1855].handle = objc_getClass ("NSKeyedArchiver");
	__xamarin_class_map [1856].handle = objc_getClass ("NSKeyedUnarchiver");
	__xamarin_class_map [1857].handle = objc_getClass ("NSLocale");
	__xamarin_class_map [1858].handle = objc_getClass ("NSPathCell");
	__xamarin_class_map [1859].handle = objc_getClass ("FIFinderSync");
	__xamarin_class_map [1860].handle = objc_getClass ("FIFinderSyncController");
	__xamarin_class_map [1861].handle = objc_getClass ("NSPopUpButtonCell");
	__xamarin_class_map [1862].handle = objc_getClass ("NSPressGestureRecognizer");
	__xamarin_class_map [1863].handle = objc_getClass ("NSPopover");
	__xamarin_class_map [1864].handle = objc_getClass ("NSCache");
	__xamarin_class_map [1865].handle = objc_getClass ("NSRotationGestureRecognizer");
	__xamarin_class_map [1866].handle = objc_getClass ("NSItemProvider");
	__xamarin_class_map [1867].handle = objc_getClass ("NSScreen");
	__xamarin_class_map [1868].handle = objc_getClass ("NSScroller");
	__xamarin_class_map [1869].handle = objc_getClass ("NSScrollView");
	__xamarin_class_map [1870].handle = objc_getClass ("NSSharingService");
	__xamarin_class_map [1871].handle = objc_getClass ("NSSound");
	__xamarin_class_map [1872].handle = objc_getClass ("NSSharingServicePicker");
	__xamarin_class_map [1873].handle = objc_getClass ("SFContentBlockerManager");
	__xamarin_class_map [1874].handle = objc_getClass ("SFSafariApplication");
	__xamarin_class_map [1875].handle = objc_getClass ("SFSafariExtensionHandler");
	__xamarin_class_map [1876].handle = objc_getClass ("NSSpellChecker");
	__xamarin_class_map [1877].handle = objc_getClass ("NSSplitView");
	__xamarin_class_map [1878].handle = objc_getClass ("SFSafariPage");
	__xamarin_class_map [1879].handle = objc_getClass ("SFSafariTab");
	__xamarin_class_map [1880].handle = objc_getClass ("SFSafariWindow");
	__xamarin_class_map [1881].handle = objc_getClass ("NSTextStorage");
	__xamarin_class_map [1882].handle = objc_getClass ("NSWorkspace");
	__xamarin_class_map [1883].handle = objc_getClass ("NSSliderAccessory");
	__xamarin_class_map [1884].handle = objc_getClass ("NSFileHandle");
	__xamarin_class_map [1885].handle = objc_getClass ("IKCameraDeviceView");
	__xamarin_class_map [1886].handle = objc_getClass ("NSFileVersion");
	__xamarin_class_map [1887].handle = objc_getClass ("IKDeviceBrowserView");
	__xamarin_class_map [1888].handle = objc_getClass ("IKFilterBrowserPanel");
	__xamarin_class_map [1889].handle = objc_getClass ("NSTabView");
	__xamarin_class_map [1890].handle = objc_getClass ("IKImageBrowserView");
	__xamarin_class_map [1891].handle = objc_getClass ("IKSaveOptions");
	__xamarin_class_map [1892].handle = objc_getClass ("NSText");
	__xamarin_class_map [1893].handle = objc_getClass ("NSTextInputContext");
	__xamarin_class_map [1894].handle = objc_getClass ("NSTextAlternatives");
	__xamarin_class_map [1895].handle = objc_getClass ("IKScannerDeviceView");
	__xamarin_class_map [1896].handle = objc_getClass ("SBApplication");
	__xamarin_class_map [1897].handle = objc_getClass ("NSTouchBar");
	__xamarin_class_map [1898].handle = objc_getClass ("SCNLayer");
	__xamarin_class_map [1899].handle = objc_getClass ("INInteraction");
	__xamarin_class_map [1900].handle = objc_getClass ("SLRequest");
	__xamarin_class_map [1901].handle = objc_getClass ("NSTextView");
	__xamarin_class_map [1902].handle = objc_getClass ("NSMetadataQuery");
	__xamarin_class_map [1903].handle = objc_getClass ("NSToolbar");
	__xamarin_class_map [1904].handle = objc_getClass ("LAContext");
	__xamarin_class_map [1905].handle = objc_getClass ("NSManagedObjectContext");
	__xamarin_class_map [1906].handle = objc_getClass ("AVAssetExportSession");
	__xamarin_class_map [1907].handle = objc_getClass ("NSPersistentContainer");
	__xamarin_class_map [1908].handle = objc_getClass ("SCNPhysicsWorld");
	__xamarin_class_map [1909].handle = objc_getClass ("MKMapSnapshotter");
	__xamarin_class_map [1910].handle = objc_getClass ("MKMapView");
	__xamarin_class_map [1911].handle = objc_getClass ("SCNRenderer");
	__xamarin_class_map [1912].handle = objc_getClass ("AVAssetWriter");
	__xamarin_class_map [1913].handle = objc_getClass ("SKPhysicsWorld");
	__xamarin_class_map [1914].handle = objc_getClass ("SKTextureAtlas");
	__xamarin_class_map [1915].handle = objc_getClass ("SCNView");
	__xamarin_class_map [1916].handle = objc_getClass ("AVAudioEngine");
	__xamarin_class_map [1917].handle = objc_getClass ("SKProductsRequest");
	__xamarin_class_map [1918].handle = objc_getClass ("AVAudioPlayerNode");
	__xamarin_class_map [1919].handle = objc_getClass ("AUAudioUnit");
	__xamarin_class_map [1920].handle = [Xwt_Mac_WindowBackend class];
	__xamarin_class_map [1921].handle = [MonoDevelop_MacIntegration_ThemedMacWindowBackend class];
	__xamarin_class_map [1922].handle = [Xwt_Mac_DialogBackend class];
	__xamarin_class_map [1923].handle = [MonoDevelop_MacIntegration_ThemedMacDialogBackend class];
	__xamarin_class_map [1924].handle = [Xwt_Mac_AlertDialogBackend class];
	__xamarin_class_map [1925].handle = [MonoDevelop_MacIntegration_ThemedMacAlertDialogBackend class];
	__xamarin_class_map [1926].handle = [MonoDevelop_MacIntegration_MDLabel class];
	__xamarin_class_map [1927].handle = [MonoDevelop_MacIntegration_AlertButtonWrapper class];
	__xamarin_class_map [1928].handle = [MonoDevelop_MacIntegration_MainToolbar_NSFocusButton class];
	__xamarin_class_map [1929].handle = [RunButton class];
	__xamarin_class_map [1930].handle = [MonoDevelop_MacIntegration_MainToolbar_ColoredButtonCell class];
	__xamarin_class_map [1931].handle = [MonoDevelop_MacIntegration_MainToolbar_StatusIcon class];
	__xamarin_class_map [1932].handle = [MonoDevelop_MacIntegration_MainToolbar_CancelButton class];
	__xamarin_class_map [1933].handle = [MonoDevelop_MacIntegration_MainToolbar_VerticallyCenteredTextFieldCell class];
	__xamarin_class_map [1934].handle = [MonoDevelop_MacIntegration_MainToolbar_AwesomeBar class];
	__xamarin_class_map [1935].handle = [MonoDevelop_MacIntegration_MainToolbar_ButtonBarContainer class];
	__xamarin_class_map [1936].handle = [MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingSource class];
	__xamarin_class_map [1937].handle = [MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingAllDelegate class];
	__xamarin_class_map [1938].handle = [MonoDevelop_MacIntegration_SelectEncodingPanel_EncodingSelectedDelegate class];
	__xamarin_class_map [1939].handle = [MonoDevelop_MacIntegration_SelectEncodingPanel class];
	__xamarin_class_map [1940].handle = [MonoDevelop_MacIntegration_SelectEncodingPopUpButton class];
	__xamarin_class_map [1941].handle = [MonoDevelop_MacIntegration_MainToolbar_SearchBar_DarkThemeSearchFieldCell class];
	__xamarin_class_map [1942].handle = [MonoDevelop_MacIntegration_MainToolbar_SearchBar class];
	__xamarin_class_map [1943].handle = [MonoDevelop_MacIntegration_MainToolbar_ButtonBar_DarkThemeSegmentedCell class];
	__xamarin_class_map [1944].handle = [MonoDevelop_MacIntegration_MainToolbar_ButtonBar class];
	__xamarin_class_map [1945].handle = [MonoDevelop_MacIntegration_MainToolbar_SelectorView class];
	__xamarin_class_map [1946].handle = [MonoDevelop_MacIntegration_MainToolbar_BuildResultsView class];
	__xamarin_class_map [1947].handle = [MonoDevelop_MacIntegration_MainToolbar_ProgressView class];
	__xamarin_class_map [1948].handle = [MonoDevelop_MacIntegration_MainToolbar_StatusBar class];
	__xamarin_class_map [1949].handle = [MonoDevelop_MacIntegration_MainToolbar_SelectorView_PathSelectorView_NSPathComponentCellFocusable class];
	__xamarin_class_map [1950].handle = [MonoDevelop_MacIntegration_MainToolbar_SelectorView_PathSelectorView class];
	__xamarin_class_map [1951].handle = [MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementProxy class];
	__xamarin_class_map [1952].handle = [MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementButtonProxy class];
	__xamarin_class_map [1953].handle = [MonoDevelop_Components_AtkCocoaHelper_RealAccessibilityElementNavigableStaticTextProxy class];
	__xamarin_class_map [1954].handle = [MonoDevelop_Components_Mac_MDLinkMenuItem class];
	__xamarin_class_map [1955].handle = [MonoDevelop_Components_Mac_MDMenuHeaderItem class];
	__xamarin_class_map [1956].handle = [MonoDevelop_Components_Mac_MDServicesMenuItem class];
	__xamarin_class_map [1957].handle = [MonoDevelop_Components_Mac_MDMenu class];
	__xamarin_class_map [1958].handle = [MonoDevelop_Components_Mac_MDMenuItem_MDExpandedArrayItem class];
	__xamarin_class_map [1959].handle = [MonoDevelop_Components_Mac_MDMenuItem class];
	__xamarin_class_map [1960].handle = [MonoDevelop_Components_Mac_MDSubMenuItem class];
	__xamarin_class_map [1961].handle = [MonoDevelop_Components_Mac_GtkEmbed class];
	__xamarin_class_map [1962].handle = [MonoDevelop_Components_ContextMenuExtensionsMac_NSLocationAwareMenu_ContextMenuDelegate class];
	__xamarin_class_map [1963].handle = [MonoDevelop_Components_ContextMenuExtensionsMac_NSLocationAwareMenu class];
	__xamarin_class_map [1964].handle = objc_getClass ("NETunnelNetworkSettings");
	__xamarin_class_map [1965].handle = objc_getClass ("NEPacketTunnelNetworkSettings");
	__xamarin_class_map [1966].handle = objc_getClass ("PHAdjustmentData");
	__xamarin_class_map [1967].handle = objc_getClass ("PHObject");
	__xamarin_class_map [1968].handle = objc_getClass ("PHAsset");
	__xamarin_class_map [1969].handle = objc_getClass ("PHCollection");
	__xamarin_class_map [1970].handle = objc_getClass ("PHAssetCollection");
	__xamarin_class_map [1971].handle = objc_getClass ("PHChange");
	__xamarin_class_map [1972].handle = objc_getClass ("PHCloudIdentifier");
	__xamarin_class_map [1973].handle = objc_getClass ("PHCollectionList");
	__xamarin_class_map [1974].handle = objc_getClass ("PHContentEditingInput");
	__xamarin_class_map [1975].handle = objc_getClass ("PHContentEditingOutput");
	__xamarin_class_map [1976].handle = objc_getClass ("PHFetchOptions");
	__xamarin_class_map [1977].handle = objc_getClass ("PHFetchResult");
	__xamarin_class_map [1978].handle = objc_getClass ("PHFetchResultChangeDetails");
	__xamarin_class_map [1979].handle = objc_getClass ("PHImageManager");
	__xamarin_class_map [1980].handle = objc_getClass ("PHImageRequestOptions");
	__xamarin_class_map [1981].handle = objc_getClass ("PHLivePhoto");
	__xamarin_class_map [1982].handle = objc_getClass ("EASession");
	__xamarin_class_map [1983].handle = objc_getClass ("PHObjectChangeDetails");
	__xamarin_class_map [1984].handle = objc_getClass ("PHProject");
	__xamarin_class_map [1985].handle = objc_getClass ("PHProjectChangeRequest");
	__xamarin_class_map [1986].handle = objc_getClass ("PHProjectElement");
	__xamarin_class_map [1987].handle = objc_getClass ("PHProjectAssetElement");
	__xamarin_class_map [1988].handle = objc_getClass ("PHProjectExtensionContext");
	__xamarin_class_map [1989].handle = objc_getClass ("PHProjectInfo");
	__xamarin_class_map [1990].handle = objc_getClass ("PHProjectJournalEntryElement");
	__xamarin_class_map [1991].handle = objc_getClass ("PHProjectRegionOfInterest");
	__xamarin_class_map [1992].handle = objc_getClass ("PHProjectSection");
	__xamarin_class_map [1993].handle = objc_getClass ("PHProjectSectionContent");
	__xamarin_class_map [1994].handle = objc_getClass ("PHProjectTextElement");
	__xamarin_class_map [1995].handle = objc_getClass ("PHProjectTypeDescription");
	__xamarin_class_map [1996].handle = objc_getClass ("CNContactPicker");
	__xamarin_class_map [1997].handle = objc_getClass ("CNContactViewController");
	__xamarin_class_map [1998].handle = objc_getClass ("AUAudioUnitViewConfiguration");
	__xamarin_class_map [1999].handle = objc_getClass ("AUViewController");
	__xamarin_class_map [2000].handle = objc_getClass ("NEAppRule");
	__xamarin_class_map [2001].handle = objc_getClass ("NEVPNProtocol");
	__xamarin_class_map [2002].handle = objc_getClass ("NEDNSProxyProviderProtocol");
	__xamarin_class_map [2003].handle = objc_getClass ("NEDNSSettings");
	__xamarin_class_map [2004].handle = objc_getClass ("NEEvaluateConnectionRule");
	__xamarin_class_map [2005].handle = objc_getClass ("NEFilterProviderConfiguration");
	__xamarin_class_map [2006].handle = objc_getClass ("NEFlowMetaData");
	__xamarin_class_map [2007].handle = objc_getClass ("NEIPv4Route");
	__xamarin_class_map [2008].handle = objc_getClass ("NEIPv4Settings");
	__xamarin_class_map [2009].handle = objc_getClass ("NEIPv6Route");
	__xamarin_class_map [2010].handle = objc_getClass ("NEIPv6Settings");
	__xamarin_class_map [2011].handle = objc_getClass ("NEOnDemandRule");
	__xamarin_class_map [2012].handle = objc_getClass ("NEOnDemandRuleConnect");
	__xamarin_class_map [2013].handle = objc_getClass ("NEOnDemandRuleDisconnect");
	__xamarin_class_map [2014].handle = objc_getClass ("NEOnDemandRuleEvaluateConnection");
	__xamarin_class_map [2015].handle = objc_getClass ("NEOnDemandRuleIgnore");
	__xamarin_class_map [2016].handle = objc_getClass ("NEPacket");
	__xamarin_class_map [2017].handle = objc_getClass ("NEProxyServer");
	__xamarin_class_map [2018].handle = objc_getClass ("NEProxySettings");
	__xamarin_class_map [2019].handle = objc_getClass ("NETunnelProviderProtocol");
	__xamarin_class_map [2020].handle = objc_getClass ("NEVPNConnection");
	__xamarin_class_map [2021].handle = objc_getClass ("NETunnelProviderSession");
	__xamarin_class_map [2022].handle = objc_getClass ("NEVPNIKEv2SecurityAssociationParameters");
	__xamarin_class_map [2023].handle = objc_getClass ("NEVPNProtocolIPSec");
	__xamarin_class_map [2024].handle = objc_getClass ("NEVPNProtocolIKEv2");
	__xamarin_class_map [2025].handle = objc_getClass ("NWEndpoint");
	__xamarin_class_map [2026].handle = objc_getClass ("NWBonjourServiceEndpoint");
	__xamarin_class_map [2027].handle = objc_getClass ("NWHostEndpoint");
	__xamarin_class_map [2028].handle = objc_getClass ("NWPath");
	__xamarin_class_map [2029].handle = objc_getClass ("NWTLSParameters");
	__xamarin_class_map [2030].handle = objc_getClass ("Foundation_NSUrlSessionHandler_WrappedNSInputStream");
	__xamarin_class_map [2031].handle = objc_getClass ("NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate");
	__xamarin_class_map [2032].handle = objc_getClass ("NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate");
	__xamarin_class_map [2033].handle = objc_getClass ("CoreAnimation_CAAnimation__CAAnimationDelegate");
	__xamarin_class_map [2034].handle = objc_getClass ("Foundation_NSNetService__NSNetServiceDelegate");
	__xamarin_class_map [2035].handle = objc_getClass ("Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate");
	__xamarin_class_map [2036].handle = objc_getClass ("__NSObject_Disposer");
	__xamarin_class_map [2037].handle = objc_getClass ("__XamarinObjectObserver");
	__xamarin_class_map [2038].handle = objc_getClass ("CoreLocation_CLLocationManager__CLLocationManagerDelegate");
	__xamarin_class_map [2039].handle = objc_getClass ("AVFoundation_AVCaptureFileOutput_recordingProxy");
	__xamarin_class_map [2040].handle = objc_getClass ("AppKit_NSAlert__NSAlertDelegate");
	__xamarin_class_map [2041].handle = objc_getClass ("AppKit_NSAnimation__NSAnimationDelegate");
	__xamarin_class_map [2042].handle = objc_getClass ("Foundation_NSStream__NSStreamDelegate");
	__xamarin_class_map [2043].handle = objc_getClass ("AppKit_NSApplication__NSApplicationDelegate");
	__xamarin_class_map [2044].handle = objc_getClass ("Foundation_NSThread_ActionThread");
	__xamarin_class_map [2045].handle = objc_getClass ("WebKit_DomNode_DomNodeEventProxy");
	__xamarin_class_map [2046].handle = objc_getClass ("WebKit_DomNode_DomNodeEventProxy2");
	__xamarin_class_map [2047].handle = objc_getClass ("__NSGestureRecognizerToken");
	__xamarin_class_map [2048].handle = objc_getClass ("__NSClickGestureRecognizer");
	__xamarin_class_map [2049].handle = objc_getClass ("NEProvider");
	__xamarin_class_map [2050].handle = objc_getClass ("NETunnelProvider");
	__xamarin_class_map [2051].handle = objc_getClass ("NEPacketTunnelProvider");
	__xamarin_class_map [2052].handle = objc_getClass ("NEVPNManager");
	__xamarin_class_map [2053].handle = objc_getClass ("AppKit_NSTextField__NSTextFieldDelegate");
	__xamarin_class_map [2054].handle = objc_getClass ("AppKit_NSComboBox__NSComboBoxDelegate");
	__xamarin_class_map [2055].handle = objc_getClass ("AppKit_NSDatePicker__NSDatePickerCellDelegate");
	__xamarin_class_map [2056].handle = objc_getClass ("AppKit_NSDatePickerCell__NSDatePickerCellDelegate");
	__xamarin_class_map [2057].handle = objc_getClass ("WebKit_WebView__WebFrameLoadDelegate");
	__xamarin_class_map [2058].handle = objc_getClass ("WebKit_WebView__WebDownloadDelegate");
	__xamarin_class_map [2059].handle = objc_getClass ("WebKit_WebView__WebResourceLoadDelegate");
	__xamarin_class_map [2060].handle = objc_getClass ("WebKit_WebView__WebUIDelegate");
	__xamarin_class_map [2061].handle = objc_getClass ("WebKit_WebView__WebPolicyDelegate");
	__xamarin_class_map [2062].handle = objc_getClass ("__NSDocumentDuplicateCallback");
	__xamarin_class_map [2063].handle = objc_getClass ("Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate");
	__xamarin_class_map [2064].handle = objc_getClass ("AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate");
	__xamarin_class_map [2065].handle = objc_getClass ("__NSGestureRecognizerParameterlessToken");
	__xamarin_class_map [2066].handle = objc_getClass ("__NSGestureRecognizerParametrizedToken");
	__xamarin_class_map [2067].handle = objc_getClass ("AppKit_NSDrawer__NSDrawerDelegate");
	__xamarin_class_map [2068].handle = objc_getClass ("GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate");
	__xamarin_class_map [2069].handle = objc_getClass ("GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate");
	__xamarin_class_map [2070].handle = objc_getClass ("CoreBluetooth_CBCentralManager__CBCentralManagerDelegate");
	__xamarin_class_map [2071].handle = objc_getClass ("CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate");
	__xamarin_class_map [2072].handle = objc_getClass ("GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [2073].handle = objc_getClass ("CoreBluetooth_CBPeripheral__CBPeripheralDelegate");
	__xamarin_class_map [2074].handle = objc_getClass ("AppKit_NSImage__NSImageDelegate");
	__xamarin_class_map [2075].handle = objc_getClass ("PdfKit_PdfDocument__PdfDocumentDelegate");
	__xamarin_class_map [2076].handle = objc_getClass ("__NSMagnificationGestureRecognizer");
	__xamarin_class_map [2077].handle = objc_getClass ("AppKit_NSMatrix__NSMatrixDelegate");
	__xamarin_class_map [2078].handle = objc_getClass ("GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [2079].handle = objc_getClass ("GameKit_GKMatch__GKMatchDelegate");
	__xamarin_class_map [2080].handle = objc_getClass ("GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [2081].handle = objc_getClass ("PdfKit_PdfView__PdfViewDelegate");
	__xamarin_class_map [2082].handle = objc_getClass ("AppKit_NSPageController__NSPageControllerDelegate");
	__xamarin_class_map [2083].handle = objc_getClass ("__NSPanGestureRecognizer");
	__xamarin_class_map [2084].handle = objc_getClass ("Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate");
	__xamarin_class_map [2085].handle = objc_getClass ("Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate");
	__xamarin_class_map [2086].handle = objc_getClass ("AppKit_NSPathCell__NSPathCellDelegate");
	__xamarin_class_map [2087].handle = objc_getClass ("PHLivePhotoEditingContext");
	__xamarin_class_map [2088].handle = objc_getClass ("ExternalAccessory_EAAccessory__EAAccessoryDelegate");
	__xamarin_class_map [2089].handle = objc_getClass ("EAAccessory");
	__xamarin_class_map [2090].handle = objc_getClass ("EAAccessoryManager");
	__xamarin_class_map [2091].handle = objc_getClass ("PHPhotoLibrary");
	__xamarin_class_map [2092].handle = objc_getClass ("__NSPressGestureRecognizer");
	__xamarin_class_map [2093].handle = objc_getClass ("Foundation_NSCache__NSCacheDelegate");
	__xamarin_class_map [2094].handle = objc_getClass ("__NSRotationGestureRecognizer");
	__xamarin_class_map [2095].handle = objc_getClass ("AppKit_NSRuleEditor__NSRuleEditorDelegate");
	__xamarin_class_map [2096].handle = objc_getClass ("AppKit_NSSearchField__NSSearchFieldDelegate");
	__xamarin_class_map [2097].handle = objc_getClass ("AppKit_NSSavePanel__NSOpenSavePanelDelegate");
	__xamarin_class_map [2098].handle = objc_getClass ("AppKit_NSTableView__NSTableViewDelegate");
	__xamarin_class_map [2099].handle = objc_getClass ("AppKit_NSSharingService__NSSharingServiceDelegate");
	__xamarin_class_map [2100].handle = objc_getClass ("AppKit_NSSound__NSSoundDelegate");
	__xamarin_class_map [2101].handle = objc_getClass ("AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate");
	__xamarin_class_map [2102].handle = objc_getClass ("AppKit_NSTextStorage__NSTextStorageDelegate");
	__xamarin_class_map [2103].handle = objc_getClass ("AppKit_NSWindow__NSWindowDelegate");
	__xamarin_class_map [2104].handle = objc_getClass ("ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate");
	__xamarin_class_map [2105].handle = objc_getClass ("ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate");
	__xamarin_class_map [2106].handle = objc_getClass ("AppKit_NSTabView__NSTabViewDelegate");
	__xamarin_class_map [2107].handle = objc_getClass ("ImageKit_IKImageBrowserView__IKImageBrowserDelegate");
	__xamarin_class_map [2108].handle = objc_getClass ("ImageKit_IKSaveOptions__IKSaveOptionsDelegate");
	__xamarin_class_map [2109].handle = objc_getClass ("AppKit_NSText__NSTextDelegate");
	__xamarin_class_map [2110].handle = objc_getClass ("ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate");
	__xamarin_class_map [2111].handle = objc_getClass ("NEAppProxyFlow");
	__xamarin_class_map [2112].handle = objc_getClass ("NEAppProxyProvider");
	__xamarin_class_map [2113].handle = objc_getClass ("NETunnelProviderManager");
	__xamarin_class_map [2114].handle = objc_getClass ("NEAppProxyProviderManager");
	__xamarin_class_map [2115].handle = objc_getClass ("NEAppProxyTCPFlow");
	__xamarin_class_map [2116].handle = objc_getClass ("ScriptingBridge_SBApplication__SBApplicationDelegate");
	__xamarin_class_map [2117].handle = objc_getClass ("NEAppProxyUDPFlow");
	__xamarin_class_map [2118].handle = objc_getClass ("AppKit_NSTouchBar__NSTouchBarDelegate");
	__xamarin_class_map [2119].handle = objc_getClass ("NEFilterManager");
	__xamarin_class_map [2120].handle = objc_getClass ("NEFilterProvider");
	__xamarin_class_map [2121].handle = objc_getClass ("AppKit_NSTextView__NSTextViewDelegate");
	__xamarin_class_map [2122].handle = objc_getClass ("NEPacketTunnelFlow");
	__xamarin_class_map [2123].handle = objc_getClass ("Foundation_NSMetadataQuery__NSMetadataQueryDelegate");
	__xamarin_class_map [2124].handle = objc_getClass ("AppKit_NSToolbar__NSToolbarDelegate");
	__xamarin_class_map [2125].handle = objc_getClass ("NWTCPConnection");
	__xamarin_class_map [2126].handle = objc_getClass ("NWUDPSession");
	__xamarin_class_map [2127].handle = objc_getClass ("SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate");
	__xamarin_class_map [2128].handle = objc_getClass ("MapKit_MKMapView__MKMapViewDelegate");
	__xamarin_class_map [2129].handle = objc_getClass ("SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate");
	__xamarin_class_map [2130].handle = objc_getClass ("StoreKit_SKRequest__SKRequestDelegate");
	__xamarin_class_map [2131].handle = objc_getClass ("StoreKit_SKProductsRequest__SKProductsRequestDelegate");
	__xamarin_class_map [2132].handle = objc_getClass ("Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate");
	__xamarin_class_map [2133].handle = [Xwt_Gtk_Mac_GtkMacSaveFileDialogBackend class];
	__xamarin_class_map [2134].handle = [Xwt_Gtk_Mac_WebViewBackend_XwtWebUIDelegate class];
	__xamarin_class_map [2135].handle = [Xwt_Gtk_Mac_GtkMacOpenFileDialogBackend class];
	__xamarin_class_map [2136].handle = [Xwt_Gtk_Mac_GtkMacSelectFolderBackend class];
	__xamarin_class_map [2137].handle = [Xwt_Mac_WidgetView class];
	__xamarin_class_map [2138].handle = [Xwt_Mac_CustomAlignedContainer class];
	__xamarin_class_map [2139].handle = [Xwt_Mac_TextFieldView class];
	__xamarin_class_map [2140].handle = [Xwt_Mac_CustomTextFieldCell class];
	__xamarin_class_map [2141].handle = [Xwt_Mac_AppDelegate class];
	__xamarin_class_map [2142].handle = [Xwt_Mac_TabView class];
	__xamarin_class_map [2143].handle = [Xwt_Mac_TreeItem class];
	__xamarin_class_map [2144].handle = [Xwt_Mac_TreeSource class];
	__xamarin_class_map [2145].handle = [Xwt_Mac_WidgetPlacementWrapper class];
	__xamarin_class_map [2146].handle = [Xwt_Mac_WindowBackendController class];
	__xamarin_class_map [2147].handle = [Xwt_Mac_TextTableCell class];
	__xamarin_class_map [2148].handle = [Xwt_Mac_ImageTableCell class];
	__xamarin_class_map [2149].handle = [Xwt_Mac_TableRow class];
	__xamarin_class_map [2150].handle = [Xwt_Mac_ListSource class];
	__xamarin_class_map [2151].handle = [Xwt_Mac_ScrollView class];
	__xamarin_class_map [2152].handle = [Xwt_Mac_MenuBackend class];
	__xamarin_class_map [2153].handle = [Xwt_Mac_PopUpButton class];
	__xamarin_class_map [2154].handle = [Xwt_Mac_ComboDataSource class];
	__xamarin_class_map [2155].handle = [Xwt_Mac_MacFrame class];
	__xamarin_class_map [2156].handle = [Xwt_Mac_CustomContentView class];
	__xamarin_class_map [2157].handle = [Xwt_Mac_CustomScrollView class];
	__xamarin_class_map [2158].handle = [Xwt_Mac_DummyClipView class];
	__xamarin_class_map [2159].handle = [Xwt_Mac_CustomClipView class];
	__xamarin_class_map [2160].handle = [Xwt_Mac_NormalClipView class];
	__xamarin_class_map [2161].handle = [Xwt_Mac_SeparatorWidget class];
	__xamarin_class_map [2162].handle = [Xwt_Mac_CustomSplitView class];
	__xamarin_class_map [2163].handle = [Xwt_Mac_ProgressIndicatorView class];
	__xamarin_class_map [2164].handle = [Xwt_Mac_MacExpander class];
	__xamarin_class_map [2165].handle = [Xwt_Mac_ExpanderWidget class];
	__xamarin_class_map [2166].handle = [Xwt_Mac_CollapsibleBox class];
	__xamarin_class_map [2167].handle = [Xwt_Mac_LinkLabelView class];
	__xamarin_class_map [2168].handle = [Xwt_Mac_FileDialogBackend class];
	__xamarin_class_map [2169].handle = [Xwt_Mac_OpenFileDialogBackend class];
	__xamarin_class_map [2170].handle = [XwtPasteboardOwner class];
	__xamarin_class_map [2171].handle = [Xwt_Mac_CustomWidgetView class];
	__xamarin_class_map [2172].handle = [Xwt_Mac_CustomScroller class];
	__xamarin_class_map [2173].handle = [Xwt_Mac_MacDatePicker class];
	__xamarin_class_map [2174].handle = [Xwt_Mac_MacSlider class];
	__xamarin_class_map [2175].handle = [Xwt_Mac_MacSliderCell class];
	__xamarin_class_map [2176].handle = [Xwt_Mac_CheckBoxTableCell class];
	__xamarin_class_map [2177].handle = [Xwt_Mac_MacWebView class];
	__xamarin_class_map [2178].handle = [Xwt_Mac_XwtWebUIDelegate class];
	__xamarin_class_map [2179].handle = [Xwt_Mac_SaveFileDialogBackend class];
	__xamarin_class_map [2180].handle = [Xwt_Mac_MacColorWell class];
	__xamarin_class_map [2181].handle = [Xwt_Mac_MacCalendar class];
	__xamarin_class_map [2182].handle = [Xwt_Mac_FontPanelDelegate class];
	__xamarin_class_map [2183].handle = [Xwt_Mac_RadioButtonTableCell class];
	__xamarin_class_map [2184].handle = [Xwt_Mac_MacButton class];
	__xamarin_class_map [2185].handle = [Xwt_Mac_TreeViewBackend_TreeDelegate class];
	__xamarin_class_map [2186].handle = [Xwt_Mac_CompositeCell class];
	__xamarin_class_map [2187].handle = [Xwt_Mac_CustomImage class];
	__xamarin_class_map [2188].handle = [Xwt_Mac_CanvasView class];
	__xamarin_class_map [2189].handle = [Xwt_Mac_CustomTextField_CustomCell class];
	__xamarin_class_map [2190].handle = [Xwt_Mac_CustomTextField class];
	__xamarin_class_map [2191].handle = [Xwt_Mac_MacComboBox class];
	__xamarin_class_map [2192].handle = [Xwt_Mac_PanedBackend_SplitViewDelegate class];
	__xamarin_class_map [2193].handle = [Xwt_Mac_MacSpinButton_VibrancyStepper class];
	__xamarin_class_map [2194].handle = [Xwt_Mac_MacSpinButton class];
	__xamarin_class_map [2195].handle = [Xwt_Mac_PopoverBackend_NSAppearanceCustomizationPopover class];
	__xamarin_class_map [2196].handle = [Xwt_Mac_SelectFolderDialogBackend class];
	__xamarin_class_map [2197].handle = [Xwt_Mac_MacMenuButton class];
	__xamarin_class_map [2198].handle = [Xwt_Mac_CanvasTableCell class];
	__xamarin_class_map [2199].handle = [Xwt_Mac_MacTextView class];
	__xamarin_class_map [2200].handle = [Xwt_Mac_CustomSecureTextField class];
	__xamarin_class_map [2201].handle = [Xwt_Mac_NSTableViewBackend_ListDelegate class];
	__xamarin_class_map [2202].handle = [Xwt_Mac_NSTableViewBackend class];
	__xamarin_class_map [2203].handle = [Xwt_Mac_OutlineViewBackend class];
	__xamarin_class_map [2204].handle = [Xwt_Mac_PopupWindowBackend class];
	__xamarin_class_map [2205].handle = [Xwt_Mac_MacButton_ColoredButtonCell class];
	__xamarin_class_map [2206].handle = [Xwt_Mac_CustomTextField_CustomEditor class];
	__xamarin_class_map [2207].handle = [Xwt_Mac_PopoverBackend_FactoryViewController_ContainerView class];
	__xamarin_class_map [2208].handle = [Xwt_Mac_PopoverBackend_FactoryViewController class];
	__xamarin_class_map [2209].handle = [Xwt_Mac_MacMenuButton_ColoredPopUpButtonCell class];
	xamarin_add_registration_map (&__xamarin_registration_map);
}


} /* extern "C" */
